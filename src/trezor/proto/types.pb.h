// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#ifndef PROTOBUF_types_2eproto__INCLUDED
#define PROTOBUF_types_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
namespace TrezorProtobuf {
class CoinType;
class CoinTypeDefaultTypeInternal;
extern CoinTypeDefaultTypeInternal _CoinType_default_instance_;
class HDNodePathType;
class HDNodePathTypeDefaultTypeInternal;
extern HDNodePathTypeDefaultTypeInternal _HDNodePathType_default_instance_;
class HDNodeType;
class HDNodeTypeDefaultTypeInternal;
extern HDNodeTypeDefaultTypeInternal _HDNodeType_default_instance_;
class IdentityType;
class IdentityTypeDefaultTypeInternal;
extern IdentityTypeDefaultTypeInternal _IdentityType_default_instance_;
class MultisigRedeemScriptType;
class MultisigRedeemScriptTypeDefaultTypeInternal;
extern MultisigRedeemScriptTypeDefaultTypeInternal _MultisigRedeemScriptType_default_instance_;
class TransactionType;
class TransactionTypeDefaultTypeInternal;
extern TransactionTypeDefaultTypeInternal _TransactionType_default_instance_;
class TxInputType;
class TxInputTypeDefaultTypeInternal;
extern TxInputTypeDefaultTypeInternal _TxInputType_default_instance_;
class TxOutputBinType;
class TxOutputBinTypeDefaultTypeInternal;
extern TxOutputBinTypeDefaultTypeInternal _TxOutputBinType_default_instance_;
class TxOutputType;
class TxOutputTypeDefaultTypeInternal;
extern TxOutputTypeDefaultTypeInternal _TxOutputType_default_instance_;
class TxRequestDetailsType;
class TxRequestDetailsTypeDefaultTypeInternal;
extern TxRequestDetailsTypeDefaultTypeInternal _TxRequestDetailsType_default_instance_;
class TxRequestSerializedType;
class TxRequestSerializedTypeDefaultTypeInternal;
extern TxRequestSerializedTypeDefaultTypeInternal _TxRequestSerializedType_default_instance_;
}  // namespace TrezorProtobuf
namespace google {
namespace protobuf {
class DescriptorProto;
class DescriptorProtoDefaultTypeInternal;
extern DescriptorProtoDefaultTypeInternal _DescriptorProto_default_instance_;
class DescriptorProto_ExtensionRange;
class DescriptorProto_ExtensionRangeDefaultTypeInternal;
extern DescriptorProto_ExtensionRangeDefaultTypeInternal _DescriptorProto_ExtensionRange_default_instance_;
class EnumDescriptorProto;
class EnumDescriptorProtoDefaultTypeInternal;
extern EnumDescriptorProtoDefaultTypeInternal _EnumDescriptorProto_default_instance_;
class EnumOptions;
class EnumOptionsDefaultTypeInternal;
extern EnumOptionsDefaultTypeInternal _EnumOptions_default_instance_;
class EnumValueDescriptorProto;
class EnumValueDescriptorProtoDefaultTypeInternal;
extern EnumValueDescriptorProtoDefaultTypeInternal _EnumValueDescriptorProto_default_instance_;
class EnumValueOptions;
class EnumValueOptionsDefaultTypeInternal;
extern EnumValueOptionsDefaultTypeInternal _EnumValueOptions_default_instance_;
class FieldDescriptorProto;
class FieldDescriptorProtoDefaultTypeInternal;
extern FieldDescriptorProtoDefaultTypeInternal _FieldDescriptorProto_default_instance_;
class FieldOptions;
class FieldOptionsDefaultTypeInternal;
extern FieldOptionsDefaultTypeInternal _FieldOptions_default_instance_;
class FileDescriptorProto;
class FileDescriptorProtoDefaultTypeInternal;
extern FileDescriptorProtoDefaultTypeInternal _FileDescriptorProto_default_instance_;
class FileDescriptorSet;
class FileDescriptorSetDefaultTypeInternal;
extern FileDescriptorSetDefaultTypeInternal _FileDescriptorSet_default_instance_;
class FileOptions;
class FileOptionsDefaultTypeInternal;
extern FileOptionsDefaultTypeInternal _FileOptions_default_instance_;
class MessageOptions;
class MessageOptionsDefaultTypeInternal;
extern MessageOptionsDefaultTypeInternal _MessageOptions_default_instance_;
class MethodDescriptorProto;
class MethodDescriptorProtoDefaultTypeInternal;
extern MethodDescriptorProtoDefaultTypeInternal _MethodDescriptorProto_default_instance_;
class MethodOptions;
class MethodOptionsDefaultTypeInternal;
extern MethodOptionsDefaultTypeInternal _MethodOptions_default_instance_;
class ServiceDescriptorProto;
class ServiceDescriptorProtoDefaultTypeInternal;
extern ServiceDescriptorProtoDefaultTypeInternal _ServiceDescriptorProto_default_instance_;
class ServiceOptions;
class ServiceOptionsDefaultTypeInternal;
extern ServiceOptionsDefaultTypeInternal _ServiceOptions_default_instance_;
class SourceCodeInfo;
class SourceCodeInfoDefaultTypeInternal;
extern SourceCodeInfoDefaultTypeInternal _SourceCodeInfo_default_instance_;
class SourceCodeInfo_Location;
class SourceCodeInfo_LocationDefaultTypeInternal;
extern SourceCodeInfo_LocationDefaultTypeInternal _SourceCodeInfo_Location_default_instance_;
class UninterpretedOption;
class UninterpretedOptionDefaultTypeInternal;
extern UninterpretedOptionDefaultTypeInternal _UninterpretedOption_default_instance_;
class UninterpretedOption_NamePart;
class UninterpretedOption_NamePartDefaultTypeInternal;
extern UninterpretedOption_NamePartDefaultTypeInternal _UninterpretedOption_NamePart_default_instance_;
}  // namespace protobuf
}  // namespace google

namespace TrezorProtobuf {

namespace protobuf_types_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_types_2eproto

enum FailureType {
  Failure_UnexpectedMessage = 1,
  Failure_ButtonExpected = 2,
  Failure_SyntaxError = 3,
  Failure_ActionCancelled = 4,
  Failure_PinExpected = 5,
  Failure_PinCancelled = 6,
  Failure_PinInvalid = 7,
  Failure_InvalidSignature = 8,
  Failure_Other = 9,
  Failure_NotEnoughFunds = 10,
  Failure_NotInitialized = 11,
  Failure_FirmwareError = 99
};
bool FailureType_IsValid(int value);
const FailureType FailureType_MIN = Failure_UnexpectedMessage;
const FailureType FailureType_MAX = Failure_FirmwareError;
const int FailureType_ARRAYSIZE = FailureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FailureType_descriptor();
inline const ::std::string& FailureType_Name(FailureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FailureType_descriptor(), value);
}
inline bool FailureType_Parse(
    const ::std::string& name, FailureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FailureType>(
    FailureType_descriptor(), name, value);
}
enum OutputScriptType {
  PAYTOADDRESS = 0,
  PAYTOSCRIPTHASH = 1,
  PAYTOMULTISIG = 2,
  PAYTOOPRETURN = 3,
  PAYTOWITNESS = 4,
  PAYTOP2SHWITNESS = 5
};
bool OutputScriptType_IsValid(int value);
const OutputScriptType OutputScriptType_MIN = PAYTOADDRESS;
const OutputScriptType OutputScriptType_MAX = PAYTOP2SHWITNESS;
const int OutputScriptType_ARRAYSIZE = OutputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OutputScriptType_descriptor();
inline const ::std::string& OutputScriptType_Name(OutputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OutputScriptType_descriptor(), value);
}
inline bool OutputScriptType_Parse(
    const ::std::string& name, OutputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OutputScriptType>(
    OutputScriptType_descriptor(), name, value);
}
enum InputScriptType {
  SPENDADDRESS = 0,
  SPENDMULTISIG = 1,
  EXTERNAL = 2,
  SPENDWITNESS = 3,
  SPENDP2SHWITNESS = 4
};
bool InputScriptType_IsValid(int value);
const InputScriptType InputScriptType_MIN = SPENDADDRESS;
const InputScriptType InputScriptType_MAX = SPENDP2SHWITNESS;
const int InputScriptType_ARRAYSIZE = InputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor();
inline const ::std::string& InputScriptType_Name(InputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InputScriptType_descriptor(), value);
}
inline bool InputScriptType_Parse(
    const ::std::string& name, InputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputScriptType>(
    InputScriptType_descriptor(), name, value);
}
enum RequestType {
  TXINPUT = 0,
  TXOUTPUT = 1,
  TXMETA = 2,
  TXFINISHED = 3,
  TXEXTRADATA = 4
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = TXINPUT;
const RequestType RequestType_MAX = TXEXTRADATA;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
enum ButtonRequestType {
  ButtonRequest_Other = 1,
  ButtonRequest_FeeOverThreshold = 2,
  ButtonRequest_ConfirmOutput = 3,
  ButtonRequest_ResetDevice = 4,
  ButtonRequest_ConfirmWord = 5,
  ButtonRequest_WipeDevice = 6,
  ButtonRequest_ProtectCall = 7,
  ButtonRequest_SignTx = 8,
  ButtonRequest_FirmwareCheck = 9,
  ButtonRequest_Address = 10,
  ButtonRequest_PublicKey = 11
};
bool ButtonRequestType_IsValid(int value);
const ButtonRequestType ButtonRequestType_MIN = ButtonRequest_Other;
const ButtonRequestType ButtonRequestType_MAX = ButtonRequest_PublicKey;
const int ButtonRequestType_ARRAYSIZE = ButtonRequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ButtonRequestType_descriptor();
inline const ::std::string& ButtonRequestType_Name(ButtonRequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ButtonRequestType_descriptor(), value);
}
inline bool ButtonRequestType_Parse(
    const ::std::string& name, ButtonRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ButtonRequestType>(
    ButtonRequestType_descriptor(), name, value);
}
enum PinMatrixRequestType {
  PinMatrixRequestType_Current = 1,
  PinMatrixRequestType_NewFirst = 2,
  PinMatrixRequestType_NewSecond = 3
};
bool PinMatrixRequestType_IsValid(int value);
const PinMatrixRequestType PinMatrixRequestType_MIN = PinMatrixRequestType_Current;
const PinMatrixRequestType PinMatrixRequestType_MAX = PinMatrixRequestType_NewSecond;
const int PinMatrixRequestType_ARRAYSIZE = PinMatrixRequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PinMatrixRequestType_descriptor();
inline const ::std::string& PinMatrixRequestType_Name(PinMatrixRequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PinMatrixRequestType_descriptor(), value);
}
inline bool PinMatrixRequestType_Parse(
    const ::std::string& name, PinMatrixRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PinMatrixRequestType>(
    PinMatrixRequestType_descriptor(), name, value);
}
enum RecoveryDeviceType {
  RecoveryDeviceType_ScrambledWords = 0,
  RecoveryDeviceType_Matrix = 1
};
bool RecoveryDeviceType_IsValid(int value);
const RecoveryDeviceType RecoveryDeviceType_MIN = RecoveryDeviceType_ScrambledWords;
const RecoveryDeviceType RecoveryDeviceType_MAX = RecoveryDeviceType_Matrix;
const int RecoveryDeviceType_ARRAYSIZE = RecoveryDeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RecoveryDeviceType_descriptor();
inline const ::std::string& RecoveryDeviceType_Name(RecoveryDeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RecoveryDeviceType_descriptor(), value);
}
inline bool RecoveryDeviceType_Parse(
    const ::std::string& name, RecoveryDeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RecoveryDeviceType>(
    RecoveryDeviceType_descriptor(), name, value);
}
enum WordRequestType {
  WordRequestType_Plain = 0,
  WordRequestType_Matrix9 = 1,
  WordRequestType_Matrix6 = 2
};
bool WordRequestType_IsValid(int value);
const WordRequestType WordRequestType_MIN = WordRequestType_Plain;
const WordRequestType WordRequestType_MAX = WordRequestType_Matrix6;
const int WordRequestType_ARRAYSIZE = WordRequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WordRequestType_descriptor();
inline const ::std::string& WordRequestType_Name(WordRequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WordRequestType_descriptor(), value);
}
inline bool WordRequestType_Parse(
    const ::std::string& name, WordRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WordRequestType>(
    WordRequestType_descriptor(), name, value);
}
// ===================================================================

class HDNodeType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.HDNodeType) */ {
 public:
  HDNodeType();
  virtual ~HDNodeType();

  HDNodeType(const HDNodeType& from);

  inline HDNodeType& operator=(const HDNodeType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HDNodeType& default_instance();

  static inline const HDNodeType* internal_default_instance() {
    return reinterpret_cast<const HDNodeType*>(
               &_HDNodeType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HDNodeType* other);

  // implements Message ----------------------------------------------

  inline HDNodeType* New() const PROTOBUF_FINAL { return New(NULL); }

  HDNodeType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HDNodeType& from);
  void MergeFrom(const HDNodeType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HDNodeType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes chain_code = 4;
  bool has_chain_code() const;
  void clear_chain_code();
  static const int kChainCodeFieldNumber = 4;
  const ::std::string& chain_code() const;
  void set_chain_code(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_code(::std::string&& value);
  #endif
  void set_chain_code(const char* value);
  void set_chain_code(const void* value, size_t size);
  ::std::string* mutable_chain_code();
  ::std::string* release_chain_code();
  void set_allocated_chain_code(::std::string* chain_code);

  // optional bytes private_key = 5;
  bool has_private_key() const;
  void clear_private_key();
  static const int kPrivateKeyFieldNumber = 5;
  const ::std::string& private_key() const;
  void set_private_key(const ::std::string& value);
  #if LANG_CXX11
  void set_private_key(::std::string&& value);
  #endif
  void set_private_key(const char* value);
  void set_private_key(const void* value, size_t size);
  ::std::string* mutable_private_key();
  ::std::string* release_private_key();
  void set_allocated_private_key(::std::string* private_key);

  // optional bytes public_key = 6;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 6;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // required uint32 depth = 1;
  bool has_depth() const;
  void clear_depth();
  static const int kDepthFieldNumber = 1;
  ::google::protobuf::uint32 depth() const;
  void set_depth(::google::protobuf::uint32 value);

  // required uint32 fingerprint = 2;
  bool has_fingerprint() const;
  void clear_fingerprint();
  static const int kFingerprintFieldNumber = 2;
  ::google::protobuf::uint32 fingerprint() const;
  void set_fingerprint(::google::protobuf::uint32 value);

  // required uint32 child_num = 3;
  bool has_child_num() const;
  void clear_child_num();
  static const int kChildNumFieldNumber = 3;
  ::google::protobuf::uint32 child_num() const;
  void set_child_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.HDNodeType)
 private:
  void set_has_depth();
  void clear_has_depth();
  void set_has_fingerprint();
  void clear_has_fingerprint();
  void set_has_child_num();
  void clear_has_child_num();
  void set_has_chain_code();
  void clear_has_chain_code();
  void set_has_private_key();
  void clear_has_private_key();
  void set_has_public_key();
  void clear_has_public_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr chain_code_;
  ::google::protobuf::internal::ArenaStringPtr private_key_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::uint32 depth_;
  ::google::protobuf::uint32 fingerprint_;
  ::google::protobuf::uint32 child_num_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HDNodePathType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.HDNodePathType) */ {
 public:
  HDNodePathType();
  virtual ~HDNodePathType();

  HDNodePathType(const HDNodePathType& from);

  inline HDNodePathType& operator=(const HDNodePathType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HDNodePathType& default_instance();

  static inline const HDNodePathType* internal_default_instance() {
    return reinterpret_cast<const HDNodePathType*>(
               &_HDNodePathType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HDNodePathType* other);

  // implements Message ----------------------------------------------

  inline HDNodePathType* New() const PROTOBUF_FINAL { return New(NULL); }

  HDNodePathType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HDNodePathType& from);
  void MergeFrom(const HDNodePathType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HDNodePathType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 2;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required .TrezorProtobuf.HDNodeType node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::TrezorProtobuf::HDNodeType& node() const;
  ::TrezorProtobuf::HDNodeType* mutable_node();
  ::TrezorProtobuf::HDNodeType* release_node();
  void set_allocated_node(::TrezorProtobuf::HDNodeType* node);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.HDNodePathType)
 private:
  void set_has_node();
  void clear_has_node();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::TrezorProtobuf::HDNodeType* node_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CoinType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.CoinType) */ {
 public:
  CoinType();
  virtual ~CoinType();

  CoinType(const CoinType& from);

  inline CoinType& operator=(const CoinType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinType& default_instance();

  static inline const CoinType* internal_default_instance() {
    return reinterpret_cast<const CoinType*>(
               &_CoinType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(CoinType* other);

  // implements Message ----------------------------------------------

  inline CoinType* New() const PROTOBUF_FINAL { return New(NULL); }

  CoinType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CoinType& from);
  void MergeFrom(const CoinType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CoinType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string coin_name = 1;
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 1;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional string coin_shortcut = 2;
  bool has_coin_shortcut() const;
  void clear_coin_shortcut();
  static const int kCoinShortcutFieldNumber = 2;
  const ::std::string& coin_shortcut() const;
  void set_coin_shortcut(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_shortcut(::std::string&& value);
  #endif
  void set_coin_shortcut(const char* value);
  void set_coin_shortcut(const char* value, size_t size);
  ::std::string* mutable_coin_shortcut();
  ::std::string* release_coin_shortcut();
  void set_allocated_coin_shortcut(::std::string* coin_shortcut);

  // optional string signed_message_header = 8;
  bool has_signed_message_header() const;
  void clear_signed_message_header();
  static const int kSignedMessageHeaderFieldNumber = 8;
  const ::std::string& signed_message_header() const;
  void set_signed_message_header(const ::std::string& value);
  #if LANG_CXX11
  void set_signed_message_header(::std::string&& value);
  #endif
  void set_signed_message_header(const char* value);
  void set_signed_message_header(const char* value, size_t size);
  ::std::string* mutable_signed_message_header();
  ::std::string* release_signed_message_header();
  void set_allocated_signed_message_header(::std::string* signed_message_header);

  // optional uint64 maxfee_kb = 4;
  bool has_maxfee_kb() const;
  void clear_maxfee_kb();
  static const int kMaxfeeKbFieldNumber = 4;
  ::google::protobuf::uint64 maxfee_kb() const;
  void set_maxfee_kb(::google::protobuf::uint64 value);

  // optional uint32 address_type = 3 [default = 0];
  bool has_address_type() const;
  void clear_address_type();
  static const int kAddressTypeFieldNumber = 3;
  ::google::protobuf::uint32 address_type() const;
  void set_address_type(::google::protobuf::uint32 value);

  // optional bool segwit = 11;
  bool has_segwit() const;
  void clear_segwit();
  static const int kSegwitFieldNumber = 11;
  bool segwit() const;
  void set_segwit(bool value);

  // optional uint32 xprv_magic = 10 [default = 76066276];
  bool has_xprv_magic() const;
  void clear_xprv_magic();
  static const int kXprvMagicFieldNumber = 10;
  ::google::protobuf::uint32 xprv_magic() const;
  void set_xprv_magic(::google::protobuf::uint32 value);

  // optional uint32 address_type_p2sh = 5 [default = 5];
  bool has_address_type_p2sh() const;
  void clear_address_type_p2sh();
  static const int kAddressTypeP2ShFieldNumber = 5;
  ::google::protobuf::uint32 address_type_p2sh() const;
  void set_address_type_p2sh(::google::protobuf::uint32 value);

  // optional uint32 xpub_magic = 9 [default = 76067358];
  bool has_xpub_magic() const;
  void clear_xpub_magic();
  static const int kXpubMagicFieldNumber = 9;
  ::google::protobuf::uint32 xpub_magic() const;
  void set_xpub_magic(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.CoinType)
 private:
  void set_has_coin_name();
  void clear_has_coin_name();
  void set_has_coin_shortcut();
  void clear_has_coin_shortcut();
  void set_has_address_type();
  void clear_has_address_type();
  void set_has_maxfee_kb();
  void clear_has_maxfee_kb();
  void set_has_address_type_p2sh();
  void clear_has_address_type_p2sh();
  void set_has_signed_message_header();
  void clear_has_signed_message_header();
  void set_has_xpub_magic();
  void clear_has_xpub_magic();
  void set_has_xprv_magic();
  void clear_has_xprv_magic();
  void set_has_segwit();
  void clear_has_segwit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_shortcut_;
  ::google::protobuf::internal::ArenaStringPtr signed_message_header_;
  ::google::protobuf::uint64 maxfee_kb_;
  ::google::protobuf::uint32 address_type_;
  bool segwit_;
  ::google::protobuf::uint32 xprv_magic_;
  ::google::protobuf::uint32 address_type_p2sh_;
  ::google::protobuf::uint32 xpub_magic_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultisigRedeemScriptType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.MultisigRedeemScriptType) */ {
 public:
  MultisigRedeemScriptType();
  virtual ~MultisigRedeemScriptType();

  MultisigRedeemScriptType(const MultisigRedeemScriptType& from);

  inline MultisigRedeemScriptType& operator=(const MultisigRedeemScriptType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultisigRedeemScriptType& default_instance();

  static inline const MultisigRedeemScriptType* internal_default_instance() {
    return reinterpret_cast<const MultisigRedeemScriptType*>(
               &_MultisigRedeemScriptType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MultisigRedeemScriptType* other);

  // implements Message ----------------------------------------------

  inline MultisigRedeemScriptType* New() const PROTOBUF_FINAL { return New(NULL); }

  MultisigRedeemScriptType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MultisigRedeemScriptType& from);
  void MergeFrom(const MultisigRedeemScriptType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MultisigRedeemScriptType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TrezorProtobuf.HDNodePathType pubkeys = 1;
  int pubkeys_size() const;
  void clear_pubkeys();
  static const int kPubkeysFieldNumber = 1;
  const ::TrezorProtobuf::HDNodePathType& pubkeys(int index) const;
  ::TrezorProtobuf::HDNodePathType* mutable_pubkeys(int index);
  ::TrezorProtobuf::HDNodePathType* add_pubkeys();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::HDNodePathType >*
      mutable_pubkeys();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::HDNodePathType >&
      pubkeys() const;

  // repeated bytes signatures = 2;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  const ::std::string& signatures(int index) const;
  ::std::string* mutable_signatures(int index);
  void set_signatures(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signatures(int index, ::std::string&& value);
  #endif
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const void* value, size_t size);
  ::std::string* add_signatures();
  void add_signatures(const ::std::string& value);
  #if LANG_CXX11
  void add_signatures(::std::string&& value);
  #endif
  void add_signatures(const char* value);
  void add_signatures(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signatures() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signatures();

  // optional uint32 m = 3;
  bool has_m() const;
  void clear_m();
  static const int kMFieldNumber = 3;
  ::google::protobuf::uint32 m() const;
  void set_m(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.MultisigRedeemScriptType)
 private:
  void set_has_m();
  void clear_has_m();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::HDNodePathType > pubkeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signatures_;
  ::google::protobuf::uint32 m_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxInputType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxInputType) */ {
 public:
  TxInputType();
  virtual ~TxInputType();

  TxInputType(const TxInputType& from);

  inline TxInputType& operator=(const TxInputType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxInputType& default_instance();

  static inline const TxInputType* internal_default_instance() {
    return reinterpret_cast<const TxInputType*>(
               &_TxInputType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TxInputType* other);

  // implements Message ----------------------------------------------

  inline TxInputType* New() const PROTOBUF_FINAL { return New(NULL); }

  TxInputType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxInputType& from);
  void MergeFrom(const TxInputType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxInputType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes prev_hash = 2;
  bool has_prev_hash() const;
  void clear_prev_hash();
  static const int kPrevHashFieldNumber = 2;
  const ::std::string& prev_hash() const;
  void set_prev_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_hash(::std::string&& value);
  #endif
  void set_prev_hash(const char* value);
  void set_prev_hash(const void* value, size_t size);
  ::std::string* mutable_prev_hash();
  ::std::string* release_prev_hash();
  void set_allocated_prev_hash(::std::string* prev_hash);

  // optional bytes script_sig = 4;
  bool has_script_sig() const;
  void clear_script_sig();
  static const int kScriptSigFieldNumber = 4;
  const ::std::string& script_sig() const;
  void set_script_sig(const ::std::string& value);
  #if LANG_CXX11
  void set_script_sig(::std::string&& value);
  #endif
  void set_script_sig(const char* value);
  void set_script_sig(const void* value, size_t size);
  ::std::string* mutable_script_sig();
  ::std::string* release_script_sig();
  void set_allocated_script_sig(::std::string* script_sig);

  // optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 7;
  bool has_multisig() const;
  void clear_multisig();
  static const int kMultisigFieldNumber = 7;
  const ::TrezorProtobuf::MultisigRedeemScriptType& multisig() const;
  ::TrezorProtobuf::MultisigRedeemScriptType* mutable_multisig();
  ::TrezorProtobuf::MultisigRedeemScriptType* release_multisig();
  void set_allocated_multisig(::TrezorProtobuf::MultisigRedeemScriptType* multisig);

  // required uint32 prev_index = 3;
  bool has_prev_index() const;
  void clear_prev_index();
  static const int kPrevIndexFieldNumber = 3;
  ::google::protobuf::uint32 prev_index() const;
  void set_prev_index(::google::protobuf::uint32 value);

  // optional .TrezorProtobuf.InputScriptType script_type = 6 [default = SPENDADDRESS];
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 6;
  ::TrezorProtobuf::InputScriptType script_type() const;
  void set_script_type(::TrezorProtobuf::InputScriptType value);

  // optional uint64 amount = 8;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 8;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // optional uint32 sequence = 5 [default = 4294967295];
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 5;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxInputType)
 private:
  void set_has_prev_hash();
  void clear_has_prev_hash();
  void set_has_prev_index();
  void clear_has_prev_index();
  void set_has_script_sig();
  void clear_has_script_sig();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_script_type();
  void clear_has_script_type();
  void set_has_multisig();
  void clear_has_multisig();
  void set_has_amount();
  void clear_has_amount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr prev_hash_;
  ::google::protobuf::internal::ArenaStringPtr script_sig_;
  ::TrezorProtobuf::MultisigRedeemScriptType* multisig_;
  ::google::protobuf::uint32 prev_index_;
  int script_type_;
  ::google::protobuf::uint64 amount_;
  ::google::protobuf::uint32 sequence_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxOutputType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxOutputType) */ {
 public:
  TxOutputType();
  virtual ~TxOutputType();

  TxOutputType(const TxOutputType& from);

  inline TxOutputType& operator=(const TxOutputType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxOutputType& default_instance();

  static inline const TxOutputType* internal_default_instance() {
    return reinterpret_cast<const TxOutputType*>(
               &_TxOutputType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TxOutputType* other);

  // implements Message ----------------------------------------------

  inline TxOutputType* New() const PROTOBUF_FINAL { return New(NULL); }

  TxOutputType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxOutputType& from);
  void MergeFrom(const TxOutputType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxOutputType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 2;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes op_return_data = 6;
  bool has_op_return_data() const;
  void clear_op_return_data();
  static const int kOpReturnDataFieldNumber = 6;
  const ::std::string& op_return_data() const;
  void set_op_return_data(const ::std::string& value);
  #if LANG_CXX11
  void set_op_return_data(::std::string&& value);
  #endif
  void set_op_return_data(const char* value);
  void set_op_return_data(const void* value, size_t size);
  ::std::string* mutable_op_return_data();
  ::std::string* release_op_return_data();
  void set_allocated_op_return_data(::std::string* op_return_data);

  // optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 5;
  bool has_multisig() const;
  void clear_multisig();
  static const int kMultisigFieldNumber = 5;
  const ::TrezorProtobuf::MultisigRedeemScriptType& multisig() const;
  ::TrezorProtobuf::MultisigRedeemScriptType* mutable_multisig();
  ::TrezorProtobuf::MultisigRedeemScriptType* release_multisig();
  void set_allocated_multisig(::TrezorProtobuf::MultisigRedeemScriptType* multisig);

  // required uint64 amount = 3;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // required .TrezorProtobuf.OutputScriptType script_type = 4;
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 4;
  ::TrezorProtobuf::OutputScriptType script_type() const;
  void set_script_type(::TrezorProtobuf::OutputScriptType value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxOutputType)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_amount();
  void clear_has_amount();
  void set_has_script_type();
  void clear_has_script_type();
  void set_has_multisig();
  void clear_has_multisig();
  void set_has_op_return_data();
  void clear_has_op_return_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr op_return_data_;
  ::TrezorProtobuf::MultisigRedeemScriptType* multisig_;
  ::google::protobuf::uint64 amount_;
  int script_type_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxOutputBinType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxOutputBinType) */ {
 public:
  TxOutputBinType();
  virtual ~TxOutputBinType();

  TxOutputBinType(const TxOutputBinType& from);

  inline TxOutputBinType& operator=(const TxOutputBinType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxOutputBinType& default_instance();

  static inline const TxOutputBinType* internal_default_instance() {
    return reinterpret_cast<const TxOutputBinType*>(
               &_TxOutputBinType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TxOutputBinType* other);

  // implements Message ----------------------------------------------

  inline TxOutputBinType* New() const PROTOBUF_FINAL { return New(NULL); }

  TxOutputBinType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxOutputBinType& from);
  void MergeFrom(const TxOutputBinType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxOutputBinType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes script_pubkey = 2;
  bool has_script_pubkey() const;
  void clear_script_pubkey();
  static const int kScriptPubkeyFieldNumber = 2;
  const ::std::string& script_pubkey() const;
  void set_script_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_script_pubkey(::std::string&& value);
  #endif
  void set_script_pubkey(const char* value);
  void set_script_pubkey(const void* value, size_t size);
  ::std::string* mutable_script_pubkey();
  ::std::string* release_script_pubkey();
  void set_allocated_script_pubkey(::std::string* script_pubkey);

  // required uint64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxOutputBinType)
 private:
  void set_has_amount();
  void clear_has_amount();
  void set_has_script_pubkey();
  void clear_has_script_pubkey();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr script_pubkey_;
  ::google::protobuf::uint64 amount_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TransactionType) */ {
 public:
  TransactionType();
  virtual ~TransactionType();

  TransactionType(const TransactionType& from);

  inline TransactionType& operator=(const TransactionType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionType& default_instance();

  static inline const TransactionType* internal_default_instance() {
    return reinterpret_cast<const TransactionType*>(
               &_TransactionType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TransactionType* other);

  // implements Message ----------------------------------------------

  inline TransactionType* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionType& from);
  void MergeFrom(const TransactionType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TrezorProtobuf.TxInputType inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::TrezorProtobuf::TxInputType& inputs(int index) const;
  ::TrezorProtobuf::TxInputType* mutable_inputs(int index);
  ::TrezorProtobuf::TxInputType* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >&
      inputs() const;

  // repeated .TrezorProtobuf.TxOutputBinType bin_outputs = 3;
  int bin_outputs_size() const;
  void clear_bin_outputs();
  static const int kBinOutputsFieldNumber = 3;
  const ::TrezorProtobuf::TxOutputBinType& bin_outputs(int index) const;
  ::TrezorProtobuf::TxOutputBinType* mutable_bin_outputs(int index);
  ::TrezorProtobuf::TxOutputBinType* add_bin_outputs();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputBinType >*
      mutable_bin_outputs();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputBinType >&
      bin_outputs() const;

  // repeated .TrezorProtobuf.TxOutputType outputs = 5;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 5;
  const ::TrezorProtobuf::TxOutputType& outputs(int index) const;
  ::TrezorProtobuf::TxOutputType* mutable_outputs(int index);
  ::TrezorProtobuf::TxOutputType* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >&
      outputs() const;

  // optional bytes extra_data = 8;
  bool has_extra_data() const;
  void clear_extra_data();
  static const int kExtraDataFieldNumber = 8;
  const ::std::string& extra_data() const;
  void set_extra_data(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_data(::std::string&& value);
  #endif
  void set_extra_data(const char* value);
  void set_extra_data(const void* value, size_t size);
  ::std::string* mutable_extra_data();
  ::std::string* release_extra_data();
  void set_allocated_extra_data(::std::string* extra_data);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 lock_time = 4;
  bool has_lock_time() const;
  void clear_lock_time();
  static const int kLockTimeFieldNumber = 4;
  ::google::protobuf::uint32 lock_time() const;
  void set_lock_time(::google::protobuf::uint32 value);

  // optional uint32 inputs_cnt = 6;
  bool has_inputs_cnt() const;
  void clear_inputs_cnt();
  static const int kInputsCntFieldNumber = 6;
  ::google::protobuf::uint32 inputs_cnt() const;
  void set_inputs_cnt(::google::protobuf::uint32 value);

  // optional uint32 outputs_cnt = 7;
  bool has_outputs_cnt() const;
  void clear_outputs_cnt();
  static const int kOutputsCntFieldNumber = 7;
  ::google::protobuf::uint32 outputs_cnt() const;
  void set_outputs_cnt(::google::protobuf::uint32 value);

  // optional uint32 extra_data_len = 9;
  bool has_extra_data_len() const;
  void clear_extra_data_len();
  static const int kExtraDataLenFieldNumber = 9;
  ::google::protobuf::uint32 extra_data_len() const;
  void set_extra_data_len(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TransactionType)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_lock_time();
  void clear_has_lock_time();
  void set_has_inputs_cnt();
  void clear_has_inputs_cnt();
  void set_has_outputs_cnt();
  void clear_has_outputs_cnt();
  void set_has_extra_data();
  void clear_has_extra_data();
  void set_has_extra_data_len();
  void clear_has_extra_data_len();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType > inputs_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputBinType > bin_outputs_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType > outputs_;
  ::google::protobuf::internal::ArenaStringPtr extra_data_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::uint32 inputs_cnt_;
  ::google::protobuf::uint32 outputs_cnt_;
  ::google::protobuf::uint32 extra_data_len_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxRequestDetailsType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxRequestDetailsType) */ {
 public:
  TxRequestDetailsType();
  virtual ~TxRequestDetailsType();

  TxRequestDetailsType(const TxRequestDetailsType& from);

  inline TxRequestDetailsType& operator=(const TxRequestDetailsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequestDetailsType& default_instance();

  static inline const TxRequestDetailsType* internal_default_instance() {
    return reinterpret_cast<const TxRequestDetailsType*>(
               &_TxRequestDetailsType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(TxRequestDetailsType* other);

  // implements Message ----------------------------------------------

  inline TxRequestDetailsType* New() const PROTOBUF_FINAL { return New(NULL); }

  TxRequestDetailsType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxRequestDetailsType& from);
  void MergeFrom(const TxRequestDetailsType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxRequestDetailsType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes tx_hash = 2;
  bool has_tx_hash() const;
  void clear_tx_hash();
  static const int kTxHashFieldNumber = 2;
  const ::std::string& tx_hash() const;
  void set_tx_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_hash(::std::string&& value);
  #endif
  void set_tx_hash(const char* value);
  void set_tx_hash(const void* value, size_t size);
  ::std::string* mutable_tx_hash();
  ::std::string* release_tx_hash();
  void set_allocated_tx_hash(::std::string* tx_hash);

  // optional uint32 request_index = 1;
  bool has_request_index() const;
  void clear_request_index();
  static const int kRequestIndexFieldNumber = 1;
  ::google::protobuf::uint32 request_index() const;
  void set_request_index(::google::protobuf::uint32 value);

  // optional uint32 extra_data_len = 3;
  bool has_extra_data_len() const;
  void clear_extra_data_len();
  static const int kExtraDataLenFieldNumber = 3;
  ::google::protobuf::uint32 extra_data_len() const;
  void set_extra_data_len(::google::protobuf::uint32 value);

  // optional uint32 extra_data_offset = 4;
  bool has_extra_data_offset() const;
  void clear_extra_data_offset();
  static const int kExtraDataOffsetFieldNumber = 4;
  ::google::protobuf::uint32 extra_data_offset() const;
  void set_extra_data_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxRequestDetailsType)
 private:
  void set_has_request_index();
  void clear_has_request_index();
  void set_has_tx_hash();
  void clear_has_tx_hash();
  void set_has_extra_data_len();
  void clear_has_extra_data_len();
  void set_has_extra_data_offset();
  void clear_has_extra_data_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_hash_;
  ::google::protobuf::uint32 request_index_;
  ::google::protobuf::uint32 extra_data_len_;
  ::google::protobuf::uint32 extra_data_offset_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxRequestSerializedType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxRequestSerializedType) */ {
 public:
  TxRequestSerializedType();
  virtual ~TxRequestSerializedType();

  TxRequestSerializedType(const TxRequestSerializedType& from);

  inline TxRequestSerializedType& operator=(const TxRequestSerializedType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequestSerializedType& default_instance();

  static inline const TxRequestSerializedType* internal_default_instance() {
    return reinterpret_cast<const TxRequestSerializedType*>(
               &_TxRequestSerializedType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(TxRequestSerializedType* other);

  // implements Message ----------------------------------------------

  inline TxRequestSerializedType* New() const PROTOBUF_FINAL { return New(NULL); }

  TxRequestSerializedType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxRequestSerializedType& from);
  void MergeFrom(const TxRequestSerializedType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxRequestSerializedType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes serialized_tx = 3;
  bool has_serialized_tx() const;
  void clear_serialized_tx();
  static const int kSerializedTxFieldNumber = 3;
  const ::std::string& serialized_tx() const;
  void set_serialized_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_serialized_tx(::std::string&& value);
  #endif
  void set_serialized_tx(const char* value);
  void set_serialized_tx(const void* value, size_t size);
  ::std::string* mutable_serialized_tx();
  ::std::string* release_serialized_tx();
  void set_allocated_serialized_tx(::std::string* serialized_tx);

  // optional uint32 signature_index = 1;
  bool has_signature_index() const;
  void clear_signature_index();
  static const int kSignatureIndexFieldNumber = 1;
  ::google::protobuf::uint32 signature_index() const;
  void set_signature_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxRequestSerializedType)
 private:
  void set_has_signature_index();
  void clear_has_signature_index();
  void set_has_signature();
  void clear_has_signature();
  void set_has_serialized_tx();
  void clear_has_serialized_tx();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr serialized_tx_;
  ::google::protobuf::uint32 signature_index_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IdentityType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.IdentityType) */ {
 public:
  IdentityType();
  virtual ~IdentityType();

  IdentityType(const IdentityType& from);

  inline IdentityType& operator=(const IdentityType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IdentityType& default_instance();

  static inline const IdentityType* internal_default_instance() {
    return reinterpret_cast<const IdentityType*>(
               &_IdentityType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(IdentityType* other);

  // implements Message ----------------------------------------------

  inline IdentityType* New() const PROTOBUF_FINAL { return New(NULL); }

  IdentityType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IdentityType& from);
  void MergeFrom(const IdentityType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IdentityType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string proto = 1;
  bool has_proto() const;
  void clear_proto();
  static const int kProtoFieldNumber = 1;
  const ::std::string& proto() const;
  void set_proto(const ::std::string& value);
  #if LANG_CXX11
  void set_proto(::std::string&& value);
  #endif
  void set_proto(const char* value);
  void set_proto(const char* value, size_t size);
  ::std::string* mutable_proto();
  ::std::string* release_proto();
  void set_allocated_proto(::std::string* proto);

  // optional string user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string host = 3;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 3;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // optional string port = 4;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 4;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // optional string path = 5;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional uint32 index = 6 [default = 0];
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 6;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.IdentityType)
 private:
  void set_has_proto();
  void clear_has_proto();
  void set_has_user();
  void clear_has_user();
  void set_has_host();
  void clear_has_host();
  void set_has_port();
  void clear_has_port();
  void set_has_path();
  void clear_has_path();
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr proto_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::uint32 index_;
  friend struct protobuf_types_2eproto::TableStruct;
};
// ===================================================================

static const int kWireInFieldNumber = 50002;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_in;
static const int kWireOutFieldNumber = 50003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_out;
static const int kWireDebugInFieldNumber = 50004;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_debug_in;
static const int kWireDebugOutFieldNumber = 50005;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_debug_out;
static const int kWireTinyFieldNumber = 50006;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_tiny;
static const int kWireBootloaderFieldNumber = 50007;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_bootloader;

// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// HDNodeType

// required uint32 depth = 1;
inline bool HDNodeType::has_depth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HDNodeType::set_has_depth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HDNodeType::clear_has_depth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HDNodeType::clear_depth() {
  depth_ = 0u;
  clear_has_depth();
}
inline ::google::protobuf::uint32 HDNodeType::depth() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodeType.depth)
  return depth_;
}
inline void HDNodeType::set_depth(::google::protobuf::uint32 value) {
  set_has_depth();
  depth_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.HDNodeType.depth)
}

// required uint32 fingerprint = 2;
inline bool HDNodeType::has_fingerprint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HDNodeType::set_has_fingerprint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HDNodeType::clear_has_fingerprint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HDNodeType::clear_fingerprint() {
  fingerprint_ = 0u;
  clear_has_fingerprint();
}
inline ::google::protobuf::uint32 HDNodeType::fingerprint() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodeType.fingerprint)
  return fingerprint_;
}
inline void HDNodeType::set_fingerprint(::google::protobuf::uint32 value) {
  set_has_fingerprint();
  fingerprint_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.HDNodeType.fingerprint)
}

// required uint32 child_num = 3;
inline bool HDNodeType::has_child_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HDNodeType::set_has_child_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HDNodeType::clear_has_child_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HDNodeType::clear_child_num() {
  child_num_ = 0u;
  clear_has_child_num();
}
inline ::google::protobuf::uint32 HDNodeType::child_num() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodeType.child_num)
  return child_num_;
}
inline void HDNodeType::set_child_num(::google::protobuf::uint32 value) {
  set_has_child_num();
  child_num_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.HDNodeType.child_num)
}

// required bytes chain_code = 4;
inline bool HDNodeType::has_chain_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HDNodeType::set_has_chain_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HDNodeType::clear_has_chain_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HDNodeType::clear_chain_code() {
  chain_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_chain_code();
}
inline const ::std::string& HDNodeType::chain_code() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodeType.chain_code)
  return chain_code_.GetNoArena();
}
inline void HDNodeType::set_chain_code(const ::std::string& value) {
  set_has_chain_code();
  chain_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.HDNodeType.chain_code)
}
#if LANG_CXX11
inline void HDNodeType::set_chain_code(::std::string&& value) {
  set_has_chain_code();
  chain_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.HDNodeType.chain_code)
}
#endif
inline void HDNodeType::set_chain_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_chain_code();
  chain_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.HDNodeType.chain_code)
}
inline void HDNodeType::set_chain_code(const void* value, size_t size) {
  set_has_chain_code();
  chain_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.HDNodeType.chain_code)
}
inline ::std::string* HDNodeType::mutable_chain_code() {
  set_has_chain_code();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.HDNodeType.chain_code)
  return chain_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HDNodeType::release_chain_code() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.HDNodeType.chain_code)
  clear_has_chain_code();
  return chain_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HDNodeType::set_allocated_chain_code(::std::string* chain_code) {
  if (chain_code != NULL) {
    set_has_chain_code();
  } else {
    clear_has_chain_code();
  }
  chain_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_code);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.HDNodeType.chain_code)
}

// optional bytes private_key = 5;
inline bool HDNodeType::has_private_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HDNodeType::set_has_private_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HDNodeType::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HDNodeType::clear_private_key() {
  private_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_private_key();
}
inline const ::std::string& HDNodeType::private_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodeType.private_key)
  return private_key_.GetNoArena();
}
inline void HDNodeType::set_private_key(const ::std::string& value) {
  set_has_private_key();
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.HDNodeType.private_key)
}
#if LANG_CXX11
inline void HDNodeType::set_private_key(::std::string&& value) {
  set_has_private_key();
  private_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.HDNodeType.private_key)
}
#endif
inline void HDNodeType::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_private_key();
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.HDNodeType.private_key)
}
inline void HDNodeType::set_private_key(const void* value, size_t size) {
  set_has_private_key();
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.HDNodeType.private_key)
}
inline ::std::string* HDNodeType::mutable_private_key() {
  set_has_private_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.HDNodeType.private_key)
  return private_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HDNodeType::release_private_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.HDNodeType.private_key)
  clear_has_private_key();
  return private_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HDNodeType::set_allocated_private_key(::std::string* private_key) {
  if (private_key != NULL) {
    set_has_private_key();
  } else {
    clear_has_private_key();
  }
  private_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), private_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.HDNodeType.private_key)
}

// optional bytes public_key = 6;
inline bool HDNodeType::has_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HDNodeType::set_has_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HDNodeType::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HDNodeType::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& HDNodeType::public_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodeType.public_key)
  return public_key_.GetNoArena();
}
inline void HDNodeType::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.HDNodeType.public_key)
}
#if LANG_CXX11
inline void HDNodeType::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.HDNodeType.public_key)
}
#endif
inline void HDNodeType::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.HDNodeType.public_key)
}
inline void HDNodeType::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.HDNodeType.public_key)
}
inline ::std::string* HDNodeType::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.HDNodeType.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HDNodeType::release_public_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.HDNodeType.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HDNodeType::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.HDNodeType.public_key)
}

// -------------------------------------------------------------------

// HDNodePathType

// required .TrezorProtobuf.HDNodeType node = 1;
inline bool HDNodePathType::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HDNodePathType::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HDNodePathType::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HDNodePathType::clear_node() {
  if (node_ != NULL) node_->::TrezorProtobuf::HDNodeType::Clear();
  clear_has_node();
}
inline const ::TrezorProtobuf::HDNodeType& HDNodePathType::node() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodePathType.node)
  return node_ != NULL ? *node_
                         : *::TrezorProtobuf::HDNodeType::internal_default_instance();
}
inline ::TrezorProtobuf::HDNodeType* HDNodePathType::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    node_ = new ::TrezorProtobuf::HDNodeType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.HDNodePathType.node)
  return node_;
}
inline ::TrezorProtobuf::HDNodeType* HDNodePathType::release_node() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.HDNodePathType.node)
  clear_has_node();
  ::TrezorProtobuf::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void HDNodePathType::set_allocated_node(::TrezorProtobuf::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.HDNodePathType.node)
}

// repeated uint32 address_n = 2;
inline int HDNodePathType::address_n_size() const {
  return address_n_.size();
}
inline void HDNodePathType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 HDNodePathType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.HDNodePathType.address_n)
  return address_n_.Get(index);
}
inline void HDNodePathType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.HDNodePathType.address_n)
}
inline void HDNodePathType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.HDNodePathType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HDNodePathType::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.HDNodePathType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HDNodePathType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.HDNodePathType.address_n)
  return &address_n_;
}

// -------------------------------------------------------------------

// CoinType

// optional string coin_name = 1;
inline bool CoinType::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoinType::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoinType::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoinType::clear_coin_name() {
  coin_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coin_name();
}
inline const ::std::string& CoinType::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.coin_name)
  return coin_name_.GetNoArena();
}
inline void CoinType::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.coin_name)
}
#if LANG_CXX11
inline void CoinType::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CoinType.coin_name)
}
#endif
inline void CoinType::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CoinType.coin_name)
}
inline void CoinType::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CoinType.coin_name)
}
inline ::std::string* CoinType::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CoinType.coin_name)
  return coin_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CoinType::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CoinType.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CoinType::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CoinType.coin_name)
}

// optional string coin_shortcut = 2;
inline bool CoinType::has_coin_shortcut() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoinType::set_has_coin_shortcut() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoinType::clear_has_coin_shortcut() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoinType::clear_coin_shortcut() {
  coin_shortcut_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coin_shortcut();
}
inline const ::std::string& CoinType::coin_shortcut() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.coin_shortcut)
  return coin_shortcut_.GetNoArena();
}
inline void CoinType::set_coin_shortcut(const ::std::string& value) {
  set_has_coin_shortcut();
  coin_shortcut_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.coin_shortcut)
}
#if LANG_CXX11
inline void CoinType::set_coin_shortcut(::std::string&& value) {
  set_has_coin_shortcut();
  coin_shortcut_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CoinType.coin_shortcut)
}
#endif
inline void CoinType::set_coin_shortcut(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_shortcut();
  coin_shortcut_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CoinType.coin_shortcut)
}
inline void CoinType::set_coin_shortcut(const char* value, size_t size) {
  set_has_coin_shortcut();
  coin_shortcut_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CoinType.coin_shortcut)
}
inline ::std::string* CoinType::mutable_coin_shortcut() {
  set_has_coin_shortcut();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CoinType.coin_shortcut)
  return coin_shortcut_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CoinType::release_coin_shortcut() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CoinType.coin_shortcut)
  clear_has_coin_shortcut();
  return coin_shortcut_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CoinType::set_allocated_coin_shortcut(::std::string* coin_shortcut) {
  if (coin_shortcut != NULL) {
    set_has_coin_shortcut();
  } else {
    clear_has_coin_shortcut();
  }
  coin_shortcut_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coin_shortcut);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CoinType.coin_shortcut)
}

// optional uint32 address_type = 3 [default = 0];
inline bool CoinType::has_address_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CoinType::set_has_address_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CoinType::clear_has_address_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CoinType::clear_address_type() {
  address_type_ = 0u;
  clear_has_address_type();
}
inline ::google::protobuf::uint32 CoinType::address_type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.address_type)
  return address_type_;
}
inline void CoinType::set_address_type(::google::protobuf::uint32 value) {
  set_has_address_type();
  address_type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.address_type)
}

// optional uint64 maxfee_kb = 4;
inline bool CoinType::has_maxfee_kb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoinType::set_has_maxfee_kb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoinType::clear_has_maxfee_kb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoinType::clear_maxfee_kb() {
  maxfee_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfee_kb();
}
inline ::google::protobuf::uint64 CoinType::maxfee_kb() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.maxfee_kb)
  return maxfee_kb_;
}
inline void CoinType::set_maxfee_kb(::google::protobuf::uint64 value) {
  set_has_maxfee_kb();
  maxfee_kb_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.maxfee_kb)
}

// optional uint32 address_type_p2sh = 5 [default = 5];
inline bool CoinType::has_address_type_p2sh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CoinType::set_has_address_type_p2sh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CoinType::clear_has_address_type_p2sh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CoinType::clear_address_type_p2sh() {
  address_type_p2sh_ = 5u;
  clear_has_address_type_p2sh();
}
inline ::google::protobuf::uint32 CoinType::address_type_p2sh() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.address_type_p2sh)
  return address_type_p2sh_;
}
inline void CoinType::set_address_type_p2sh(::google::protobuf::uint32 value) {
  set_has_address_type_p2sh();
  address_type_p2sh_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.address_type_p2sh)
}

// optional string signed_message_header = 8;
inline bool CoinType::has_signed_message_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoinType::set_has_signed_message_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoinType::clear_has_signed_message_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoinType::clear_signed_message_header() {
  signed_message_header_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signed_message_header();
}
inline const ::std::string& CoinType::signed_message_header() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.signed_message_header)
  return signed_message_header_.GetNoArena();
}
inline void CoinType::set_signed_message_header(const ::std::string& value) {
  set_has_signed_message_header();
  signed_message_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.signed_message_header)
}
#if LANG_CXX11
inline void CoinType::set_signed_message_header(::std::string&& value) {
  set_has_signed_message_header();
  signed_message_header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CoinType.signed_message_header)
}
#endif
inline void CoinType::set_signed_message_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signed_message_header();
  signed_message_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CoinType.signed_message_header)
}
inline void CoinType::set_signed_message_header(const char* value, size_t size) {
  set_has_signed_message_header();
  signed_message_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CoinType.signed_message_header)
}
inline ::std::string* CoinType::mutable_signed_message_header() {
  set_has_signed_message_header();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CoinType.signed_message_header)
  return signed_message_header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CoinType::release_signed_message_header() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CoinType.signed_message_header)
  clear_has_signed_message_header();
  return signed_message_header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CoinType::set_allocated_signed_message_header(::std::string* signed_message_header) {
  if (signed_message_header != NULL) {
    set_has_signed_message_header();
  } else {
    clear_has_signed_message_header();
  }
  signed_message_header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signed_message_header);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CoinType.signed_message_header)
}

// optional uint32 xpub_magic = 9 [default = 76067358];
inline bool CoinType::has_xpub_magic() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CoinType::set_has_xpub_magic() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CoinType::clear_has_xpub_magic() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CoinType::clear_xpub_magic() {
  xpub_magic_ = 76067358u;
  clear_has_xpub_magic();
}
inline ::google::protobuf::uint32 CoinType::xpub_magic() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.xpub_magic)
  return xpub_magic_;
}
inline void CoinType::set_xpub_magic(::google::protobuf::uint32 value) {
  set_has_xpub_magic();
  xpub_magic_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.xpub_magic)
}

// optional uint32 xprv_magic = 10 [default = 76066276];
inline bool CoinType::has_xprv_magic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CoinType::set_has_xprv_magic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CoinType::clear_has_xprv_magic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CoinType::clear_xprv_magic() {
  xprv_magic_ = 76066276u;
  clear_has_xprv_magic();
}
inline ::google::protobuf::uint32 CoinType::xprv_magic() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.xprv_magic)
  return xprv_magic_;
}
inline void CoinType::set_xprv_magic(::google::protobuf::uint32 value) {
  set_has_xprv_magic();
  xprv_magic_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.xprv_magic)
}

// optional bool segwit = 11;
inline bool CoinType::has_segwit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CoinType::set_has_segwit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CoinType::clear_has_segwit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CoinType::clear_segwit() {
  segwit_ = false;
  clear_has_segwit();
}
inline bool CoinType::segwit() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CoinType.segwit)
  return segwit_;
}
inline void CoinType::set_segwit(bool value) {
  set_has_segwit();
  segwit_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CoinType.segwit)
}

// -------------------------------------------------------------------

// MultisigRedeemScriptType

// repeated .TrezorProtobuf.HDNodePathType pubkeys = 1;
inline int MultisigRedeemScriptType::pubkeys_size() const {
  return pubkeys_.size();
}
inline void MultisigRedeemScriptType::clear_pubkeys() {
  pubkeys_.Clear();
}
inline const ::TrezorProtobuf::HDNodePathType& MultisigRedeemScriptType::pubkeys(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Get(index);
}
inline ::TrezorProtobuf::HDNodePathType* MultisigRedeemScriptType::mutable_pubkeys(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Mutable(index);
}
inline ::TrezorProtobuf::HDNodePathType* MultisigRedeemScriptType::add_pubkeys() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.MultisigRedeemScriptType.pubkeys)
  return pubkeys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::HDNodePathType >*
MultisigRedeemScriptType::mutable_pubkeys() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.MultisigRedeemScriptType.pubkeys)
  return &pubkeys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::HDNodePathType >&
MultisigRedeemScriptType::pubkeys() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.MultisigRedeemScriptType.pubkeys)
  return pubkeys_;
}

// repeated bytes signatures = 2;
inline int MultisigRedeemScriptType::signatures_size() const {
  return signatures_.size();
}
inline void MultisigRedeemScriptType::clear_signatures() {
  signatures_.Clear();
}
inline const ::std::string& MultisigRedeemScriptType::signatures(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.MultisigRedeemScriptType.signatures)
  return signatures_.Get(index);
}
inline ::std::string* MultisigRedeemScriptType::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.MultisigRedeemScriptType.signatures)
  return signatures_.Mutable(index);
}
inline void MultisigRedeemScriptType::set_signatures(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:TrezorProtobuf.MultisigRedeemScriptType.signatures)
  signatures_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MultisigRedeemScriptType::set_signatures(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:TrezorProtobuf.MultisigRedeemScriptType.signatures)
  signatures_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MultisigRedeemScriptType::set_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.MultisigRedeemScriptType.signatures)
}
inline void MultisigRedeemScriptType::set_signatures(int index, const void* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.MultisigRedeemScriptType.signatures)
}
inline ::std::string* MultisigRedeemScriptType::add_signatures() {
  // @@protoc_insertion_point(field_add_mutable:TrezorProtobuf.MultisigRedeemScriptType.signatures)
  return signatures_.Add();
}
inline void MultisigRedeemScriptType::add_signatures(const ::std::string& value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.MultisigRedeemScriptType.signatures)
}
#if LANG_CXX11
inline void MultisigRedeemScriptType::add_signatures(::std::string&& value) {
  signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TrezorProtobuf.MultisigRedeemScriptType.signatures)
}
#endif
inline void MultisigRedeemScriptType::add_signatures(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TrezorProtobuf.MultisigRedeemScriptType.signatures)
}
inline void MultisigRedeemScriptType::add_signatures(const void* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TrezorProtobuf.MultisigRedeemScriptType.signatures)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MultisigRedeemScriptType::signatures() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.MultisigRedeemScriptType.signatures)
  return signatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MultisigRedeemScriptType::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.MultisigRedeemScriptType.signatures)
  return &signatures_;
}

// optional uint32 m = 3;
inline bool MultisigRedeemScriptType::has_m() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultisigRedeemScriptType::set_has_m() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultisigRedeemScriptType::clear_has_m() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultisigRedeemScriptType::clear_m() {
  m_ = 0u;
  clear_has_m();
}
inline ::google::protobuf::uint32 MultisigRedeemScriptType::m() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.MultisigRedeemScriptType.m)
  return m_;
}
inline void MultisigRedeemScriptType::set_m(::google::protobuf::uint32 value) {
  set_has_m();
  m_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.MultisigRedeemScriptType.m)
}

// -------------------------------------------------------------------

// TxInputType

// repeated uint32 address_n = 1;
inline int TxInputType::address_n_size() const {
  return address_n_.size();
}
inline void TxInputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxInputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.address_n)
  return address_n_.Get(index);
}
inline void TxInputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxInputType.address_n)
}
inline void TxInputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.TxInputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxInputType::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.TxInputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxInputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.TxInputType.address_n)
  return &address_n_;
}

// required bytes prev_hash = 2;
inline bool TxInputType::has_prev_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxInputType::set_has_prev_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxInputType::clear_has_prev_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxInputType::clear_prev_hash() {
  prev_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_prev_hash();
}
inline const ::std::string& TxInputType::prev_hash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.prev_hash)
  return prev_hash_.GetNoArena();
}
inline void TxInputType::set_prev_hash(const ::std::string& value) {
  set_has_prev_hash();
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxInputType.prev_hash)
}
#if LANG_CXX11
inline void TxInputType::set_prev_hash(::std::string&& value) {
  set_has_prev_hash();
  prev_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxInputType.prev_hash)
}
#endif
inline void TxInputType::set_prev_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_prev_hash();
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxInputType.prev_hash)
}
inline void TxInputType::set_prev_hash(const void* value, size_t size) {
  set_has_prev_hash();
  prev_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxInputType.prev_hash)
}
inline ::std::string* TxInputType::mutable_prev_hash() {
  set_has_prev_hash();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxInputType.prev_hash)
  return prev_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInputType::release_prev_hash() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxInputType.prev_hash)
  clear_has_prev_hash();
  return prev_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInputType::set_allocated_prev_hash(::std::string* prev_hash) {
  if (prev_hash != NULL) {
    set_has_prev_hash();
  } else {
    clear_has_prev_hash();
  }
  prev_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_hash);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxInputType.prev_hash)
}

// required uint32 prev_index = 3;
inline bool TxInputType::has_prev_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxInputType::set_has_prev_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxInputType::clear_has_prev_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxInputType::clear_prev_index() {
  prev_index_ = 0u;
  clear_has_prev_index();
}
inline ::google::protobuf::uint32 TxInputType::prev_index() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.prev_index)
  return prev_index_;
}
inline void TxInputType::set_prev_index(::google::protobuf::uint32 value) {
  set_has_prev_index();
  prev_index_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxInputType.prev_index)
}

// optional bytes script_sig = 4;
inline bool TxInputType::has_script_sig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxInputType::set_has_script_sig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxInputType::clear_has_script_sig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxInputType::clear_script_sig() {
  script_sig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_script_sig();
}
inline const ::std::string& TxInputType::script_sig() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.script_sig)
  return script_sig_.GetNoArena();
}
inline void TxInputType::set_script_sig(const ::std::string& value) {
  set_has_script_sig();
  script_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxInputType.script_sig)
}
#if LANG_CXX11
inline void TxInputType::set_script_sig(::std::string&& value) {
  set_has_script_sig();
  script_sig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxInputType.script_sig)
}
#endif
inline void TxInputType::set_script_sig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_script_sig();
  script_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxInputType.script_sig)
}
inline void TxInputType::set_script_sig(const void* value, size_t size) {
  set_has_script_sig();
  script_sig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxInputType.script_sig)
}
inline ::std::string* TxInputType::mutable_script_sig() {
  set_has_script_sig();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxInputType.script_sig)
  return script_sig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxInputType::release_script_sig() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxInputType.script_sig)
  clear_has_script_sig();
  return script_sig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxInputType::set_allocated_script_sig(::std::string* script_sig) {
  if (script_sig != NULL) {
    set_has_script_sig();
  } else {
    clear_has_script_sig();
  }
  script_sig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script_sig);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxInputType.script_sig)
}

// optional uint32 sequence = 5 [default = 4294967295];
inline bool TxInputType::has_sequence() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxInputType::set_has_sequence() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxInputType::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxInputType::clear_sequence() {
  sequence_ = 4294967295u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 TxInputType::sequence() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.sequence)
  return sequence_;
}
inline void TxInputType::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxInputType.sequence)
}

// optional .TrezorProtobuf.InputScriptType script_type = 6 [default = SPENDADDRESS];
inline bool TxInputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxInputType::set_has_script_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxInputType::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxInputType::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::TrezorProtobuf::InputScriptType TxInputType::script_type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.script_type)
  return static_cast< ::TrezorProtobuf::InputScriptType >(script_type_);
}
inline void TxInputType::set_script_type(::TrezorProtobuf::InputScriptType value) {
  assert(::TrezorProtobuf::InputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxInputType.script_type)
}

// optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 7;
inline bool TxInputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxInputType::set_has_multisig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxInputType::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxInputType::clear_multisig() {
  if (multisig_ != NULL) multisig_->::TrezorProtobuf::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::TrezorProtobuf::MultisigRedeemScriptType& TxInputType::multisig() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.multisig)
  return multisig_ != NULL ? *multisig_
                         : *::TrezorProtobuf::MultisigRedeemScriptType::internal_default_instance();
}
inline ::TrezorProtobuf::MultisigRedeemScriptType* TxInputType::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) {
    multisig_ = new ::TrezorProtobuf::MultisigRedeemScriptType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxInputType.multisig)
  return multisig_;
}
inline ::TrezorProtobuf::MultisigRedeemScriptType* TxInputType::release_multisig() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxInputType.multisig)
  clear_has_multisig();
  ::TrezorProtobuf::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void TxInputType::set_allocated_multisig(::TrezorProtobuf::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxInputType.multisig)
}

// optional uint64 amount = 8;
inline bool TxInputType::has_amount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxInputType::set_has_amount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxInputType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxInputType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxInputType::amount() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxInputType.amount)
  return amount_;
}
inline void TxInputType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxInputType.amount)
}

// -------------------------------------------------------------------

// TxOutputType

// optional string address = 1;
inline bool TxOutputType::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxOutputType::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxOutputType::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxOutputType::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& TxOutputType::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputType.address)
  return address_.GetNoArena();
}
inline void TxOutputType::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxOutputType.address)
}
#if LANG_CXX11
inline void TxOutputType::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxOutputType.address)
}
#endif
inline void TxOutputType::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxOutputType.address)
}
inline void TxOutputType::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxOutputType.address)
}
inline ::std::string* TxOutputType::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxOutputType.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutputType::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxOutputType.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutputType::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxOutputType.address)
}

// repeated uint32 address_n = 2;
inline int TxOutputType::address_n_size() const {
  return address_n_.size();
}
inline void TxOutputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxOutputType::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputType.address_n)
  return address_n_.Get(index);
}
inline void TxOutputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxOutputType.address_n)
}
inline void TxOutputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.TxOutputType.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxOutputType::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.TxOutputType.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxOutputType::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.TxOutputType.address_n)
  return &address_n_;
}

// required uint64 amount = 3;
inline bool TxOutputType::has_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxOutputType::set_has_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxOutputType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxOutputType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxOutputType::amount() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputType.amount)
  return amount_;
}
inline void TxOutputType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxOutputType.amount)
}

// required .TrezorProtobuf.OutputScriptType script_type = 4;
inline bool TxOutputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxOutputType::set_has_script_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxOutputType::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxOutputType::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::TrezorProtobuf::OutputScriptType TxOutputType::script_type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputType.script_type)
  return static_cast< ::TrezorProtobuf::OutputScriptType >(script_type_);
}
inline void TxOutputType::set_script_type(::TrezorProtobuf::OutputScriptType value) {
  assert(::TrezorProtobuf::OutputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxOutputType.script_type)
}

// optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 5;
inline bool TxOutputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxOutputType::set_has_multisig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxOutputType::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxOutputType::clear_multisig() {
  if (multisig_ != NULL) multisig_->::TrezorProtobuf::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::TrezorProtobuf::MultisigRedeemScriptType& TxOutputType::multisig() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputType.multisig)
  return multisig_ != NULL ? *multisig_
                         : *::TrezorProtobuf::MultisigRedeemScriptType::internal_default_instance();
}
inline ::TrezorProtobuf::MultisigRedeemScriptType* TxOutputType::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) {
    multisig_ = new ::TrezorProtobuf::MultisigRedeemScriptType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxOutputType.multisig)
  return multisig_;
}
inline ::TrezorProtobuf::MultisigRedeemScriptType* TxOutputType::release_multisig() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxOutputType.multisig)
  clear_has_multisig();
  ::TrezorProtobuf::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void TxOutputType::set_allocated_multisig(::TrezorProtobuf::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxOutputType.multisig)
}

// optional bytes op_return_data = 6;
inline bool TxOutputType::has_op_return_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxOutputType::set_has_op_return_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxOutputType::clear_has_op_return_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxOutputType::clear_op_return_data() {
  op_return_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_op_return_data();
}
inline const ::std::string& TxOutputType::op_return_data() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputType.op_return_data)
  return op_return_data_.GetNoArena();
}
inline void TxOutputType::set_op_return_data(const ::std::string& value) {
  set_has_op_return_data();
  op_return_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxOutputType.op_return_data)
}
#if LANG_CXX11
inline void TxOutputType::set_op_return_data(::std::string&& value) {
  set_has_op_return_data();
  op_return_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxOutputType.op_return_data)
}
#endif
inline void TxOutputType::set_op_return_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_op_return_data();
  op_return_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxOutputType.op_return_data)
}
inline void TxOutputType::set_op_return_data(const void* value, size_t size) {
  set_has_op_return_data();
  op_return_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxOutputType.op_return_data)
}
inline ::std::string* TxOutputType::mutable_op_return_data() {
  set_has_op_return_data();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxOutputType.op_return_data)
  return op_return_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutputType::release_op_return_data() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxOutputType.op_return_data)
  clear_has_op_return_data();
  return op_return_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutputType::set_allocated_op_return_data(::std::string* op_return_data) {
  if (op_return_data != NULL) {
    set_has_op_return_data();
  } else {
    clear_has_op_return_data();
  }
  op_return_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), op_return_data);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxOutputType.op_return_data)
}

// -------------------------------------------------------------------

// TxOutputBinType

// required uint64 amount = 1;
inline bool TxOutputBinType::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxOutputBinType::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxOutputBinType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxOutputBinType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxOutputBinType::amount() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputBinType.amount)
  return amount_;
}
inline void TxOutputBinType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxOutputBinType.amount)
}

// required bytes script_pubkey = 2;
inline bool TxOutputBinType::has_script_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxOutputBinType::set_has_script_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxOutputBinType::clear_has_script_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxOutputBinType::clear_script_pubkey() {
  script_pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_script_pubkey();
}
inline const ::std::string& TxOutputBinType::script_pubkey() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxOutputBinType.script_pubkey)
  return script_pubkey_.GetNoArena();
}
inline void TxOutputBinType::set_script_pubkey(const ::std::string& value) {
  set_has_script_pubkey();
  script_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxOutputBinType.script_pubkey)
}
#if LANG_CXX11
inline void TxOutputBinType::set_script_pubkey(::std::string&& value) {
  set_has_script_pubkey();
  script_pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxOutputBinType.script_pubkey)
}
#endif
inline void TxOutputBinType::set_script_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_script_pubkey();
  script_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxOutputBinType.script_pubkey)
}
inline void TxOutputBinType::set_script_pubkey(const void* value, size_t size) {
  set_has_script_pubkey();
  script_pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxOutputBinType.script_pubkey)
}
inline ::std::string* TxOutputBinType::mutable_script_pubkey() {
  set_has_script_pubkey();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxOutputBinType.script_pubkey)
  return script_pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxOutputBinType::release_script_pubkey() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxOutputBinType.script_pubkey)
  clear_has_script_pubkey();
  return script_pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxOutputBinType::set_allocated_script_pubkey(::std::string* script_pubkey) {
  if (script_pubkey != NULL) {
    set_has_script_pubkey();
  } else {
    clear_has_script_pubkey();
  }
  script_pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script_pubkey);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxOutputBinType.script_pubkey)
}

// -------------------------------------------------------------------

// TransactionType

// optional uint32 version = 1;
inline bool TransactionType::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionType::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionType::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionType::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 TransactionType::version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.version)
  return version_;
}
inline void TransactionType::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TransactionType.version)
}

// repeated .TrezorProtobuf.TxInputType inputs = 2;
inline int TransactionType::inputs_size() const {
  return inputs_.size();
}
inline void TransactionType::clear_inputs() {
  inputs_.Clear();
}
inline const ::TrezorProtobuf::TxInputType& TransactionType::inputs(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.inputs)
  return inputs_.Get(index);
}
inline ::TrezorProtobuf::TxInputType* TransactionType::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TransactionType.inputs)
  return inputs_.Mutable(index);
}
inline ::TrezorProtobuf::TxInputType* TransactionType::add_inputs() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.TransactionType.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >*
TransactionType::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.TransactionType.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >&
TransactionType::inputs() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.TransactionType.inputs)
  return inputs_;
}

// repeated .TrezorProtobuf.TxOutputBinType bin_outputs = 3;
inline int TransactionType::bin_outputs_size() const {
  return bin_outputs_.size();
}
inline void TransactionType::clear_bin_outputs() {
  bin_outputs_.Clear();
}
inline const ::TrezorProtobuf::TxOutputBinType& TransactionType::bin_outputs(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.bin_outputs)
  return bin_outputs_.Get(index);
}
inline ::TrezorProtobuf::TxOutputBinType* TransactionType::mutable_bin_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TransactionType.bin_outputs)
  return bin_outputs_.Mutable(index);
}
inline ::TrezorProtobuf::TxOutputBinType* TransactionType::add_bin_outputs() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.TransactionType.bin_outputs)
  return bin_outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputBinType >*
TransactionType::mutable_bin_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.TransactionType.bin_outputs)
  return &bin_outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputBinType >&
TransactionType::bin_outputs() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.TransactionType.bin_outputs)
  return bin_outputs_;
}

// repeated .TrezorProtobuf.TxOutputType outputs = 5;
inline int TransactionType::outputs_size() const {
  return outputs_.size();
}
inline void TransactionType::clear_outputs() {
  outputs_.Clear();
}
inline const ::TrezorProtobuf::TxOutputType& TransactionType::outputs(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.outputs)
  return outputs_.Get(index);
}
inline ::TrezorProtobuf::TxOutputType* TransactionType::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TransactionType.outputs)
  return outputs_.Mutable(index);
}
inline ::TrezorProtobuf::TxOutputType* TransactionType::add_outputs() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.TransactionType.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >*
TransactionType::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.TransactionType.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >&
TransactionType::outputs() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.TransactionType.outputs)
  return outputs_;
}

// optional uint32 lock_time = 4;
inline bool TransactionType::has_lock_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionType::set_has_lock_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionType::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionType::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
inline ::google::protobuf::uint32 TransactionType::lock_time() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.lock_time)
  return lock_time_;
}
inline void TransactionType::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TransactionType.lock_time)
}

// optional uint32 inputs_cnt = 6;
inline bool TransactionType::has_inputs_cnt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionType::set_has_inputs_cnt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionType::clear_has_inputs_cnt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionType::clear_inputs_cnt() {
  inputs_cnt_ = 0u;
  clear_has_inputs_cnt();
}
inline ::google::protobuf::uint32 TransactionType::inputs_cnt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.inputs_cnt)
  return inputs_cnt_;
}
inline void TransactionType::set_inputs_cnt(::google::protobuf::uint32 value) {
  set_has_inputs_cnt();
  inputs_cnt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TransactionType.inputs_cnt)
}

// optional uint32 outputs_cnt = 7;
inline bool TransactionType::has_outputs_cnt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransactionType::set_has_outputs_cnt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransactionType::clear_has_outputs_cnt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransactionType::clear_outputs_cnt() {
  outputs_cnt_ = 0u;
  clear_has_outputs_cnt();
}
inline ::google::protobuf::uint32 TransactionType::outputs_cnt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.outputs_cnt)
  return outputs_cnt_;
}
inline void TransactionType::set_outputs_cnt(::google::protobuf::uint32 value) {
  set_has_outputs_cnt();
  outputs_cnt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TransactionType.outputs_cnt)
}

// optional bytes extra_data = 8;
inline bool TransactionType::has_extra_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionType::set_has_extra_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionType::clear_has_extra_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionType::clear_extra_data() {
  extra_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extra_data();
}
inline const ::std::string& TransactionType::extra_data() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.extra_data)
  return extra_data_.GetNoArena();
}
inline void TransactionType::set_extra_data(const ::std::string& value) {
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TransactionType.extra_data)
}
#if LANG_CXX11
inline void TransactionType::set_extra_data(::std::string&& value) {
  set_has_extra_data();
  extra_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TransactionType.extra_data)
}
#endif
inline void TransactionType::set_extra_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TransactionType.extra_data)
}
inline void TransactionType::set_extra_data(const void* value, size_t size) {
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TransactionType.extra_data)
}
inline ::std::string* TransactionType::mutable_extra_data() {
  set_has_extra_data();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TransactionType.extra_data)
  return extra_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionType::release_extra_data() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TransactionType.extra_data)
  clear_has_extra_data();
  return extra_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionType::set_allocated_extra_data(::std::string* extra_data) {
  if (extra_data != NULL) {
    set_has_extra_data();
  } else {
    clear_has_extra_data();
  }
  extra_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_data);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TransactionType.extra_data)
}

// optional uint32 extra_data_len = 9;
inline bool TransactionType::has_extra_data_len() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransactionType::set_has_extra_data_len() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransactionType::clear_has_extra_data_len() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransactionType::clear_extra_data_len() {
  extra_data_len_ = 0u;
  clear_has_extra_data_len();
}
inline ::google::protobuf::uint32 TransactionType::extra_data_len() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TransactionType.extra_data_len)
  return extra_data_len_;
}
inline void TransactionType::set_extra_data_len(::google::protobuf::uint32 value) {
  set_has_extra_data_len();
  extra_data_len_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TransactionType.extra_data_len)
}

// -------------------------------------------------------------------

// TxRequestDetailsType

// optional uint32 request_index = 1;
inline bool TxRequestDetailsType::has_request_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequestDetailsType::set_has_request_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequestDetailsType::clear_has_request_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequestDetailsType::clear_request_index() {
  request_index_ = 0u;
  clear_has_request_index();
}
inline ::google::protobuf::uint32 TxRequestDetailsType::request_index() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequestDetailsType.request_index)
  return request_index_;
}
inline void TxRequestDetailsType::set_request_index(::google::protobuf::uint32 value) {
  set_has_request_index();
  request_index_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequestDetailsType.request_index)
}

// optional bytes tx_hash = 2;
inline bool TxRequestDetailsType::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequestDetailsType::set_has_tx_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequestDetailsType::clear_has_tx_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequestDetailsType::clear_tx_hash() {
  tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tx_hash();
}
inline const ::std::string& TxRequestDetailsType::tx_hash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequestDetailsType.tx_hash)
  return tx_hash_.GetNoArena();
}
inline void TxRequestDetailsType::set_tx_hash(const ::std::string& value) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequestDetailsType.tx_hash)
}
#if LANG_CXX11
inline void TxRequestDetailsType::set_tx_hash(::std::string&& value) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxRequestDetailsType.tx_hash)
}
#endif
inline void TxRequestDetailsType::set_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxRequestDetailsType.tx_hash)
}
inline void TxRequestDetailsType::set_tx_hash(const void* value, size_t size) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxRequestDetailsType.tx_hash)
}
inline ::std::string* TxRequestDetailsType::mutable_tx_hash() {
  set_has_tx_hash();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxRequestDetailsType.tx_hash)
  return tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxRequestDetailsType::release_tx_hash() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxRequestDetailsType.tx_hash)
  clear_has_tx_hash();
  return tx_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxRequestDetailsType::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash != NULL) {
    set_has_tx_hash();
  } else {
    clear_has_tx_hash();
  }
  tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_hash);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxRequestDetailsType.tx_hash)
}

// optional uint32 extra_data_len = 3;
inline bool TxRequestDetailsType::has_extra_data_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequestDetailsType::set_has_extra_data_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequestDetailsType::clear_has_extra_data_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequestDetailsType::clear_extra_data_len() {
  extra_data_len_ = 0u;
  clear_has_extra_data_len();
}
inline ::google::protobuf::uint32 TxRequestDetailsType::extra_data_len() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequestDetailsType.extra_data_len)
  return extra_data_len_;
}
inline void TxRequestDetailsType::set_extra_data_len(::google::protobuf::uint32 value) {
  set_has_extra_data_len();
  extra_data_len_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequestDetailsType.extra_data_len)
}

// optional uint32 extra_data_offset = 4;
inline bool TxRequestDetailsType::has_extra_data_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxRequestDetailsType::set_has_extra_data_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxRequestDetailsType::clear_has_extra_data_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxRequestDetailsType::clear_extra_data_offset() {
  extra_data_offset_ = 0u;
  clear_has_extra_data_offset();
}
inline ::google::protobuf::uint32 TxRequestDetailsType::extra_data_offset() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequestDetailsType.extra_data_offset)
  return extra_data_offset_;
}
inline void TxRequestDetailsType::set_extra_data_offset(::google::protobuf::uint32 value) {
  set_has_extra_data_offset();
  extra_data_offset_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequestDetailsType.extra_data_offset)
}

// -------------------------------------------------------------------

// TxRequestSerializedType

// optional uint32 signature_index = 1;
inline bool TxRequestSerializedType::has_signature_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequestSerializedType::set_has_signature_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequestSerializedType::clear_has_signature_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequestSerializedType::clear_signature_index() {
  signature_index_ = 0u;
  clear_has_signature_index();
}
inline ::google::protobuf::uint32 TxRequestSerializedType::signature_index() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequestSerializedType.signature_index)
  return signature_index_;
}
inline void TxRequestSerializedType::set_signature_index(::google::protobuf::uint32 value) {
  set_has_signature_index();
  signature_index_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequestSerializedType.signature_index)
}

// optional bytes signature = 2;
inline bool TxRequestSerializedType::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequestSerializedType::set_has_signature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequestSerializedType::clear_has_signature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequestSerializedType::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& TxRequestSerializedType::signature() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequestSerializedType.signature)
  return signature_.GetNoArena();
}
inline void TxRequestSerializedType::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequestSerializedType.signature)
}
#if LANG_CXX11
inline void TxRequestSerializedType::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxRequestSerializedType.signature)
}
#endif
inline void TxRequestSerializedType::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxRequestSerializedType.signature)
}
inline void TxRequestSerializedType::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxRequestSerializedType.signature)
}
inline ::std::string* TxRequestSerializedType::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxRequestSerializedType.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxRequestSerializedType::release_signature() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxRequestSerializedType.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxRequestSerializedType::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxRequestSerializedType.signature)
}

// optional bytes serialized_tx = 3;
inline bool TxRequestSerializedType::has_serialized_tx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequestSerializedType::set_has_serialized_tx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequestSerializedType::clear_has_serialized_tx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequestSerializedType::clear_serialized_tx() {
  serialized_tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serialized_tx();
}
inline const ::std::string& TxRequestSerializedType::serialized_tx() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
  return serialized_tx_.GetNoArena();
}
inline void TxRequestSerializedType::set_serialized_tx(const ::std::string& value) {
  set_has_serialized_tx();
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
}
#if LANG_CXX11
inline void TxRequestSerializedType::set_serialized_tx(::std::string&& value) {
  set_has_serialized_tx();
  serialized_tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
}
#endif
inline void TxRequestSerializedType::set_serialized_tx(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serialized_tx();
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
}
inline void TxRequestSerializedType::set_serialized_tx(const void* value, size_t size) {
  set_has_serialized_tx();
  serialized_tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
}
inline ::std::string* TxRequestSerializedType::mutable_serialized_tx() {
  set_has_serialized_tx();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
  return serialized_tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxRequestSerializedType::release_serialized_tx() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
  clear_has_serialized_tx();
  return serialized_tx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxRequestSerializedType::set_allocated_serialized_tx(::std::string* serialized_tx) {
  if (serialized_tx != NULL) {
    set_has_serialized_tx();
  } else {
    clear_has_serialized_tx();
  }
  serialized_tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialized_tx);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxRequestSerializedType.serialized_tx)
}

// -------------------------------------------------------------------

// IdentityType

// optional string proto = 1;
inline bool IdentityType::has_proto() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdentityType::set_has_proto() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdentityType::clear_has_proto() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdentityType::clear_proto() {
  proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_proto();
}
inline const ::std::string& IdentityType::proto() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.IdentityType.proto)
  return proto_.GetNoArena();
}
inline void IdentityType::set_proto(const ::std::string& value) {
  set_has_proto();
  proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.IdentityType.proto)
}
#if LANG_CXX11
inline void IdentityType::set_proto(::std::string&& value) {
  set_has_proto();
  proto_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.IdentityType.proto)
}
#endif
inline void IdentityType::set_proto(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_proto();
  proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.IdentityType.proto)
}
inline void IdentityType::set_proto(const char* value, size_t size) {
  set_has_proto();
  proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.IdentityType.proto)
}
inline ::std::string* IdentityType::mutable_proto() {
  set_has_proto();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.IdentityType.proto)
  return proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_proto() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.IdentityType.proto)
  clear_has_proto();
  return proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_proto(::std::string* proto) {
  if (proto != NULL) {
    set_has_proto();
  } else {
    clear_has_proto();
  }
  proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proto);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.IdentityType.proto)
}

// optional string user = 2;
inline bool IdentityType::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdentityType::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdentityType::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdentityType::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& IdentityType::user() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.IdentityType.user)
  return user_.GetNoArena();
}
inline void IdentityType::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.IdentityType.user)
}
#if LANG_CXX11
inline void IdentityType::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.IdentityType.user)
}
#endif
inline void IdentityType::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.IdentityType.user)
}
inline void IdentityType::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.IdentityType.user)
}
inline ::std::string* IdentityType::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.IdentityType.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_user() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.IdentityType.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.IdentityType.user)
}

// optional string host = 3;
inline bool IdentityType::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IdentityType::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IdentityType::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IdentityType::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& IdentityType::host() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.IdentityType.host)
  return host_.GetNoArena();
}
inline void IdentityType::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.IdentityType.host)
}
#if LANG_CXX11
inline void IdentityType::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.IdentityType.host)
}
#endif
inline void IdentityType::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.IdentityType.host)
}
inline void IdentityType::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.IdentityType.host)
}
inline ::std::string* IdentityType::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.IdentityType.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_host() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.IdentityType.host)
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.IdentityType.host)
}

// optional string port = 4;
inline bool IdentityType::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IdentityType::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IdentityType::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IdentityType::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_port();
}
inline const ::std::string& IdentityType::port() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.IdentityType.port)
  return port_.GetNoArena();
}
inline void IdentityType::set_port(const ::std::string& value) {
  set_has_port();
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.IdentityType.port)
}
#if LANG_CXX11
inline void IdentityType::set_port(::std::string&& value) {
  set_has_port();
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.IdentityType.port)
}
#endif
inline void IdentityType::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_port();
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.IdentityType.port)
}
inline void IdentityType::set_port(const char* value, size_t size) {
  set_has_port();
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.IdentityType.port)
}
inline ::std::string* IdentityType::mutable_port() {
  set_has_port();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.IdentityType.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_port() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.IdentityType.port)
  clear_has_port();
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    set_has_port();
  } else {
    clear_has_port();
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.IdentityType.port)
}

// optional string path = 5;
inline bool IdentityType::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IdentityType::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IdentityType::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IdentityType::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& IdentityType::path() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.IdentityType.path)
  return path_.GetNoArena();
}
inline void IdentityType::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.IdentityType.path)
}
#if LANG_CXX11
inline void IdentityType::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.IdentityType.path)
}
#endif
inline void IdentityType::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.IdentityType.path)
}
inline void IdentityType::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.IdentityType.path)
}
inline ::std::string* IdentityType::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.IdentityType.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IdentityType::release_path() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.IdentityType.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IdentityType::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.IdentityType.path)
}

// optional uint32 index = 6 [default = 0];
inline bool IdentityType::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IdentityType::set_has_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IdentityType::clear_has_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IdentityType::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 IdentityType::index() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.IdentityType.index)
  return index_;
}
inline void IdentityType::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.IdentityType.index)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace TrezorProtobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TrezorProtobuf::FailureType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::FailureType>() {
  return ::TrezorProtobuf::FailureType_descriptor();
}
template <> struct is_proto_enum< ::TrezorProtobuf::OutputScriptType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::OutputScriptType>() {
  return ::TrezorProtobuf::OutputScriptType_descriptor();
}
template <> struct is_proto_enum< ::TrezorProtobuf::InputScriptType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::InputScriptType>() {
  return ::TrezorProtobuf::InputScriptType_descriptor();
}
template <> struct is_proto_enum< ::TrezorProtobuf::RequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::RequestType>() {
  return ::TrezorProtobuf::RequestType_descriptor();
}
template <> struct is_proto_enum< ::TrezorProtobuf::ButtonRequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::ButtonRequestType>() {
  return ::TrezorProtobuf::ButtonRequestType_descriptor();
}
template <> struct is_proto_enum< ::TrezorProtobuf::PinMatrixRequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::PinMatrixRequestType>() {
  return ::TrezorProtobuf::PinMatrixRequestType_descriptor();
}
template <> struct is_proto_enum< ::TrezorProtobuf::RecoveryDeviceType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::RecoveryDeviceType>() {
  return ::TrezorProtobuf::RecoveryDeviceType_descriptor();
}
template <> struct is_proto_enum< ::TrezorProtobuf::WordRequestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::WordRequestType>() {
  return ::TrezorProtobuf::WordRequestType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_types_2eproto__INCLUDED
