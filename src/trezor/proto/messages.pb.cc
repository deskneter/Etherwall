// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace TrezorProtobuf {
class InitializeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Initialize> {
} _Initialize_default_instance_;
class GetFeaturesDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetFeatures> {
} _GetFeatures_default_instance_;
class FeaturesDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Features> {
} _Features_default_instance_;
class ClearSessionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ClearSession> {
} _ClearSession_default_instance_;
class ApplySettingsDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ApplySettings> {
} _ApplySettings_default_instance_;
class ChangePinDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ChangePin> {
} _ChangePin_default_instance_;
class PingDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Ping> {
} _Ping_default_instance_;
class SuccessDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Success> {
} _Success_default_instance_;
class FailureDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Failure> {
} _Failure_default_instance_;
class ButtonRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ButtonRequest> {
} _ButtonRequest_default_instance_;
class ButtonAckDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ButtonAck> {
} _ButtonAck_default_instance_;
class PinMatrixRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PinMatrixRequest> {
} _PinMatrixRequest_default_instance_;
class PinMatrixAckDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PinMatrixAck> {
} _PinMatrixAck_default_instance_;
class CancelDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Cancel> {
} _Cancel_default_instance_;
class PassphraseRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PassphraseRequest> {
} _PassphraseRequest_default_instance_;
class PassphraseAckDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PassphraseAck> {
} _PassphraseAck_default_instance_;
class GetEntropyDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetEntropy> {
} _GetEntropy_default_instance_;
class EntropyDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Entropy> {
} _Entropy_default_instance_;
class GetPublicKeyDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetPublicKey> {
} _GetPublicKey_default_instance_;
class PublicKeyDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PublicKey> {
} _PublicKey_default_instance_;
class GetAddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetAddress> {
} _GetAddress_default_instance_;
class EthereumGetAddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EthereumGetAddress> {
} _EthereumGetAddress_default_instance_;
class AddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Address> {
} _Address_default_instance_;
class EthereumAddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EthereumAddress> {
} _EthereumAddress_default_instance_;
class WipeDeviceDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<WipeDevice> {
} _WipeDevice_default_instance_;
class LoadDeviceDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<LoadDevice> {
} _LoadDevice_default_instance_;
class ResetDeviceDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ResetDevice> {
} _ResetDevice_default_instance_;
class EntropyRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EntropyRequest> {
} _EntropyRequest_default_instance_;
class EntropyAckDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EntropyAck> {
} _EntropyAck_default_instance_;
class RecoveryDeviceDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RecoveryDevice> {
} _RecoveryDevice_default_instance_;
class WordRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<WordRequest> {
} _WordRequest_default_instance_;
class WordAckDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<WordAck> {
} _WordAck_default_instance_;
class SignMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SignMessage> {
} _SignMessage_default_instance_;
class VerifyMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<VerifyMessage> {
} _VerifyMessage_default_instance_;
class MessageSignatureDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<MessageSignature> {
} _MessageSignature_default_instance_;
class EncryptMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EncryptMessage> {
} _EncryptMessage_default_instance_;
class EncryptedMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EncryptedMessage> {
} _EncryptedMessage_default_instance_;
class DecryptMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DecryptMessage> {
} _DecryptMessage_default_instance_;
class DecryptedMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DecryptedMessage> {
} _DecryptedMessage_default_instance_;
class CipherKeyValueDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CipherKeyValue> {
} _CipherKeyValue_default_instance_;
class CipheredKeyValueDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<CipheredKeyValue> {
} _CipheredKeyValue_default_instance_;
class EstimateTxSizeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EstimateTxSize> {
} _EstimateTxSize_default_instance_;
class TxSizeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TxSize> {
} _TxSize_default_instance_;
class SignTxDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SignTx> {
} _SignTx_default_instance_;
class SimpleSignTxDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SimpleSignTx> {
} _SimpleSignTx_default_instance_;
class TxRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TxRequest> {
} _TxRequest_default_instance_;
class TxAckDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TxAck> {
} _TxAck_default_instance_;
class EthereumSignTxDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EthereumSignTx> {
} _EthereumSignTx_default_instance_;
class EthereumTxRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EthereumTxRequest> {
} _EthereumTxRequest_default_instance_;
class EthereumTxAckDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<EthereumTxAck> {
} _EthereumTxAck_default_instance_;
class SignIdentityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SignIdentity> {
} _SignIdentity_default_instance_;
class SignedIdentityDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SignedIdentity> {
} _SignedIdentity_default_instance_;
class GetECDHSessionKeyDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<GetECDHSessionKey> {
} _GetECDHSessionKey_default_instance_;
class ECDHSessionKeyDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ECDHSessionKey> {
} _ECDHSessionKey_default_instance_;
class SetU2FCounterDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<SetU2FCounter> {
} _SetU2FCounter_default_instance_;
class FirmwareEraseDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FirmwareErase> {
} _FirmwareErase_default_instance_;
class FirmwareRequestDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FirmwareRequest> {
} _FirmwareRequest_default_instance_;
class FirmwareUploadDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<FirmwareUpload> {
} _FirmwareUpload_default_instance_;
class DebugLinkDecisionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkDecision> {
} _DebugLinkDecision_default_instance_;
class DebugLinkGetStateDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkGetState> {
} _DebugLinkGetState_default_instance_;
class DebugLinkStateDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkState> {
} _DebugLinkState_default_instance_;
class DebugLinkStopDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkStop> {
} _DebugLinkStop_default_instance_;
class DebugLinkLogDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkLog> {
} _DebugLinkLog_default_instance_;
class DebugLinkMemoryReadDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkMemoryRead> {
} _DebugLinkMemoryRead_default_instance_;
class DebugLinkMemoryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkMemory> {
} _DebugLinkMemory_default_instance_;
class DebugLinkMemoryWriteDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkMemoryWrite> {
} _DebugLinkMemoryWrite_default_instance_;
class DebugLinkFlashEraseDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<DebugLinkFlashErase> {
} _DebugLinkFlashErase_default_instance_;

namespace protobuf_messages_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[67];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[1];

}  // namespace

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initialize, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initialize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetFeatures, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetFeatures, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, vendor_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, major_version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, minor_version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, patch_version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, bootloader_mode_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, device_id_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, pin_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, passphrase_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, language_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, label_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, coins_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, initialized_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, revision_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, bootloader_hash_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, imported_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, pin_cached_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, passphrase_cached_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, firmware_present_),
  0,
  6,
  7,
  8,
  9,
  1,
  10,
  11,
  2,
  3,
  ~0u,
  12,
  4,
  5,
  13,
  14,
  15,
  16,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClearSession, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClearSession, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, language_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, label_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, use_passphrase_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, homescreen_),
  0,
  1,
  3,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, remove_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, button_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, pin_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, passphrase_protection_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, message_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, code_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, message_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, code_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, data_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, type_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, pin_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cancel, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cancel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseAck, passphrase_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, size_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, entropy_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, ecdsa_curve_name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, show_display_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, coin_name_),
  ~0u,
  0,
  2,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, node_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, xpub_),
  1,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, coin_name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, show_display_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, multisig_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, script_type_),
  ~0u,
  0,
  2,
  1,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumGetAddress, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumGetAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumGetAddress, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumGetAddress, show_display_),
  ~0u,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, address_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumAddress, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumAddress, address_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WipeDevice, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WipeDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, mnemonic_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, node_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, pin_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, passphrase_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, language_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, label_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, skip_checksum_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, u2f_counter_),
  0,
  4,
  1,
  5,
  2,
  3,
  6,
  7,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, display_random_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, strength_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, passphrase_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, pin_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, language_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, label_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, u2f_counter_),
  2,
  6,
  3,
  4,
  0,
  1,
  5,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, entropy_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, word_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, passphrase_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, pin_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, language_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, label_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, enforce_wordlist_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, u2f_counter_),
  2,
  3,
  4,
  0,
  1,
  5,
  6,
  7,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRequest, type_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordAck, word_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, coin_name_),
  ~0u,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, signature_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, coin_name_),
  0,
  1,
  2,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, signature_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, pubkey_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, display_only_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, coin_name_),
  0,
  1,
  3,
  ~0u,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedMessage, nonce_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedMessage, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptedMessage, hmac_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, nonce_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, hmac_),
  ~0u,
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptedMessage, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptedMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptedMessage, message_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptedMessage, address_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, key_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, value_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, encrypt_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, ask_on_encrypt_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, ask_on_decrypt_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, iv_),
  ~0u,
  0,
  1,
  3,
  4,
  5,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipheredKeyValue, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipheredKeyValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipheredKeyValue, value_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, outputs_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, inputs_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, coin_name_),
  1,
  2,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxSize, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxSize, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxSize, tx_size_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, outputs_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, inputs_count_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, coin_name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, lock_time_),
  1,
  2,
  0,
  4,
  3,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, inputs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, outputs_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, transactions_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, coin_name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, version_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, lock_time_),
  ~0u,
  ~0u,
  ~0u,
  0,
  2,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, request_type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, details_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, serialized_),
  2,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, tx_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, address_n_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, nonce_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, gas_price_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, gas_limit_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, to_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, value_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, data_initial_chunk_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, data_length_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumSignTx, chain_id_),
  ~0u,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxRequest, data_length_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxRequest, signature_v_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxRequest, signature_r_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxRequest, signature_s_),
  2,
  3,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxAck, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EthereumTxAck, data_chunk_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignIdentity, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignIdentity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignIdentity, identity_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignIdentity, challenge_hidden_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignIdentity, challenge_visual_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignIdentity, ecdsa_curve_name_),
  3,
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedIdentity, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedIdentity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedIdentity, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedIdentity, public_key_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignedIdentity, signature_),
  0,
  1,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetECDHSessionKey, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetECDHSessionKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetECDHSessionKey, identity_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetECDHSessionKey, peer_public_key_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetECDHSessionKey, ecdsa_curve_name_),
  2,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDHSessionKey, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDHSessionKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECDHSessionKey, session_key_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetU2FCounter, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetU2FCounter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetU2FCounter, u2f_counter_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareErase, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareErase, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareRequest, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareRequest, offset_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareRequest, length_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareUpload, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareUpload, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareUpload, payload_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareUpload, hash_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, yes_no_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, layout_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, pin_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, matrix_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, mnemonic_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, node_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, passphrase_protection_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, reset_word_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, reset_entropy_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, recovery_fake_word_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, recovery_word_pos_),
  0,
  1,
  2,
  3,
  7,
  8,
  4,
  5,
  6,
  9,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkStop, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkStop, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, level_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, bucket_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, text_),
  2,
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryRead, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryRead, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryRead, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryRead, length_),
  0,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemory, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemory, memory_),
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryWrite, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryWrite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryWrite, address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryWrite, memory_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkMemoryWrite, flash_),
  1,
  0,
  2,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkFlashErase, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkFlashErase, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkFlashErase, sector_),
  0,
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, 5, sizeof(Initialize)},
  { 5, 10, sizeof(GetFeatures)},
  { 10, 33, sizeof(Features)},
  { 51, 56, sizeof(ClearSession)},
  { 56, 65, sizeof(ApplySettings)},
  { 69, 75, sizeof(ChangePin)},
  { 76, 85, sizeof(Ping)},
  { 89, 95, sizeof(Success)},
  { 96, 103, sizeof(Failure)},
  { 105, 112, sizeof(ButtonRequest)},
  { 114, 119, sizeof(ButtonAck)},
  { 119, 125, sizeof(PinMatrixRequest)},
  { 126, 132, sizeof(PinMatrixAck)},
  { 133, 138, sizeof(Cancel)},
  { 138, 143, sizeof(PassphraseRequest)},
  { 143, 149, sizeof(PassphraseAck)},
  { 150, 156, sizeof(GetEntropy)},
  { 157, 163, sizeof(Entropy)},
  { 164, 173, sizeof(GetPublicKey)},
  { 177, 184, sizeof(PublicKey)},
  { 186, 196, sizeof(GetAddress)},
  { 201, 208, sizeof(EthereumGetAddress)},
  { 210, 216, sizeof(Address)},
  { 217, 223, sizeof(EthereumAddress)},
  { 224, 229, sizeof(WipeDevice)},
  { 229, 242, sizeof(LoadDevice)},
  { 250, 262, sizeof(ResetDevice)},
  { 269, 274, sizeof(EntropyRequest)},
  { 274, 280, sizeof(EntropyAck)},
  { 281, 294, sizeof(RecoveryDevice)},
  { 302, 308, sizeof(WordRequest)},
  { 309, 315, sizeof(WordAck)},
  { 316, 324, sizeof(SignMessage)},
  { 327, 336, sizeof(VerifyMessage)},
  { 340, 347, sizeof(MessageSignature)},
  { 349, 359, sizeof(EncryptMessage)},
  { 364, 372, sizeof(EncryptedMessage)},
  { 375, 384, sizeof(DecryptMessage)},
  { 388, 395, sizeof(DecryptedMessage)},
  { 397, 409, sizeof(CipherKeyValue)},
  { 416, 422, sizeof(CipheredKeyValue)},
  { 423, 431, sizeof(EstimateTxSize)},
  { 434, 440, sizeof(TxSize)},
  { 441, 451, sizeof(SignTx)},
  { 456, 467, sizeof(SimpleSignTx)},
  { 473, 481, sizeof(TxRequest)},
  { 484, 490, sizeof(TxAck)},
  { 491, 505, sizeof(EthereumSignTx)},
  { 514, 523, sizeof(EthereumTxRequest)},
  { 527, 533, sizeof(EthereumTxAck)},
  { 534, 543, sizeof(SignIdentity)},
  { 547, 555, sizeof(SignedIdentity)},
  { 558, 566, sizeof(GetECDHSessionKey)},
  { 569, 575, sizeof(ECDHSessionKey)},
  { 576, 582, sizeof(SetU2FCounter)},
  { 583, 588, sizeof(FirmwareErase)},
  { 588, 595, sizeof(FirmwareRequest)},
  { 597, 604, sizeof(FirmwareUpload)},
  { 606, 612, sizeof(DebugLinkDecision)},
  { 613, 618, sizeof(DebugLinkGetState)},
  { 618, 633, sizeof(DebugLinkState)},
  { 643, 648, sizeof(DebugLinkStop)},
  { 648, 656, sizeof(DebugLinkLog)},
  { 659, 666, sizeof(DebugLinkMemoryRead)},
  { 668, 674, sizeof(DebugLinkMemory)},
  { 675, 683, sizeof(DebugLinkMemoryWrite)},
  { 686, 692, sizeof(DebugLinkFlashErase)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_Initialize_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetFeatures_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Features_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ClearSession_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ApplySettings_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ChangePin_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Ping_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Success_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Failure_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ButtonRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ButtonAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PinMatrixRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PinMatrixAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Cancel_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PassphraseRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PassphraseAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetEntropy_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Entropy_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetPublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_PublicKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EthereumGetAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_Address_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EthereumAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_WipeDevice_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_LoadDevice_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ResetDevice_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EntropyRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EntropyAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_RecoveryDevice_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_WordRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_WordAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SignMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_VerifyMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_MessageSignature_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EncryptMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EncryptedMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DecryptMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DecryptedMessage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CipherKeyValue_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_CipheredKeyValue_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EstimateTxSize_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_TxSize_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SignTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SimpleSignTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_TxRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_TxAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EthereumSignTx_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EthereumTxRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_EthereumTxAck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SignIdentity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SignedIdentity_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_GetECDHSessionKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ECDHSessionKey_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_SetU2FCounter_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_FirmwareErase_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_FirmwareRequest_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_FirmwareUpload_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkDecision_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkGetState_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkState_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkStop_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkLog_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkMemoryRead_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkMemory_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkMemoryWrite_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_DebugLinkFlashErase_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "messages.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 67);
}

}  // namespace

void TableStruct::Shutdown() {
  _Initialize_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _GetFeatures_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _Features_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _ClearSession_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _ApplySettings_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _ChangePin_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _Ping_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _Success_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
  _Failure_default_instance_.Shutdown();
  delete file_level_metadata[8].reflection;
  _ButtonRequest_default_instance_.Shutdown();
  delete file_level_metadata[9].reflection;
  _ButtonAck_default_instance_.Shutdown();
  delete file_level_metadata[10].reflection;
  _PinMatrixRequest_default_instance_.Shutdown();
  delete file_level_metadata[11].reflection;
  _PinMatrixAck_default_instance_.Shutdown();
  delete file_level_metadata[12].reflection;
  _Cancel_default_instance_.Shutdown();
  delete file_level_metadata[13].reflection;
  _PassphraseRequest_default_instance_.Shutdown();
  delete file_level_metadata[14].reflection;
  _PassphraseAck_default_instance_.Shutdown();
  delete file_level_metadata[15].reflection;
  _GetEntropy_default_instance_.Shutdown();
  delete file_level_metadata[16].reflection;
  _Entropy_default_instance_.Shutdown();
  delete file_level_metadata[17].reflection;
  _GetPublicKey_default_instance_.Shutdown();
  delete file_level_metadata[18].reflection;
  GetPublicKey::_default_coin_name_.Shutdown();
  _PublicKey_default_instance_.Shutdown();
  delete file_level_metadata[19].reflection;
  _GetAddress_default_instance_.Shutdown();
  delete file_level_metadata[20].reflection;
  GetAddress::_default_coin_name_.Shutdown();
  _EthereumGetAddress_default_instance_.Shutdown();
  delete file_level_metadata[21].reflection;
  _Address_default_instance_.Shutdown();
  delete file_level_metadata[22].reflection;
  _EthereumAddress_default_instance_.Shutdown();
  delete file_level_metadata[23].reflection;
  _WipeDevice_default_instance_.Shutdown();
  delete file_level_metadata[24].reflection;
  _LoadDevice_default_instance_.Shutdown();
  delete file_level_metadata[25].reflection;
  LoadDevice::_default_language_.Shutdown();
  _ResetDevice_default_instance_.Shutdown();
  delete file_level_metadata[26].reflection;
  ResetDevice::_default_language_.Shutdown();
  _EntropyRequest_default_instance_.Shutdown();
  delete file_level_metadata[27].reflection;
  _EntropyAck_default_instance_.Shutdown();
  delete file_level_metadata[28].reflection;
  _RecoveryDevice_default_instance_.Shutdown();
  delete file_level_metadata[29].reflection;
  RecoveryDevice::_default_language_.Shutdown();
  _WordRequest_default_instance_.Shutdown();
  delete file_level_metadata[30].reflection;
  _WordAck_default_instance_.Shutdown();
  delete file_level_metadata[31].reflection;
  _SignMessage_default_instance_.Shutdown();
  delete file_level_metadata[32].reflection;
  SignMessage::_default_coin_name_.Shutdown();
  _VerifyMessage_default_instance_.Shutdown();
  delete file_level_metadata[33].reflection;
  VerifyMessage::_default_coin_name_.Shutdown();
  _MessageSignature_default_instance_.Shutdown();
  delete file_level_metadata[34].reflection;
  _EncryptMessage_default_instance_.Shutdown();
  delete file_level_metadata[35].reflection;
  EncryptMessage::_default_coin_name_.Shutdown();
  _EncryptedMessage_default_instance_.Shutdown();
  delete file_level_metadata[36].reflection;
  _DecryptMessage_default_instance_.Shutdown();
  delete file_level_metadata[37].reflection;
  _DecryptedMessage_default_instance_.Shutdown();
  delete file_level_metadata[38].reflection;
  _CipherKeyValue_default_instance_.Shutdown();
  delete file_level_metadata[39].reflection;
  _CipheredKeyValue_default_instance_.Shutdown();
  delete file_level_metadata[40].reflection;
  _EstimateTxSize_default_instance_.Shutdown();
  delete file_level_metadata[41].reflection;
  EstimateTxSize::_default_coin_name_.Shutdown();
  _TxSize_default_instance_.Shutdown();
  delete file_level_metadata[42].reflection;
  _SignTx_default_instance_.Shutdown();
  delete file_level_metadata[43].reflection;
  SignTx::_default_coin_name_.Shutdown();
  _SimpleSignTx_default_instance_.Shutdown();
  delete file_level_metadata[44].reflection;
  SimpleSignTx::_default_coin_name_.Shutdown();
  _TxRequest_default_instance_.Shutdown();
  delete file_level_metadata[45].reflection;
  _TxAck_default_instance_.Shutdown();
  delete file_level_metadata[46].reflection;
  _EthereumSignTx_default_instance_.Shutdown();
  delete file_level_metadata[47].reflection;
  _EthereumTxRequest_default_instance_.Shutdown();
  delete file_level_metadata[48].reflection;
  _EthereumTxAck_default_instance_.Shutdown();
  delete file_level_metadata[49].reflection;
  _SignIdentity_default_instance_.Shutdown();
  delete file_level_metadata[50].reflection;
  _SignedIdentity_default_instance_.Shutdown();
  delete file_level_metadata[51].reflection;
  _GetECDHSessionKey_default_instance_.Shutdown();
  delete file_level_metadata[52].reflection;
  _ECDHSessionKey_default_instance_.Shutdown();
  delete file_level_metadata[53].reflection;
  _SetU2FCounter_default_instance_.Shutdown();
  delete file_level_metadata[54].reflection;
  _FirmwareErase_default_instance_.Shutdown();
  delete file_level_metadata[55].reflection;
  _FirmwareRequest_default_instance_.Shutdown();
  delete file_level_metadata[56].reflection;
  _FirmwareUpload_default_instance_.Shutdown();
  delete file_level_metadata[57].reflection;
  _DebugLinkDecision_default_instance_.Shutdown();
  delete file_level_metadata[58].reflection;
  _DebugLinkGetState_default_instance_.Shutdown();
  delete file_level_metadata[59].reflection;
  _DebugLinkState_default_instance_.Shutdown();
  delete file_level_metadata[60].reflection;
  _DebugLinkStop_default_instance_.Shutdown();
  delete file_level_metadata[61].reflection;
  _DebugLinkLog_default_instance_.Shutdown();
  delete file_level_metadata[62].reflection;
  _DebugLinkMemoryRead_default_instance_.Shutdown();
  delete file_level_metadata[63].reflection;
  _DebugLinkMemory_default_instance_.Shutdown();
  delete file_level_metadata[64].reflection;
  _DebugLinkMemoryWrite_default_instance_.Shutdown();
  delete file_level_metadata[65].reflection;
  _DebugLinkFlashErase_default_instance_.Shutdown();
  delete file_level_metadata[66].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::TrezorProtobuf::protobuf_types_2eproto::InitDefaults();
  _Initialize_default_instance_.DefaultConstruct();
  _GetFeatures_default_instance_.DefaultConstruct();
  _Features_default_instance_.DefaultConstruct();
  _ClearSession_default_instance_.DefaultConstruct();
  _ApplySettings_default_instance_.DefaultConstruct();
  _ChangePin_default_instance_.DefaultConstruct();
  _Ping_default_instance_.DefaultConstruct();
  _Success_default_instance_.DefaultConstruct();
  _Failure_default_instance_.DefaultConstruct();
  _ButtonRequest_default_instance_.DefaultConstruct();
  _ButtonAck_default_instance_.DefaultConstruct();
  _PinMatrixRequest_default_instance_.DefaultConstruct();
  _PinMatrixAck_default_instance_.DefaultConstruct();
  _Cancel_default_instance_.DefaultConstruct();
  _PassphraseRequest_default_instance_.DefaultConstruct();
  _PassphraseAck_default_instance_.DefaultConstruct();
  _GetEntropy_default_instance_.DefaultConstruct();
  _Entropy_default_instance_.DefaultConstruct();
  GetPublicKey::_default_coin_name_.DefaultConstruct();
  *GetPublicKey::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _GetPublicKey_default_instance_.DefaultConstruct();
  _PublicKey_default_instance_.DefaultConstruct();
  GetAddress::_default_coin_name_.DefaultConstruct();
  *GetAddress::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _GetAddress_default_instance_.DefaultConstruct();
  _EthereumGetAddress_default_instance_.DefaultConstruct();
  _Address_default_instance_.DefaultConstruct();
  _EthereumAddress_default_instance_.DefaultConstruct();
  _WipeDevice_default_instance_.DefaultConstruct();
  LoadDevice::_default_language_.DefaultConstruct();
  *LoadDevice::_default_language_.get_mutable() = ::std::string("english", 7);
  _LoadDevice_default_instance_.DefaultConstruct();
  ResetDevice::_default_language_.DefaultConstruct();
  *ResetDevice::_default_language_.get_mutable() = ::std::string("english", 7);
  _ResetDevice_default_instance_.DefaultConstruct();
  _EntropyRequest_default_instance_.DefaultConstruct();
  _EntropyAck_default_instance_.DefaultConstruct();
  RecoveryDevice::_default_language_.DefaultConstruct();
  *RecoveryDevice::_default_language_.get_mutable() = ::std::string("english", 7);
  _RecoveryDevice_default_instance_.DefaultConstruct();
  _WordRequest_default_instance_.DefaultConstruct();
  _WordAck_default_instance_.DefaultConstruct();
  SignMessage::_default_coin_name_.DefaultConstruct();
  *SignMessage::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _SignMessage_default_instance_.DefaultConstruct();
  VerifyMessage::_default_coin_name_.DefaultConstruct();
  *VerifyMessage::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _VerifyMessage_default_instance_.DefaultConstruct();
  _MessageSignature_default_instance_.DefaultConstruct();
  EncryptMessage::_default_coin_name_.DefaultConstruct();
  *EncryptMessage::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _EncryptMessage_default_instance_.DefaultConstruct();
  _EncryptedMessage_default_instance_.DefaultConstruct();
  _DecryptMessage_default_instance_.DefaultConstruct();
  _DecryptedMessage_default_instance_.DefaultConstruct();
  _CipherKeyValue_default_instance_.DefaultConstruct();
  _CipheredKeyValue_default_instance_.DefaultConstruct();
  EstimateTxSize::_default_coin_name_.DefaultConstruct();
  *EstimateTxSize::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _EstimateTxSize_default_instance_.DefaultConstruct();
  _TxSize_default_instance_.DefaultConstruct();
  SignTx::_default_coin_name_.DefaultConstruct();
  *SignTx::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _SignTx_default_instance_.DefaultConstruct();
  SimpleSignTx::_default_coin_name_.DefaultConstruct();
  *SimpleSignTx::_default_coin_name_.get_mutable() = ::std::string("Bitcoin", 7);
  _SimpleSignTx_default_instance_.DefaultConstruct();
  _TxRequest_default_instance_.DefaultConstruct();
  _TxAck_default_instance_.DefaultConstruct();
  _EthereumSignTx_default_instance_.DefaultConstruct();
  _EthereumTxRequest_default_instance_.DefaultConstruct();
  _EthereumTxAck_default_instance_.DefaultConstruct();
  _SignIdentity_default_instance_.DefaultConstruct();
  _SignedIdentity_default_instance_.DefaultConstruct();
  _GetECDHSessionKey_default_instance_.DefaultConstruct();
  _ECDHSessionKey_default_instance_.DefaultConstruct();
  _SetU2FCounter_default_instance_.DefaultConstruct();
  _FirmwareErase_default_instance_.DefaultConstruct();
  _FirmwareRequest_default_instance_.DefaultConstruct();
  _FirmwareUpload_default_instance_.DefaultConstruct();
  _DebugLinkDecision_default_instance_.DefaultConstruct();
  _DebugLinkGetState_default_instance_.DefaultConstruct();
  _DebugLinkState_default_instance_.DefaultConstruct();
  _DebugLinkStop_default_instance_.DefaultConstruct();
  _DebugLinkLog_default_instance_.DefaultConstruct();
  _DebugLinkMemoryRead_default_instance_.DefaultConstruct();
  _DebugLinkMemory_default_instance_.DefaultConstruct();
  _DebugLinkMemoryWrite_default_instance_.DefaultConstruct();
  _DebugLinkFlashErase_default_instance_.DefaultConstruct();
  _PublicKey_default_instance_.get_mutable()->node_ = const_cast< ::TrezorProtobuf::HDNodeType*>(
      ::TrezorProtobuf::HDNodeType::internal_default_instance());
  _GetAddress_default_instance_.get_mutable()->multisig_ = const_cast< ::TrezorProtobuf::MultisigRedeemScriptType*>(
      ::TrezorProtobuf::MultisigRedeemScriptType::internal_default_instance());
  _LoadDevice_default_instance_.get_mutable()->node_ = const_cast< ::TrezorProtobuf::HDNodeType*>(
      ::TrezorProtobuf::HDNodeType::internal_default_instance());
  _TxRequest_default_instance_.get_mutable()->details_ = const_cast< ::TrezorProtobuf::TxRequestDetailsType*>(
      ::TrezorProtobuf::TxRequestDetailsType::internal_default_instance());
  _TxRequest_default_instance_.get_mutable()->serialized_ = const_cast< ::TrezorProtobuf::TxRequestSerializedType*>(
      ::TrezorProtobuf::TxRequestSerializedType::internal_default_instance());
  _TxAck_default_instance_.get_mutable()->tx_ = const_cast< ::TrezorProtobuf::TransactionType*>(
      ::TrezorProtobuf::TransactionType::internal_default_instance());
  _SignIdentity_default_instance_.get_mutable()->identity_ = const_cast< ::TrezorProtobuf::IdentityType*>(
      ::TrezorProtobuf::IdentityType::internal_default_instance());
  _GetECDHSessionKey_default_instance_.get_mutable()->identity_ = const_cast< ::TrezorProtobuf::IdentityType*>(
      ::TrezorProtobuf::IdentityType::internal_default_instance());
  _DebugLinkState_default_instance_.get_mutable()->node_ = const_cast< ::TrezorProtobuf::HDNodeType*>(
      ::TrezorProtobuf::HDNodeType::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\016messages.proto\022\016TrezorProtobuf\032\013types."
      "proto\"\014\n\nInitialize\"\r\n\013GetFeatures\"\247\003\n\010F"
      "eatures\022\016\n\006vendor\030\001 \001(\t\022\025\n\rmajor_version"
      "\030\002 \001(\r\022\025\n\rminor_version\030\003 \001(\r\022\025\n\rpatch_v"
      "ersion\030\004 \001(\r\022\027\n\017bootloader_mode\030\005 \001(\010\022\021\n"
      "\tdevice_id\030\006 \001(\t\022\026\n\016pin_protection\030\007 \001(\010"
      "\022\035\n\025passphrase_protection\030\010 \001(\010\022\020\n\010langu"
      "age\030\t \001(\t\022\r\n\005label\030\n \001(\t\022\'\n\005coins\030\013 \003(\0132"
      "\030.TrezorProtobuf.CoinType\022\023\n\013initialized"
      "\030\014 \001(\010\022\020\n\010revision\030\r \001(\014\022\027\n\017bootloader_h"
      "ash\030\016 \001(\014\022\020\n\010imported\030\017 \001(\010\022\022\n\npin_cache"
      "d\030\020 \001(\010\022\031\n\021passphrase_cached\030\021 \001(\010\022\030\n\020fi"
      "rmware_present\030\022 \001(\010\"\016\n\014ClearSession\"\\\n\r"
      "ApplySettings\022\020\n\010language\030\001 \001(\t\022\r\n\005label"
      "\030\002 \001(\t\022\026\n\016use_passphrase\030\003 \001(\010\022\022\n\nhomesc"
      "reen\030\004 \001(\014\"\033\n\tChangePin\022\016\n\006remove\030\001 \001(\010\""
      "i\n\004Ping\022\017\n\007message\030\001 \001(\t\022\031\n\021button_prote"
      "ction\030\002 \001(\010\022\026\n\016pin_protection\030\003 \001(\010\022\035\n\025p"
      "assphrase_protection\030\004 \001(\010\"\032\n\007Success\022\017\n"
      "\007message\030\001 \001(\t\"E\n\007Failure\022)\n\004code\030\001 \001(\0162"
      "\033.TrezorProtobuf.FailureType\022\017\n\007message\030"
      "\002 \001(\t\"N\n\rButtonRequest\022/\n\004code\030\001 \001(\0162!.T"
      "rezorProtobuf.ButtonRequestType\022\014\n\004data\030"
      "\002 \001(\t\"\013\n\tButtonAck\"F\n\020PinMatrixRequest\0222"
      "\n\004type\030\001 \001(\0162$.TrezorProtobuf.PinMatrixR"
      "equestType\"\033\n\014PinMatrixAck\022\013\n\003pin\030\001 \002(\t\""
      "\010\n\006Cancel\"\023\n\021PassphraseRequest\"#\n\rPassph"
      "raseAck\022\022\n\npassphrase\030\001 \002(\t\"\032\n\nGetEntrop"
      "y\022\014\n\004size\030\001 \002(\r\"\032\n\007Entropy\022\017\n\007entropy\030\001 "
      "\002(\014\"m\n\014GetPublicKey\022\021\n\taddress_n\030\001 \003(\r\022\030"
      "\n\020ecdsa_curve_name\030\002 \001(\t\022\024\n\014show_display"
      "\030\003 \001(\010\022\032\n\tcoin_name\030\004 \001(\t:\007Bitcoin\"C\n\tPu"
      "blicKey\022(\n\004node\030\001 \002(\0132\032.TrezorProtobuf.H"
      "DNodeType\022\014\n\004xpub\030\002 \001(\t\"\321\001\n\nGetAddress\022\021"
      "\n\taddress_n\030\001 \003(\r\022\032\n\tcoin_name\030\002 \001(\t:\007Bi"
      "tcoin\022\024\n\014show_display\030\003 \001(\010\022:\n\010multisig\030"
      "\004 \001(\0132(.TrezorProtobuf.MultisigRedeemScr"
      "iptType\022B\n\013script_type\030\005 \001(\0162\037.TrezorPro"
      "tobuf.InputScriptType:\014SPENDADDRESS\"=\n\022E"
      "thereumGetAddress\022\021\n\taddress_n\030\001 \003(\r\022\024\n\014"
      "show_display\030\002 \001(\010\"\032\n\007Address\022\017\n\007address"
      "\030\001 \002(\t\"\"\n\017EthereumAddress\022\017\n\007address\030\001 \002"
      "(\014\"\014\n\nWipeDevice\"\312\001\n\nLoadDevice\022\020\n\010mnemo"
      "nic\030\001 \001(\t\022(\n\004node\030\002 \001(\0132\032.TrezorProtobuf"
      ".HDNodeType\022\013\n\003pin\030\003 \001(\t\022\035\n\025passphrase_p"
      "rotection\030\004 \001(\010\022\031\n\010language\030\005 \001(\t:\007engli"
      "sh\022\r\n\005label\030\006 \001(\t\022\025\n\rskip_checksum\030\007 \001(\010"
      "\022\023\n\013u2f_counter\030\010 \001(\r\"\262\001\n\013ResetDevice\022\026\n"
      "\016display_random\030\001 \001(\010\022\025\n\010strength\030\002 \001(\r:"
      "\003256\022\035\n\025passphrase_protection\030\003 \001(\010\022\026\n\016p"
      "in_protection\030\004 \001(\010\022\031\n\010language\030\005 \001(\t:\007e"
      "nglish\022\r\n\005label\030\006 \001(\t\022\023\n\013u2f_counter\030\007 \001"
      "(\r\"\020\n\016EntropyRequest\"\035\n\nEntropyAck\022\017\n\007en"
      "tropy\030\001 \001(\014\"\302\001\n\016RecoveryDevice\022\022\n\nword_c"
      "ount\030\001 \001(\r\022\035\n\025passphrase_protection\030\002 \001("
      "\010\022\026\n\016pin_protection\030\003 \001(\010\022\031\n\010language\030\004 "
      "\001(\t:\007english\022\r\n\005label\030\005 \001(\t\022\030\n\020enforce_w"
      "ordlist\030\006 \001(\010\022\014\n\004type\030\010 \001(\r\022\023\n\013u2f_count"
      "er\030\t \001(\r\"<\n\013WordRequest\022-\n\004type\030\001 \001(\0162\037."
      "TrezorProtobuf.WordRequestType\"\027\n\007WordAc"
      "k\022\014\n\004word\030\001 \002(\t\"M\n\013SignMessage\022\021\n\taddres"
      "s_n\030\001 \003(\r\022\017\n\007message\030\002 \002(\014\022\032\n\tcoin_name\030"
      "\003 \001(\t:\007Bitcoin\"`\n\rVerifyMessage\022\017\n\007addre"
      "ss\030\001 \001(\t\022\021\n\tsignature\030\002 \001(\014\022\017\n\007message\030\003"
      " \001(\014\022\032\n\tcoin_name\030\004 \001(\t:\007Bitcoin\"6\n\020Mess"
      "ageSignature\022\017\n\007address\030\001 \001(\t\022\021\n\tsignatu"
      "re\030\002 \001(\014\"v\n\016EncryptMessage\022\016\n\006pubkey\030\001 \001"
      "(\014\022\017\n\007message\030\002 \001(\014\022\024\n\014display_only\030\003 \001("
      "\010\022\021\n\taddress_n\030\004 \003(\r\022\032\n\tcoin_name\030\005 \001(\t:"
      "\007Bitcoin\"@\n\020EncryptedMessage\022\r\n\005nonce\030\001 "
      "\001(\014\022\017\n\007message\030\002 \001(\014\022\014\n\004hmac\030\003 \001(\014\"Q\n\016De"
      "cryptMessage\022\021\n\taddress_n\030\001 \003(\r\022\r\n\005nonce"
      "\030\002 \001(\014\022\017\n\007message\030\003 \001(\014\022\014\n\004hmac\030\004 \001(\014\"4\n"
      "\020DecryptedMessage\022\017\n\007message\030\001 \001(\014\022\017\n\007ad"
      "dress\030\002 \001(\t\"\214\001\n\016CipherKeyValue\022\021\n\taddres"
      "s_n\030\001 \003(\r\022\013\n\003key\030\002 \001(\t\022\r\n\005value\030\003 \001(\014\022\017\n"
      "\007encrypt\030\004 \001(\010\022\026\n\016ask_on_encrypt\030\005 \001(\010\022\026"
      "\n\016ask_on_decrypt\030\006 \001(\010\022\n\n\002iv\030\007 \001(\014\"!\n\020Ci"
      "pheredKeyValue\022\r\n\005value\030\001 \001(\014\"Y\n\016Estimat"
      "eTxSize\022\025\n\routputs_count\030\001 \002(\r\022\024\n\014inputs"
      "_count\030\002 \002(\r\022\032\n\tcoin_name\030\003 \001(\t:\007Bitcoin"
      "\"\031\n\006TxSize\022\017\n\007tx_size\030\001 \001(\r\"{\n\006SignTx\022\025\n"
      "\routputs_count\030\001 \002(\r\022\024\n\014inputs_count\030\002 \002"
      "(\r\022\032\n\tcoin_name\030\003 \001(\t:\007Bitcoin\022\022\n\007versio"
      "n\030\004 \001(\r:\0011\022\024\n\tlock_time\030\005 \001(\r:\0010\"\347\001\n\014Sim"
      "pleSignTx\022+\n\006inputs\030\001 \003(\0132\033.TrezorProtob"
      "uf.TxInputType\022-\n\007outputs\030\002 \003(\0132\034.Trezor"
      "Protobuf.TxOutputType\0225\n\014transactions\030\003 "
      "\003(\0132\037.TrezorProtobuf.TransactionType\022\032\n\t"
      "coin_name\030\004 \001(\t:\007Bitcoin\022\022\n\007version\030\005 \001("
      "\r:\0011\022\024\n\tlock_time\030\006 \001(\r:\0010\"\262\001\n\tTxRequest"
      "\0221\n\014request_type\030\001 \001(\0162\033.TrezorProtobuf."
      "RequestType\0225\n\007details\030\002 \001(\0132$.TrezorPro"
      "tobuf.TxRequestDetailsType\022;\n\nserialized"
      "\030\003 \001(\0132\'.TrezorProtobuf.TxRequestSeriali"
      "zedType\"4\n\005TxAck\022+\n\002tx\030\001 \001(\0132\037.TrezorPro"
      "tobuf.TransactionType\"\266\001\n\016EthereumSignTx"
      "\022\021\n\taddress_n\030\001 \003(\r\022\r\n\005nonce\030\002 \001(\014\022\021\n\tga"
      "s_price\030\003 \001(\014\022\021\n\tgas_limit\030\004 \001(\014\022\n\n\002to\030\005"
      " \001(\014\022\r\n\005value\030\006 \001(\014\022\032\n\022data_initial_chun"
      "k\030\007 \001(\014\022\023\n\013data_length\030\010 \001(\r\022\020\n\010chain_id"
      "\030\t \001(\r\"g\n\021EthereumTxRequest\022\023\n\013data_leng"
      "th\030\001 \001(\r\022\023\n\013signature_v\030\002 \001(\r\022\023\n\013signatu"
      "re_r\030\003 \001(\014\022\023\n\013signature_s\030\004 \001(\014\"#\n\rEther"
      "eumTxAck\022\022\n\ndata_chunk\030\001 \001(\014\"\214\001\n\014SignIde"
      "ntity\022.\n\010identity\030\001 \001(\0132\034.TrezorProtobuf"
      ".IdentityType\022\030\n\020challenge_hidden\030\002 \001(\014\022"
      "\030\n\020challenge_visual\030\003 \001(\t\022\030\n\020ecdsa_curve"
      "_name\030\004 \001(\t\"H\n\016SignedIdentity\022\017\n\007address"
      "\030\001 \001(\t\022\022\n\npublic_key\030\002 \001(\014\022\021\n\tsignature\030"
      "\003 \001(\014\"v\n\021GetECDHSessionKey\022.\n\010identity\030\001"
      " \001(\0132\034.TrezorProtobuf.IdentityType\022\027\n\017pe"
      "er_public_key\030\002 \001(\014\022\030\n\020ecdsa_curve_name\030"
      "\003 \001(\t\"%\n\016ECDHSessionKey\022\023\n\013session_key\030\001"
      " \001(\014\"$\n\rSetU2FCounter\022\023\n\013u2f_counter\030\001 \001"
      "(\r\"\017\n\rFirmwareErase\"1\n\017FirmwareRequest\022\016"
      "\n\006offset\030\001 \001(\r\022\016\n\006length\030\002 \001(\r\"/\n\016Firmwa"
      "reUpload\022\017\n\007payload\030\001 \002(\014\022\014\n\004hash\030\002 \001(\014\""
      "#\n\021DebugLinkDecision\022\016\n\006yes_no\030\001 \002(\010\"\023\n\021"
      "DebugLinkGetState\"\372\001\n\016DebugLinkState\022\016\n\006"
      "layout\030\001 \001(\014\022\013\n\003pin\030\002 \001(\t\022\016\n\006matrix\030\003 \001("
      "\t\022\020\n\010mnemonic\030\004 \001(\t\022(\n\004node\030\005 \001(\0132\032.Trez"
      "orProtobuf.HDNodeType\022\035\n\025passphrase_prot"
      "ection\030\006 \001(\010\022\022\n\nreset_word\030\007 \001(\t\022\025\n\rrese"
      "t_entropy\030\010 \001(\014\022\032\n\022recovery_fake_word\030\t "
      "\001(\t\022\031\n\021recovery_word_pos\030\n \001(\r\"\017\n\rDebugL"
      "inkStop\";\n\014DebugLinkLog\022\r\n\005level\030\001 \001(\r\022\016"
      "\n\006bucket\030\002 \001(\t\022\014\n\004text\030\003 \001(\t\"6\n\023DebugLin"
      "kMemoryRead\022\017\n\007address\030\001 \001(\r\022\016\n\006length\030\002"
      " \001(\r\"!\n\017DebugLinkMemory\022\016\n\006memory\030\001 \001(\014\""
      "F\n\024DebugLinkMemoryWrite\022\017\n\007address\030\001 \001(\r"
      "\022\016\n\006memory\030\002 \001(\014\022\r\n\005flash\030\003 \001(\010\"%\n\023Debug"
      "LinkFlashErase\022\016\n\006sector\030\001 \001(\r*\253\023\n\013Messa"
      "geType\022 \n\026MessageType_Initialize\020\000\032\004\220\265\030\001"
      "\022\032\n\020MessageType_Ping\020\001\032\004\220\265\030\001\022\035\n\023MessageT"
      "ype_Success\020\002\032\004\230\265\030\001\022\035\n\023MessageType_Failu"
      "re\020\003\032\004\230\265\030\001\022\037\n\025MessageType_ChangePin\020\004\032\004\220"
      "\265\030\001\022 \n\026MessageType_WipeDevice\020\005\032\004\220\265\030\001\022\'\n"
      "\031MessageType_FirmwareErase\020\006\032\010\220\265\030\001\270\265\030\001\022("
      "\n\032MessageType_FirmwareUpload\020\007\032\010\220\265\030\001\270\265\030\001"
      "\022)\n\033MessageType_FirmwareRequest\020\010\032\010\230\265\030\001\270"
      "\265\030\001\022 \n\026MessageType_GetEntropy\020\t\032\004\220\265\030\001\022\035\n"
      "\023MessageType_Entropy\020\n\032\004\230\265\030\001\022\"\n\030MessageT"
      "ype_GetPublicKey\020\013\032\004\220\265\030\001\022\037\n\025MessageType_"
      "PublicKey\020\014\032\004\230\265\030\001\022 \n\026MessageType_LoadDev"
      "ice\020\r\032\004\220\265\030\001\022!\n\027MessageType_ResetDevice\020\016"
      "\032\004\220\265\030\001\022\034\n\022MessageType_SignTx\020\017\032\004\220\265\030\001\022\"\n\030"
      "MessageType_SimpleSignTx\020\020\032\004\220\265\030\001\022\036\n\024Mess"
      "ageType_Features\020\021\032\004\230\265\030\001\022&\n\034MessageType_"
      "PinMatrixRequest\020\022\032\004\230\265\030\001\022&\n\030MessageType_"
      "PinMatrixAck\020\023\032\010\220\265\030\001\260\265\030\001\022\034\n\022MessageType_"
      "Cancel\020\024\032\004\220\265\030\001\022\037\n\025MessageType_TxRequest\020"
      "\025\032\004\230\265\030\001\022\033\n\021MessageType_TxAck\020\026\032\004\220\265\030\001\022$\n\032"
      "MessageType_CipherKeyValue\020\027\032\004\220\265\030\001\022\"\n\030Me"
      "ssageType_ClearSession\020\030\032\004\220\265\030\001\022#\n\031Messag"
      "eType_ApplySettings\020\031\032\004\220\265\030\001\022#\n\031MessageTy"
      "pe_ButtonRequest\020\032\032\004\230\265\030\001\022#\n\025MessageType_"
      "ButtonAck\020\033\032\010\220\265\030\001\260\265\030\001\022 \n\026MessageType_Get"
      "Address\020\035\032\004\220\265\030\001\022\035\n\023MessageType_Address\020\036"
      "\032\004\230\265\030\001\022$\n\032MessageType_EntropyRequest\020#\032\004"
      "\230\265\030\001\022 \n\026MessageType_EntropyAck\020$\032\004\220\265\030\001\022!"
      "\n\027MessageType_SignMessage\020&\032\004\220\265\030\001\022#\n\031Mes"
      "sageType_VerifyMessage\020\'\032\004\220\265\030\001\022&\n\034Messag"
      "eType_MessageSignature\020(\032\004\230\265\030\001\022\'\n\035Messag"
      "eType_PassphraseRequest\020)\032\004\230\265\030\001\022\'\n\031Messa"
      "geType_PassphraseAck\020*\032\010\220\265\030\001\260\265\030\001\022$\n\032Mess"
      "ageType_EstimateTxSize\020+\032\004\220\265\030\001\022\034\n\022Messag"
      "eType_TxSize\020,\032\004\230\265\030\001\022$\n\032MessageType_Reco"
      "veryDevice\020-\032\004\220\265\030\001\022!\n\027MessageType_WordRe"
      "quest\020.\032\004\230\265\030\001\022\035\n\023MessageType_WordAck\020/\032\004"
      "\220\265\030\001\022&\n\034MessageType_CipheredKeyValue\0200\032\004"
      "\230\265\030\001\022$\n\032MessageType_EncryptMessage\0201\032\004\220\265"
      "\030\001\022&\n\034MessageType_EncryptedMessage\0202\032\004\230\265"
      "\030\001\022$\n\032MessageType_DecryptMessage\0203\032\004\220\265\030\001"
      "\022&\n\034MessageType_DecryptedMessage\0204\032\004\230\265\030\001"
      "\022\"\n\030MessageType_SignIdentity\0205\032\004\220\265\030\001\022$\n\032"
      "MessageType_SignedIdentity\0206\032\004\230\265\030\001\022!\n\027Me"
      "ssageType_GetFeatures\0207\032\004\220\265\030\001\022(\n\036Message"
      "Type_EthereumGetAddress\0208\032\004\220\265\030\001\022%\n\033Messa"
      "geType_EthereumAddress\0209\032\004\230\265\030\001\022$\n\032Messag"
      "eType_EthereumSignTx\020:\032\004\220\265\030\001\022\'\n\035MessageT"
      "ype_EthereumTxRequest\020;\032\004\230\265\030\001\022#\n\031Message"
      "Type_EthereumTxAck\020<\032\004\220\265\030\001\022\'\n\035MessageTyp"
      "e_GetECDHSessionKey\020=\032\004\220\265\030\001\022$\n\032MessageTy"
      "pe_ECDHSessionKey\020>\032\004\230\265\030\001\022#\n\031MessageType"
      "_SetU2FCounter\020\?\032\004\220\265\030\001\022+\n\035MessageType_De"
      "bugLinkDecision\020d\032\010\240\265\030\001\260\265\030\001\022\'\n\035MessageTy"
      "pe_DebugLinkGetState\020e\032\004\240\265\030\001\022$\n\032MessageT"
      "ype_DebugLinkState\020f\032\004\250\265\030\001\022#\n\031MessageTyp"
      "e_DebugLinkStop\020g\032\004\240\265\030\001\022\"\n\030MessageType_D"
      "ebugLinkLog\020h\032\004\250\265\030\001\022)\n\037MessageType_Debug"
      "LinkMemoryRead\020n\032\004\240\265\030\001\022%\n\033MessageType_De"
      "bugLinkMemory\020o\032\004\250\265\030\001\022*\n MessageType_Deb"
      "ugLinkMemoryWrite\020p\032\004\240\265\030\001\022)\n\037MessageType"
      "_DebugLinkFlashErase\020q\032\004\240\265\030\001B0\n\037com.sato"
      "shilabs.trezor.protobufB\rTrezorMessage"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 7838);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  ::TrezorProtobuf::protobuf_types_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_messages_2eproto

const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_enum_descriptors[0];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 29:
    case 30:
    case 35:
    case 36:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 110:
    case 111:
    case 112:
    case 113:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Initialize::Initialize()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Initialize)
}
Initialize::Initialize(const Initialize& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Initialize)
}

void Initialize::SharedCtor() {
  _cached_size_ = 0;
}

Initialize::~Initialize() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Initialize)
  SharedDtor();
}

void Initialize::SharedDtor() {
}

void Initialize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Initialize::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Initialize& Initialize::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Initialize* Initialize::New(::google::protobuf::Arena* arena) const {
  Initialize* n = new Initialize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Initialize::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Initialize)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Initialize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Initialize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Initialize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Initialize)
  return false;
#undef DO_
}

void Initialize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Initialize)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Initialize)
}

::google::protobuf::uint8* Initialize::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Initialize)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Initialize)
  return target;
}

size_t Initialize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Initialize)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Initialize::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Initialize)
  GOOGLE_DCHECK_NE(&from, this);
  const Initialize* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Initialize>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Initialize)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Initialize)
    MergeFrom(*source);
  }
}

void Initialize::MergeFrom(const Initialize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Initialize)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void Initialize::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Initialize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Initialize::CopyFrom(const Initialize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Initialize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Initialize::IsInitialized() const {
  return true;
}

void Initialize::Swap(Initialize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Initialize::InternalSwap(Initialize* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Initialize::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Initialize

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetFeatures::GetFeatures()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.GetFeatures)
}
GetFeatures::GetFeatures(const GetFeatures& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.GetFeatures)
}

void GetFeatures::SharedCtor() {
  _cached_size_ = 0;
}

GetFeatures::~GetFeatures() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.GetFeatures)
  SharedDtor();
}

void GetFeatures::SharedDtor() {
}

void GetFeatures::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetFeatures::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetFeatures& GetFeatures::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetFeatures* GetFeatures::New(::google::protobuf::Arena* arena) const {
  GetFeatures* n = new GetFeatures;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetFeatures::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.GetFeatures)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool GetFeatures::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.GetFeatures)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.GetFeatures)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.GetFeatures)
  return false;
#undef DO_
}

void GetFeatures::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.GetFeatures)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.GetFeatures)
}

::google::protobuf::uint8* GetFeatures::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.GetFeatures)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.GetFeatures)
  return target;
}

size_t GetFeatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.GetFeatures)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetFeatures::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.GetFeatures)
  GOOGLE_DCHECK_NE(&from, this);
  const GetFeatures* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetFeatures>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.GetFeatures)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.GetFeatures)
    MergeFrom(*source);
  }
}

void GetFeatures::MergeFrom(const GetFeatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.GetFeatures)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void GetFeatures::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.GetFeatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetFeatures::CopyFrom(const GetFeatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.GetFeatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetFeatures::IsInitialized() const {
  return true;
}

void GetFeatures::Swap(GetFeatures* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetFeatures::InternalSwap(GetFeatures* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetFeatures::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetFeatures

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Features::kVendorFieldNumber;
const int Features::kMajorVersionFieldNumber;
const int Features::kMinorVersionFieldNumber;
const int Features::kPatchVersionFieldNumber;
const int Features::kBootloaderModeFieldNumber;
const int Features::kDeviceIdFieldNumber;
const int Features::kPinProtectionFieldNumber;
const int Features::kPassphraseProtectionFieldNumber;
const int Features::kLanguageFieldNumber;
const int Features::kLabelFieldNumber;
const int Features::kCoinsFieldNumber;
const int Features::kInitializedFieldNumber;
const int Features::kRevisionFieldNumber;
const int Features::kBootloaderHashFieldNumber;
const int Features::kImportedFieldNumber;
const int Features::kPinCachedFieldNumber;
const int Features::kPassphraseCachedFieldNumber;
const int Features::kFirmwarePresentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Features::Features()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Features)
}
Features::Features(const Features& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      coins_(from.coins_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vendor_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_vendor()) {
    vendor_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vendor_);
  }
  device_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_device_id()) {
    device_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_id_);
  }
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_language()) {
    language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
  }
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_label()) {
    label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
  }
  revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_revision()) {
    revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.revision_);
  }
  bootloader_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_bootloader_hash()) {
    bootloader_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bootloader_hash_);
  }
  ::memcpy(&major_version_, &from.major_version_,
    reinterpret_cast<char*>(&firmware_present_) -
    reinterpret_cast<char*>(&major_version_) + sizeof(firmware_present_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Features)
}

void Features::SharedCtor() {
  _cached_size_ = 0;
  vendor_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  revision_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bootloader_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&major_version_, 0, reinterpret_cast<char*>(&firmware_present_) -
    reinterpret_cast<char*>(&major_version_) + sizeof(firmware_present_));
}

Features::~Features() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Features)
  SharedDtor();
}

void Features::SharedDtor() {
  vendor_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  label_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  revision_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bootloader_hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Features::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Features::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Features& Features::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Features* Features::New(::google::protobuf::Arena* arena) const {
  Features* n = new Features;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Features::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Features)
  coins_.Clear();
  if (_has_bits_[0 / 32] & 63u) {
    if (has_vendor()) {
      GOOGLE_DCHECK(!vendor_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*vendor_.UnsafeRawStringPointer())->clear();
    }
    if (has_device_id()) {
      GOOGLE_DCHECK(!device_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*device_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_language()) {
      GOOGLE_DCHECK(!language_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*language_.UnsafeRawStringPointer())->clear();
    }
    if (has_label()) {
      GOOGLE_DCHECK(!label_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*label_.UnsafeRawStringPointer())->clear();
    }
    if (has_revision()) {
      GOOGLE_DCHECK(!revision_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*revision_.UnsafeRawStringPointer())->clear();
    }
    if (has_bootloader_hash()) {
      GOOGLE_DCHECK(!bootloader_hash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*bootloader_hash_.UnsafeRawStringPointer())->clear();
    }
  }
  if (_has_bits_[0 / 32] & 192u) {
    ::memset(&major_version_, 0, reinterpret_cast<char*>(&minor_version_) -
      reinterpret_cast<char*>(&major_version_) + sizeof(minor_version_));
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ::memset(&patch_version_, 0, reinterpret_cast<char*>(&passphrase_cached_) -
      reinterpret_cast<char*>(&patch_version_) + sizeof(passphrase_cached_));
  }
  firmware_present_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Features::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Features)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string vendor = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vendor()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vendor().data(), this->vendor().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Features.vendor");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 major_version = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_major_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &major_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 minor_version = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_minor_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minor_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 patch_version = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_patch_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &patch_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool bootloader_mode = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_bootloader_mode();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bootloader_mode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string device_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->device_id().data(), this->device_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Features.device_id");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool pin_protection = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u)) {
          set_has_pin_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool passphrase_protection = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u)) {
          set_has_passphrase_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Features.language");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string label = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Features.label");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .TrezorProtobuf.CoinType coins = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(90u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_coins()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool initialized = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u)) {
          set_has_initialized();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &initialized_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes revision = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(106u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_revision()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes bootloader_hash = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(114u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bootloader_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool imported = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(120u)) {
          set_has_imported();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &imported_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool pin_cached = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(128u)) {
          set_has_pin_cached();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_cached_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool passphrase_cached = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(136u)) {
          set_has_passphrase_cached();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_cached_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool firmware_present = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(144u)) {
          set_has_firmware_present();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &firmware_present_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Features)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Features)
  return false;
#undef DO_
}

void Features::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Features)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string vendor = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.vendor");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->vendor(), output);
  }

  // optional uint32 major_version = 2;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->major_version(), output);
  }

  // optional uint32 minor_version = 3;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->minor_version(), output);
  }

  // optional uint32 patch_version = 4;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->patch_version(), output);
  }

  // optional bool bootloader_mode = 5;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->bootloader_mode(), output);
  }

  // optional string device_id = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_id().data(), this->device_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.device_id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->device_id(), output);
  }

  // optional bool pin_protection = 7;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->pin_protection(), output);
  }

  // optional bool passphrase_protection = 8;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->passphrase_protection(), output);
  }

  // optional string language = 9;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->language(), output);
  }

  // optional string label = 10;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.label");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->label(), output);
  }

  // repeated .TrezorProtobuf.CoinType coins = 11;
  for (unsigned int i = 0, n = this->coins_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->coins(i), output);
  }

  // optional bool initialized = 12;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->initialized(), output);
  }

  // optional bytes revision = 13;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      13, this->revision(), output);
  }

  // optional bytes bootloader_hash = 14;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      14, this->bootloader_hash(), output);
  }

  // optional bool imported = 15;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->imported(), output);
  }

  // optional bool pin_cached = 16;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->pin_cached(), output);
  }

  // optional bool passphrase_cached = 17;
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->passphrase_cached(), output);
  }

  // optional bool firmware_present = 18;
  if (cached_has_bits & 0x00010000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->firmware_present(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Features)
}

::google::protobuf::uint8* Features::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Features)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string vendor = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.vendor");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vendor(), target);
  }

  // optional uint32 major_version = 2;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->major_version(), target);
  }

  // optional uint32 minor_version = 3;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->minor_version(), target);
  }

  // optional uint32 patch_version = 4;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->patch_version(), target);
  }

  // optional bool bootloader_mode = 5;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->bootloader_mode(), target);
  }

  // optional string device_id = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->device_id().data(), this->device_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.device_id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->device_id(), target);
  }

  // optional bool pin_protection = 7;
  if (cached_has_bits & 0x00000400u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->pin_protection(), target);
  }

  // optional bool passphrase_protection = 8;
  if (cached_has_bits & 0x00000800u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->passphrase_protection(), target);
  }

  // optional string language = 9;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->language(), target);
  }

  // optional string label = 10;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Features.label");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->label(), target);
  }

  // repeated .TrezorProtobuf.CoinType coins = 11;
  for (unsigned int i = 0, n = this->coins_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, this->coins(i), deterministic, target);
  }

  // optional bool initialized = 12;
  if (cached_has_bits & 0x00001000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->initialized(), target);
  }

  // optional bytes revision = 13;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        13, this->revision(), target);
  }

  // optional bytes bootloader_hash = 14;
  if (cached_has_bits & 0x00000020u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        14, this->bootloader_hash(), target);
  }

  // optional bool imported = 15;
  if (cached_has_bits & 0x00002000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->imported(), target);
  }

  // optional bool pin_cached = 16;
  if (cached_has_bits & 0x00004000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(16, this->pin_cached(), target);
  }

  // optional bool passphrase_cached = 17;
  if (cached_has_bits & 0x00008000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->passphrase_cached(), target);
  }

  // optional bool firmware_present = 18;
  if (cached_has_bits & 0x00010000u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->firmware_present(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Features)
  return target;
}

size_t Features::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Features)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .TrezorProtobuf.CoinType coins = 11;
  {
    unsigned int count = this->coins_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->coins(i));
    }
  }

  if (_has_bits_[0 / 32] & 255u) {
    // optional string vendor = 1;
    if (has_vendor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vendor());
    }

    // optional string device_id = 6;
    if (has_device_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_id());
    }

    // optional string language = 9;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 10;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional bytes revision = 13;
    if (has_revision()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->revision());
    }

    // optional bytes bootloader_hash = 14;
    if (has_bootloader_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bootloader_hash());
    }

    // optional uint32 major_version = 2;
    if (has_major_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->major_version());
    }

    // optional uint32 minor_version = 3;
    if (has_minor_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->minor_version());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional uint32 patch_version = 4;
    if (has_patch_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->patch_version());
    }

    // optional bool bootloader_mode = 5;
    if (has_bootloader_mode()) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 7;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_protection = 8;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional bool initialized = 12;
    if (has_initialized()) {
      total_size += 1 + 1;
    }

    // optional bool imported = 15;
    if (has_imported()) {
      total_size += 1 + 1;
    }

    // optional bool pin_cached = 16;
    if (has_pin_cached()) {
      total_size += 2 + 1;
    }

    // optional bool passphrase_cached = 17;
    if (has_passphrase_cached()) {
      total_size += 2 + 1;
    }

  }
  // optional bool firmware_present = 18;
  if (has_firmware_present()) {
    total_size += 2 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Features::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Features)
  GOOGLE_DCHECK_NE(&from, this);
  const Features* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Features>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Features)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Features)
    MergeFrom(*source);
  }
}

void Features::MergeFrom(const Features& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Features)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  coins_.MergeFrom(from.coins_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_vendor();
      vendor_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vendor_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_device_id();
      device_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_language();
      language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_label();
      label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_revision();
      revision_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.revision_);
    }
    if (cached_has_bits & 0x00000020u) {
      set_has_bootloader_hash();
      bootloader_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bootloader_hash_);
    }
    if (cached_has_bits & 0x00000040u) {
      major_version_ = from.major_version_;
    }
    if (cached_has_bits & 0x00000080u) {
      minor_version_ = from.minor_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 65280u) {
    if (cached_has_bits & 0x00000100u) {
      patch_version_ = from.patch_version_;
    }
    if (cached_has_bits & 0x00000200u) {
      bootloader_mode_ = from.bootloader_mode_;
    }
    if (cached_has_bits & 0x00000400u) {
      pin_protection_ = from.pin_protection_;
    }
    if (cached_has_bits & 0x00000800u) {
      passphrase_protection_ = from.passphrase_protection_;
    }
    if (cached_has_bits & 0x00001000u) {
      initialized_ = from.initialized_;
    }
    if (cached_has_bits & 0x00002000u) {
      imported_ = from.imported_;
    }
    if (cached_has_bits & 0x00004000u) {
      pin_cached_ = from.pin_cached_;
    }
    if (cached_has_bits & 0x00008000u) {
      passphrase_cached_ = from.passphrase_cached_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    set_firmware_present(from.firmware_present());
  }
}

void Features::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Features)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Features::CopyFrom(const Features& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Features)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Features::IsInitialized() const {
  return true;
}

void Features::Swap(Features* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Features::InternalSwap(Features* other) {
  coins_.InternalSwap(&other->coins_);
  vendor_.Swap(&other->vendor_);
  device_id_.Swap(&other->device_id_);
  language_.Swap(&other->language_);
  label_.Swap(&other->label_);
  revision_.Swap(&other->revision_);
  bootloader_hash_.Swap(&other->bootloader_hash_);
  std::swap(major_version_, other->major_version_);
  std::swap(minor_version_, other->minor_version_);
  std::swap(patch_version_, other->patch_version_);
  std::swap(bootloader_mode_, other->bootloader_mode_);
  std::swap(pin_protection_, other->pin_protection_);
  std::swap(passphrase_protection_, other->passphrase_protection_);
  std::swap(initialized_, other->initialized_);
  std::swap(imported_, other->imported_);
  std::swap(pin_cached_, other->pin_cached_);
  std::swap(passphrase_cached_, other->passphrase_cached_);
  std::swap(firmware_present_, other->firmware_present_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Features::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Features

// optional string vendor = 1;
bool Features::has_vendor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Features::set_has_vendor() {
  _has_bits_[0] |= 0x00000001u;
}
void Features::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000001u;
}
void Features::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vendor();
}
const ::std::string& Features::vendor() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.vendor)
  return vendor_.GetNoArena();
}
void Features::set_vendor(const ::std::string& value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.vendor)
}
#if LANG_CXX11
void Features::set_vendor(::std::string&& value) {
  set_has_vendor();
  vendor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.vendor)
}
#endif
void Features::set_vendor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.vendor)
}
void Features::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.vendor)
}
::std::string* Features::mutable_vendor() {
  set_has_vendor();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Features::release_vendor() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.vendor)
  clear_has_vendor();
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Features::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    set_has_vendor();
  } else {
    clear_has_vendor();
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.vendor)
}

// optional uint32 major_version = 2;
bool Features::has_major_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Features::set_has_major_version() {
  _has_bits_[0] |= 0x00000040u;
}
void Features::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000040u;
}
void Features::clear_major_version() {
  major_version_ = 0u;
  clear_has_major_version();
}
::google::protobuf::uint32 Features::major_version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.major_version)
  return major_version_;
}
void Features::set_major_version(::google::protobuf::uint32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.major_version)
}

// optional uint32 minor_version = 3;
bool Features::has_minor_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Features::set_has_minor_version() {
  _has_bits_[0] |= 0x00000080u;
}
void Features::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000080u;
}
void Features::clear_minor_version() {
  minor_version_ = 0u;
  clear_has_minor_version();
}
::google::protobuf::uint32 Features::minor_version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.minor_version)
  return minor_version_;
}
void Features::set_minor_version(::google::protobuf::uint32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.minor_version)
}

// optional uint32 patch_version = 4;
bool Features::has_patch_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Features::set_has_patch_version() {
  _has_bits_[0] |= 0x00000100u;
}
void Features::clear_has_patch_version() {
  _has_bits_[0] &= ~0x00000100u;
}
void Features::clear_patch_version() {
  patch_version_ = 0u;
  clear_has_patch_version();
}
::google::protobuf::uint32 Features::patch_version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.patch_version)
  return patch_version_;
}
void Features::set_patch_version(::google::protobuf::uint32 value) {
  set_has_patch_version();
  patch_version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.patch_version)
}

// optional bool bootloader_mode = 5;
bool Features::has_bootloader_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Features::set_has_bootloader_mode() {
  _has_bits_[0] |= 0x00000200u;
}
void Features::clear_has_bootloader_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
void Features::clear_bootloader_mode() {
  bootloader_mode_ = false;
  clear_has_bootloader_mode();
}
bool Features::bootloader_mode() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.bootloader_mode)
  return bootloader_mode_;
}
void Features::set_bootloader_mode(bool value) {
  set_has_bootloader_mode();
  bootloader_mode_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.bootloader_mode)
}

// optional string device_id = 6;
bool Features::has_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Features::set_has_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Features::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Features::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_id();
}
const ::std::string& Features::device_id() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.device_id)
  return device_id_.GetNoArena();
}
void Features::set_device_id(const ::std::string& value) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.device_id)
}
#if LANG_CXX11
void Features::set_device_id(::std::string&& value) {
  set_has_device_id();
  device_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.device_id)
}
#endif
void Features::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.device_id)
}
void Features::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.device_id)
}
::std::string* Features::mutable_device_id() {
  set_has_device_id();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.device_id)
  return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Features::release_device_id() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.device_id)
  clear_has_device_id();
  return device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Features::set_allocated_device_id(::std::string* device_id) {
  if (device_id != NULL) {
    set_has_device_id();
  } else {
    clear_has_device_id();
  }
  device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.device_id)
}

// optional bool pin_protection = 7;
bool Features::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Features::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000400u;
}
void Features::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000400u;
}
void Features::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
bool Features::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.pin_protection)
  return pin_protection_;
}
void Features::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.pin_protection)
}

// optional bool passphrase_protection = 8;
bool Features::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Features::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000800u;
}
void Features::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000800u;
}
void Features::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
bool Features::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.passphrase_protection)
  return passphrase_protection_;
}
void Features::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.passphrase_protection)
}

// optional string language = 9;
bool Features::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Features::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
void Features::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
void Features::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
const ::std::string& Features::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.language)
  return language_.GetNoArena();
}
void Features::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.language)
}
#if LANG_CXX11
void Features::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.language)
}
#endif
void Features::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.language)
}
void Features::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.language)
}
::std::string* Features::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Features::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Features::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.language)
}

// optional string label = 10;
bool Features::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Features::set_has_label() {
  _has_bits_[0] |= 0x00000008u;
}
void Features::clear_has_label() {
  _has_bits_[0] &= ~0x00000008u;
}
void Features::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
const ::std::string& Features::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.label)
  return label_.GetNoArena();
}
void Features::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.label)
}
#if LANG_CXX11
void Features::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.label)
}
#endif
void Features::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.label)
}
void Features::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.label)
}
::std::string* Features::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Features::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Features::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.label)
}

// repeated .TrezorProtobuf.CoinType coins = 11;
int Features::coins_size() const {
  return coins_.size();
}
void Features::clear_coins() {
  coins_.Clear();
}
const ::TrezorProtobuf::CoinType& Features::coins(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.coins)
  return coins_.Get(index);
}
::TrezorProtobuf::CoinType* Features::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.coins)
  return coins_.Mutable(index);
}
::TrezorProtobuf::CoinType* Features::add_coins() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.Features.coins)
  return coins_.Add();
}
::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::CoinType >*
Features::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.Features.coins)
  return &coins_;
}
const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::CoinType >&
Features::coins() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.Features.coins)
  return coins_;
}

// optional bool initialized = 12;
bool Features::has_initialized() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Features::set_has_initialized() {
  _has_bits_[0] |= 0x00001000u;
}
void Features::clear_has_initialized() {
  _has_bits_[0] &= ~0x00001000u;
}
void Features::clear_initialized() {
  initialized_ = false;
  clear_has_initialized();
}
bool Features::initialized() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.initialized)
  return initialized_;
}
void Features::set_initialized(bool value) {
  set_has_initialized();
  initialized_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.initialized)
}

// optional bytes revision = 13;
bool Features::has_revision() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Features::set_has_revision() {
  _has_bits_[0] |= 0x00000010u;
}
void Features::clear_has_revision() {
  _has_bits_[0] &= ~0x00000010u;
}
void Features::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_revision();
}
const ::std::string& Features::revision() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.revision)
  return revision_.GetNoArena();
}
void Features::set_revision(const ::std::string& value) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.revision)
}
#if LANG_CXX11
void Features::set_revision(::std::string&& value) {
  set_has_revision();
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.revision)
}
#endif
void Features::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.revision)
}
void Features::set_revision(const void* value, size_t size) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.revision)
}
::std::string* Features::mutable_revision() {
  set_has_revision();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Features::release_revision() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.revision)
  clear_has_revision();
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Features::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    set_has_revision();
  } else {
    clear_has_revision();
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.revision)
}

// optional bytes bootloader_hash = 14;
bool Features::has_bootloader_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Features::set_has_bootloader_hash() {
  _has_bits_[0] |= 0x00000020u;
}
void Features::clear_has_bootloader_hash() {
  _has_bits_[0] &= ~0x00000020u;
}
void Features::clear_bootloader_hash() {
  bootloader_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bootloader_hash();
}
const ::std::string& Features::bootloader_hash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.bootloader_hash)
  return bootloader_hash_.GetNoArena();
}
void Features::set_bootloader_hash(const ::std::string& value) {
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.bootloader_hash)
}
#if LANG_CXX11
void Features::set_bootloader_hash(::std::string&& value) {
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.bootloader_hash)
}
#endif
void Features::set_bootloader_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.bootloader_hash)
}
void Features::set_bootloader_hash(const void* value, size_t size) {
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.bootloader_hash)
}
::std::string* Features::mutable_bootloader_hash() {
  set_has_bootloader_hash();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.bootloader_hash)
  return bootloader_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Features::release_bootloader_hash() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.bootloader_hash)
  clear_has_bootloader_hash();
  return bootloader_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Features::set_allocated_bootloader_hash(::std::string* bootloader_hash) {
  if (bootloader_hash != NULL) {
    set_has_bootloader_hash();
  } else {
    clear_has_bootloader_hash();
  }
  bootloader_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bootloader_hash);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.bootloader_hash)
}

// optional bool imported = 15;
bool Features::has_imported() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Features::set_has_imported() {
  _has_bits_[0] |= 0x00002000u;
}
void Features::clear_has_imported() {
  _has_bits_[0] &= ~0x00002000u;
}
void Features::clear_imported() {
  imported_ = false;
  clear_has_imported();
}
bool Features::imported() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.imported)
  return imported_;
}
void Features::set_imported(bool value) {
  set_has_imported();
  imported_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.imported)
}

// optional bool pin_cached = 16;
bool Features::has_pin_cached() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void Features::set_has_pin_cached() {
  _has_bits_[0] |= 0x00004000u;
}
void Features::clear_has_pin_cached() {
  _has_bits_[0] &= ~0x00004000u;
}
void Features::clear_pin_cached() {
  pin_cached_ = false;
  clear_has_pin_cached();
}
bool Features::pin_cached() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.pin_cached)
  return pin_cached_;
}
void Features::set_pin_cached(bool value) {
  set_has_pin_cached();
  pin_cached_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.pin_cached)
}

// optional bool passphrase_cached = 17;
bool Features::has_passphrase_cached() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void Features::set_has_passphrase_cached() {
  _has_bits_[0] |= 0x00008000u;
}
void Features::clear_has_passphrase_cached() {
  _has_bits_[0] &= ~0x00008000u;
}
void Features::clear_passphrase_cached() {
  passphrase_cached_ = false;
  clear_has_passphrase_cached();
}
bool Features::passphrase_cached() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.passphrase_cached)
  return passphrase_cached_;
}
void Features::set_passphrase_cached(bool value) {
  set_has_passphrase_cached();
  passphrase_cached_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.passphrase_cached)
}

// optional bool firmware_present = 18;
bool Features::has_firmware_present() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void Features::set_has_firmware_present() {
  _has_bits_[0] |= 0x00010000u;
}
void Features::clear_has_firmware_present() {
  _has_bits_[0] &= ~0x00010000u;
}
void Features::clear_firmware_present() {
  firmware_present_ = false;
  clear_has_firmware_present();
}
bool Features::firmware_present() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.firmware_present)
  return firmware_present_;
}
void Features::set_firmware_present(bool value) {
  set_has_firmware_present();
  firmware_present_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.firmware_present)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClearSession::ClearSession()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.ClearSession)
}
ClearSession::ClearSession(const ClearSession& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.ClearSession)
}

void ClearSession::SharedCtor() {
  _cached_size_ = 0;
}

ClearSession::~ClearSession() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.ClearSession)
  SharedDtor();
}

void ClearSession::SharedDtor() {
}

void ClearSession::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClearSession::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ClearSession& ClearSession::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

ClearSession* ClearSession::New(::google::protobuf::Arena* arena) const {
  ClearSession* n = new ClearSession;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClearSession::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.ClearSession)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ClearSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.ClearSession)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.ClearSession)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.ClearSession)
  return false;
#undef DO_
}

void ClearSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.ClearSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.ClearSession)
}

::google::protobuf::uint8* ClearSession::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.ClearSession)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.ClearSession)
  return target;
}

size_t ClearSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.ClearSession)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClearSession::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.ClearSession)
  GOOGLE_DCHECK_NE(&from, this);
  const ClearSession* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ClearSession>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.ClearSession)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.ClearSession)
    MergeFrom(*source);
  }
}

void ClearSession::MergeFrom(const ClearSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.ClearSession)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ClearSession::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.ClearSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClearSession::CopyFrom(const ClearSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.ClearSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearSession::IsInitialized() const {
  return true;
}

void ClearSession::Swap(ClearSession* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClearSession::InternalSwap(ClearSession* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ClearSession::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClearSession

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApplySettings::kLanguageFieldNumber;
const int ApplySettings::kLabelFieldNumber;
const int ApplySettings::kUsePassphraseFieldNumber;
const int ApplySettings::kHomescreenFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApplySettings::ApplySettings()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.ApplySettings)
}
ApplySettings::ApplySettings(const ApplySettings& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_language()) {
    language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
  }
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_label()) {
    label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
  }
  homescreen_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_homescreen()) {
    homescreen_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.homescreen_);
  }
  use_passphrase_ = from.use_passphrase_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.ApplySettings)
}

void ApplySettings::SharedCtor() {
  _cached_size_ = 0;
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  homescreen_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  use_passphrase_ = false;
}

ApplySettings::~ApplySettings() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.ApplySettings)
  SharedDtor();
}

void ApplySettings::SharedDtor() {
  language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  label_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  homescreen_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ApplySettings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ApplySettings::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ApplySettings& ApplySettings::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

ApplySettings* ApplySettings::New(::google::protobuf::Arena* arena) const {
  ApplySettings* n = new ApplySettings;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ApplySettings::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.ApplySettings)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_language()) {
      GOOGLE_DCHECK(!language_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*language_.UnsafeRawStringPointer())->clear();
    }
    if (has_label()) {
      GOOGLE_DCHECK(!label_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*label_.UnsafeRawStringPointer())->clear();
    }
    if (has_homescreen()) {
      GOOGLE_DCHECK(!homescreen_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*homescreen_.UnsafeRawStringPointer())->clear();
    }
  }
  use_passphrase_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ApplySettings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.ApplySettings)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string language = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.ApplySettings.language");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string label = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.ApplySettings.label");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool use_passphrase = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_use_passphrase();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_passphrase_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes homescreen = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_homescreen()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.ApplySettings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.ApplySettings)
  return false;
#undef DO_
}

void ApplySettings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.ApplySettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ApplySettings.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->language(), output);
  }

  // optional string label = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ApplySettings.label");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->label(), output);
  }

  // optional bool use_passphrase = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->use_passphrase(), output);
  }

  // optional bytes homescreen = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->homescreen(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.ApplySettings)
}

::google::protobuf::uint8* ApplySettings::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.ApplySettings)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string language = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ApplySettings.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->language(), target);
  }

  // optional string label = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ApplySettings.label");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->label(), target);
  }

  // optional bool use_passphrase = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->use_passphrase(), target);
  }

  // optional bytes homescreen = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->homescreen(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.ApplySettings)
  return target;
}

size_t ApplySettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.ApplySettings)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional string language = 1;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 2;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional bytes homescreen = 4;
    if (has_homescreen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->homescreen());
    }

    // optional bool use_passphrase = 3;
    if (has_use_passphrase()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplySettings::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.ApplySettings)
  GOOGLE_DCHECK_NE(&from, this);
  const ApplySettings* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ApplySettings>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.ApplySettings)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.ApplySettings)
    MergeFrom(*source);
  }
}

void ApplySettings::MergeFrom(const ApplySettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.ApplySettings)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_language();
      language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_label();
      label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_homescreen();
      homescreen_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.homescreen_);
    }
    if (cached_has_bits & 0x00000008u) {
      use_passphrase_ = from.use_passphrase_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ApplySettings::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.ApplySettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplySettings::CopyFrom(const ApplySettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.ApplySettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplySettings::IsInitialized() const {
  return true;
}

void ApplySettings::Swap(ApplySettings* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApplySettings::InternalSwap(ApplySettings* other) {
  language_.Swap(&other->language_);
  label_.Swap(&other->label_);
  homescreen_.Swap(&other->homescreen_);
  std::swap(use_passphrase_, other->use_passphrase_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ApplySettings::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ApplySettings

// optional string language = 1;
bool ApplySettings::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ApplySettings::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
void ApplySettings::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
void ApplySettings::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
const ::std::string& ApplySettings::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.language)
  return language_.GetNoArena();
}
void ApplySettings::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.language)
}
#if LANG_CXX11
void ApplySettings::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ApplySettings.language)
}
#endif
void ApplySettings::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ApplySettings.language)
}
void ApplySettings::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ApplySettings.language)
}
::std::string* ApplySettings::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ApplySettings.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ApplySettings::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ApplySettings.language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ApplySettings::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ApplySettings.language)
}

// optional string label = 2;
bool ApplySettings::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ApplySettings::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
void ApplySettings::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
void ApplySettings::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
const ::std::string& ApplySettings::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.label)
  return label_.GetNoArena();
}
void ApplySettings::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.label)
}
#if LANG_CXX11
void ApplySettings::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ApplySettings.label)
}
#endif
void ApplySettings::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ApplySettings.label)
}
void ApplySettings::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ApplySettings.label)
}
::std::string* ApplySettings::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ApplySettings.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ApplySettings::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ApplySettings.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ApplySettings::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ApplySettings.label)
}

// optional bool use_passphrase = 3;
bool ApplySettings::has_use_passphrase() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ApplySettings::set_has_use_passphrase() {
  _has_bits_[0] |= 0x00000008u;
}
void ApplySettings::clear_has_use_passphrase() {
  _has_bits_[0] &= ~0x00000008u;
}
void ApplySettings::clear_use_passphrase() {
  use_passphrase_ = false;
  clear_has_use_passphrase();
}
bool ApplySettings::use_passphrase() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.use_passphrase)
  return use_passphrase_;
}
void ApplySettings::set_use_passphrase(bool value) {
  set_has_use_passphrase();
  use_passphrase_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.use_passphrase)
}

// optional bytes homescreen = 4;
bool ApplySettings::has_homescreen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ApplySettings::set_has_homescreen() {
  _has_bits_[0] |= 0x00000004u;
}
void ApplySettings::clear_has_homescreen() {
  _has_bits_[0] &= ~0x00000004u;
}
void ApplySettings::clear_homescreen() {
  homescreen_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_homescreen();
}
const ::std::string& ApplySettings::homescreen() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.homescreen)
  return homescreen_.GetNoArena();
}
void ApplySettings::set_homescreen(const ::std::string& value) {
  set_has_homescreen();
  homescreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.homescreen)
}
#if LANG_CXX11
void ApplySettings::set_homescreen(::std::string&& value) {
  set_has_homescreen();
  homescreen_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ApplySettings.homescreen)
}
#endif
void ApplySettings::set_homescreen(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_homescreen();
  homescreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ApplySettings.homescreen)
}
void ApplySettings::set_homescreen(const void* value, size_t size) {
  set_has_homescreen();
  homescreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ApplySettings.homescreen)
}
::std::string* ApplySettings::mutable_homescreen() {
  set_has_homescreen();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ApplySettings.homescreen)
  return homescreen_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ApplySettings::release_homescreen() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ApplySettings.homescreen)
  clear_has_homescreen();
  return homescreen_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ApplySettings::set_allocated_homescreen(::std::string* homescreen) {
  if (homescreen != NULL) {
    set_has_homescreen();
  } else {
    clear_has_homescreen();
  }
  homescreen_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), homescreen);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ApplySettings.homescreen)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChangePin::kRemoveFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChangePin::ChangePin()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.ChangePin)
}
ChangePin::ChangePin(const ChangePin& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  remove_ = from.remove_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.ChangePin)
}

void ChangePin::SharedCtor() {
  _cached_size_ = 0;
  remove_ = false;
}

ChangePin::~ChangePin() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.ChangePin)
  SharedDtor();
}

void ChangePin::SharedDtor() {
}

void ChangePin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChangePin::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ChangePin& ChangePin::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

ChangePin* ChangePin::New(::google::protobuf::Arena* arena) const {
  ChangePin* n = new ChangePin;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChangePin::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.ChangePin)
  remove_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ChangePin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.ChangePin)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool remove = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_remove();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &remove_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.ChangePin)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.ChangePin)
  return false;
#undef DO_
}

void ChangePin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.ChangePin)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool remove = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->remove(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.ChangePin)
}

::google::protobuf::uint8* ChangePin::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.ChangePin)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool remove = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->remove(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.ChangePin)
  return target;
}

size_t ChangePin::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.ChangePin)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional bool remove = 1;
  if (has_remove()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangePin::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.ChangePin)
  GOOGLE_DCHECK_NE(&from, this);
  const ChangePin* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ChangePin>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.ChangePin)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.ChangePin)
    MergeFrom(*source);
  }
}

void ChangePin::MergeFrom(const ChangePin& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.ChangePin)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_remove()) {
    set_remove(from.remove());
  }
}

void ChangePin::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.ChangePin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChangePin::CopyFrom(const ChangePin& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.ChangePin)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangePin::IsInitialized() const {
  return true;
}

void ChangePin::Swap(ChangePin* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChangePin::InternalSwap(ChangePin* other) {
  std::swap(remove_, other->remove_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ChangePin::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChangePin

// optional bool remove = 1;
bool ChangePin::has_remove() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ChangePin::set_has_remove() {
  _has_bits_[0] |= 0x00000001u;
}
void ChangePin::clear_has_remove() {
  _has_bits_[0] &= ~0x00000001u;
}
void ChangePin::clear_remove() {
  remove_ = false;
  clear_has_remove();
}
bool ChangePin::remove() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ChangePin.remove)
  return remove_;
}
void ChangePin::set_remove(bool value) {
  set_has_remove();
  remove_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ChangePin.remove)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Ping::kMessageFieldNumber;
const int Ping::kButtonProtectionFieldNumber;
const int Ping::kPinProtectionFieldNumber;
const int Ping::kPassphraseProtectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Ping::Ping()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Ping)
}
Ping::Ping(const Ping& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  ::memcpy(&button_protection_, &from.button_protection_,
    reinterpret_cast<char*>(&passphrase_protection_) -
    reinterpret_cast<char*>(&button_protection_) + sizeof(passphrase_protection_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Ping)
}

void Ping::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&button_protection_, 0, reinterpret_cast<char*>(&passphrase_protection_) -
    reinterpret_cast<char*>(&button_protection_) + sizeof(passphrase_protection_));
}

Ping::~Ping() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Ping)
  SharedDtor();
}

void Ping::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Ping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ping::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Ping& Ping::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Ping* Ping::New(::google::protobuf::Arena* arena) const {
  Ping* n = new Ping;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Ping::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Ping)
  if (has_message()) {
    GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*message_.UnsafeRawStringPointer())->clear();
  }
  if (_has_bits_[0 / 32] & 14u) {
    ::memset(&button_protection_, 0, reinterpret_cast<char*>(&passphrase_protection_) -
      reinterpret_cast<char*>(&button_protection_) + sizeof(passphrase_protection_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Ping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Ping)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Ping.message");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool button_protection = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_button_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &button_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool pin_protection = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_pin_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool passphrase_protection = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_passphrase_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Ping)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Ping)
  return false;
#undef DO_
}

void Ping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Ping)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Ping.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  // optional bool button_protection = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->button_protection(), output);
  }

  // optional bool pin_protection = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->pin_protection(), output);
  }

  // optional bool passphrase_protection = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->passphrase_protection(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Ping)
}

::google::protobuf::uint8* Ping::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Ping)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Ping.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  // optional bool button_protection = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->button_protection(), target);
  }

  // optional bool pin_protection = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->pin_protection(), target);
  }

  // optional bool passphrase_protection = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->passphrase_protection(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Ping)
  return target;
}

size_t Ping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Ping)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional bool button_protection = 2;
    if (has_button_protection()) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 3;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_protection = 4;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ping::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Ping)
  GOOGLE_DCHECK_NE(&from, this);
  const Ping* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Ping>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Ping)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Ping)
    MergeFrom(*source);
  }
}

void Ping::MergeFrom(const Ping& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Ping)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      button_protection_ = from.button_protection_;
    }
    if (cached_has_bits & 0x00000004u) {
      pin_protection_ = from.pin_protection_;
    }
    if (cached_has_bits & 0x00000008u) {
      passphrase_protection_ = from.passphrase_protection_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Ping::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Ping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ping::CopyFrom(const Ping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Ping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ping::IsInitialized() const {
  return true;
}

void Ping::Swap(Ping* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Ping::InternalSwap(Ping* other) {
  message_.Swap(&other->message_);
  std::swap(button_protection_, other->button_protection_);
  std::swap(pin_protection_, other->pin_protection_);
  std::swap(passphrase_protection_, other->passphrase_protection_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Ping::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Ping

// optional string message = 1;
bool Ping::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Ping::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void Ping::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void Ping::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& Ping::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.message)
  return message_.GetNoArena();
}
void Ping::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.message)
}
#if LANG_CXX11
void Ping::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Ping.message)
}
#endif
void Ping::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Ping.message)
}
void Ping::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Ping.message)
}
::std::string* Ping::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Ping.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Ping::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Ping.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Ping::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Ping.message)
}

// optional bool button_protection = 2;
bool Ping::has_button_protection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Ping::set_has_button_protection() {
  _has_bits_[0] |= 0x00000002u;
}
void Ping::clear_has_button_protection() {
  _has_bits_[0] &= ~0x00000002u;
}
void Ping::clear_button_protection() {
  button_protection_ = false;
  clear_has_button_protection();
}
bool Ping::button_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.button_protection)
  return button_protection_;
}
void Ping::set_button_protection(bool value) {
  set_has_button_protection();
  button_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.button_protection)
}

// optional bool pin_protection = 3;
bool Ping::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Ping::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000004u;
}
void Ping::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
void Ping::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
bool Ping::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.pin_protection)
  return pin_protection_;
}
void Ping::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.pin_protection)
}

// optional bool passphrase_protection = 4;
bool Ping::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Ping::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
void Ping::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
void Ping::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
bool Ping::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.passphrase_protection)
  return passphrase_protection_;
}
void Ping::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.passphrase_protection)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Success::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Success::Success()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Success)
}
Success::Success(const Success& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Success)
}

void Success::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Success::~Success() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Success)
  SharedDtor();
}

void Success::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Success::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Success::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Success& Success::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Success* Success::New(::google::protobuf::Arena* arena) const {
  Success* n = new Success;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Success::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Success)
  if (has_message()) {
    GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*message_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Success::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Success)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Success.message");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Success)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Success)
  return false;
#undef DO_
}

void Success::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Success)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Success.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->message(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Success)
}

::google::protobuf::uint8* Success::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Success)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Success.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Success)
  return target;
}

size_t Success::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Success)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional string message = 1;
  if (has_message()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->message());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Success::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Success)
  GOOGLE_DCHECK_NE(&from, this);
  const Success* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Success>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Success)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Success)
    MergeFrom(*source);
  }
}

void Success::MergeFrom(const Success& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Success)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_message()) {
    set_has_message();
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
}

void Success::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Success)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Success::CopyFrom(const Success& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Success)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Success::IsInitialized() const {
  return true;
}

void Success::Swap(Success* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Success::InternalSwap(Success* other) {
  message_.Swap(&other->message_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Success::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Success

// optional string message = 1;
bool Success::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Success::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void Success::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void Success::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& Success::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Success.message)
  return message_.GetNoArena();
}
void Success::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Success.message)
}
#if LANG_CXX11
void Success::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Success.message)
}
#endif
void Success::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Success.message)
}
void Success::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Success.message)
}
::std::string* Success::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Success.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Success::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Success.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Success::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Success.message)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Failure::kCodeFieldNumber;
const int Failure::kMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Failure::Failure()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Failure)
}
Failure::Failure(const Failure& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Failure)
}

void Failure::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  code_ = 1;
}

Failure::~Failure() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Failure)
  SharedDtor();
}

void Failure::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Failure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Failure::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Failure& Failure::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Failure* Failure::New(::google::protobuf::Arena* arena) const {
  Failure* n = new Failure;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Failure::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Failure)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_message()) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    code_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Failure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Failure)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.FailureType code = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TrezorProtobuf::FailureType_IsValid(value)) {
            set_code(static_cast< ::TrezorProtobuf::FailureType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Failure.message");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Failure)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Failure)
  return false;
#undef DO_
}

void Failure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Failure)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.FailureType code = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Failure.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->message(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Failure)
}

::google::protobuf::uint8* Failure::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Failure)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.FailureType code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->code(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Failure.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Failure)
  return target;
}

size_t Failure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Failure)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional .TrezorProtobuf.FailureType code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Failure::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Failure)
  GOOGLE_DCHECK_NE(&from, this);
  const Failure* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Failure>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Failure)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Failure)
    MergeFrom(*source);
  }
}

void Failure::MergeFrom(const Failure& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Failure)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Failure::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Failure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Failure::CopyFrom(const Failure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Failure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Failure::IsInitialized() const {
  return true;
}

void Failure::Swap(Failure* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Failure::InternalSwap(Failure* other) {
  message_.Swap(&other->message_);
  std::swap(code_, other->code_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Failure::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Failure

// optional .TrezorProtobuf.FailureType code = 1;
bool Failure::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Failure::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
void Failure::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
void Failure::clear_code() {
  code_ = 1;
  clear_has_code();
}
::TrezorProtobuf::FailureType Failure::code() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Failure.code)
  return static_cast< ::TrezorProtobuf::FailureType >(code_);
}
void Failure::set_code(::TrezorProtobuf::FailureType value) {
  assert(::TrezorProtobuf::FailureType_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Failure.code)
}

// optional string message = 2;
bool Failure::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Failure::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void Failure::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void Failure::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& Failure::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Failure.message)
  return message_.GetNoArena();
}
void Failure::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Failure.message)
}
#if LANG_CXX11
void Failure::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Failure.message)
}
#endif
void Failure::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Failure.message)
}
void Failure::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Failure.message)
}
::std::string* Failure::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Failure.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Failure::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Failure.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Failure::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Failure.message)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ButtonRequest::kCodeFieldNumber;
const int ButtonRequest::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ButtonRequest::ButtonRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.ButtonRequest)
}
ButtonRequest::ButtonRequest(const ButtonRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.ButtonRequest)
}

void ButtonRequest::SharedCtor() {
  _cached_size_ = 0;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  code_ = 1;
}

ButtonRequest::~ButtonRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.ButtonRequest)
  SharedDtor();
}

void ButtonRequest::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ButtonRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ButtonRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ButtonRequest& ButtonRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

ButtonRequest* ButtonRequest::New(::google::protobuf::Arena* arena) const {
  ButtonRequest* n = new ButtonRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ButtonRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.ButtonRequest)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_data()) {
      GOOGLE_DCHECK(!data_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*data_.UnsafeRawStringPointer())->clear();
    }
    code_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ButtonRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.ButtonRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.ButtonRequestType code = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TrezorProtobuf::ButtonRequestType_IsValid(value)) {
            set_code(static_cast< ::TrezorProtobuf::ButtonRequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string data = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->data().data(), this->data().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.ButtonRequest.data");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.ButtonRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.ButtonRequest)
  return false;
#undef DO_
}

void ButtonRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.ButtonRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.ButtonRequestType code = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string data = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->data().data(), this->data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ButtonRequest.data");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->data(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.ButtonRequest)
}

::google::protobuf::uint8* ButtonRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.ButtonRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.ButtonRequestType code = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->code(), target);
  }

  // optional string data = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->data().data(), this->data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ButtonRequest.data");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->data(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.ButtonRequest)
  return target;
}

size_t ButtonRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.ButtonRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data());
    }

    // optional .TrezorProtobuf.ButtonRequestType code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ButtonRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.ButtonRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const ButtonRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ButtonRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.ButtonRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.ButtonRequest)
    MergeFrom(*source);
  }
}

void ButtonRequest::MergeFrom(const ButtonRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.ButtonRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000002u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ButtonRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.ButtonRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ButtonRequest::CopyFrom(const ButtonRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.ButtonRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ButtonRequest::IsInitialized() const {
  return true;
}

void ButtonRequest::Swap(ButtonRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ButtonRequest::InternalSwap(ButtonRequest* other) {
  data_.Swap(&other->data_);
  std::swap(code_, other->code_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ButtonRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ButtonRequest

// optional .TrezorProtobuf.ButtonRequestType code = 1;
bool ButtonRequest::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ButtonRequest::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
void ButtonRequest::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
void ButtonRequest::clear_code() {
  code_ = 1;
  clear_has_code();
}
::TrezorProtobuf::ButtonRequestType ButtonRequest::code() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ButtonRequest.code)
  return static_cast< ::TrezorProtobuf::ButtonRequestType >(code_);
}
void ButtonRequest::set_code(::TrezorProtobuf::ButtonRequestType value) {
  assert(::TrezorProtobuf::ButtonRequestType_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ButtonRequest.code)
}

// optional string data = 2;
bool ButtonRequest::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ButtonRequest::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
void ButtonRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void ButtonRequest::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
const ::std::string& ButtonRequest::data() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ButtonRequest.data)
  return data_.GetNoArena();
}
void ButtonRequest::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ButtonRequest.data)
}
#if LANG_CXX11
void ButtonRequest::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ButtonRequest.data)
}
#endif
void ButtonRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ButtonRequest.data)
}
void ButtonRequest::set_data(const char* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ButtonRequest.data)
}
::std::string* ButtonRequest::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ButtonRequest.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ButtonRequest::release_data() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ButtonRequest.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ButtonRequest::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ButtonRequest.data)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ButtonAck::ButtonAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.ButtonAck)
}
ButtonAck::ButtonAck(const ButtonAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.ButtonAck)
}

void ButtonAck::SharedCtor() {
  _cached_size_ = 0;
}

ButtonAck::~ButtonAck() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.ButtonAck)
  SharedDtor();
}

void ButtonAck::SharedDtor() {
}

void ButtonAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ButtonAck::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ButtonAck& ButtonAck::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

ButtonAck* ButtonAck::New(::google::protobuf::Arena* arena) const {
  ButtonAck* n = new ButtonAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ButtonAck::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.ButtonAck)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ButtonAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.ButtonAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.ButtonAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.ButtonAck)
  return false;
#undef DO_
}

void ButtonAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.ButtonAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.ButtonAck)
}

::google::protobuf::uint8* ButtonAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.ButtonAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.ButtonAck)
  return target;
}

size_t ButtonAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.ButtonAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ButtonAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.ButtonAck)
  GOOGLE_DCHECK_NE(&from, this);
  const ButtonAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ButtonAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.ButtonAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.ButtonAck)
    MergeFrom(*source);
  }
}

void ButtonAck::MergeFrom(const ButtonAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.ButtonAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void ButtonAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.ButtonAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ButtonAck::CopyFrom(const ButtonAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.ButtonAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ButtonAck::IsInitialized() const {
  return true;
}

void ButtonAck::Swap(ButtonAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ButtonAck::InternalSwap(ButtonAck* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ButtonAck::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ButtonAck

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PinMatrixRequest::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PinMatrixRequest::PinMatrixRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.PinMatrixRequest)
}
PinMatrixRequest::PinMatrixRequest(const PinMatrixRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.PinMatrixRequest)
}

void PinMatrixRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
}

PinMatrixRequest::~PinMatrixRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.PinMatrixRequest)
  SharedDtor();
}

void PinMatrixRequest::SharedDtor() {
}

void PinMatrixRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PinMatrixRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PinMatrixRequest& PinMatrixRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

PinMatrixRequest* PinMatrixRequest::New(::google::protobuf::Arena* arena) const {
  PinMatrixRequest* n = new PinMatrixRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PinMatrixRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.PinMatrixRequest)
  type_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PinMatrixRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.PinMatrixRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.PinMatrixRequestType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TrezorProtobuf::PinMatrixRequestType_IsValid(value)) {
            set_type(static_cast< ::TrezorProtobuf::PinMatrixRequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.PinMatrixRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.PinMatrixRequest)
  return false;
#undef DO_
}

void PinMatrixRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.PinMatrixRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.PinMatrixRequestType type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.PinMatrixRequest)
}

::google::protobuf::uint8* PinMatrixRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.PinMatrixRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.PinMatrixRequestType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.PinMatrixRequest)
  return target;
}

size_t PinMatrixRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.PinMatrixRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional .TrezorProtobuf.PinMatrixRequestType type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PinMatrixRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.PinMatrixRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const PinMatrixRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PinMatrixRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.PinMatrixRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.PinMatrixRequest)
    MergeFrom(*source);
  }
}

void PinMatrixRequest::MergeFrom(const PinMatrixRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.PinMatrixRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_type()) {
    set_type(from.type());
  }
}

void PinMatrixRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.PinMatrixRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PinMatrixRequest::CopyFrom(const PinMatrixRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.PinMatrixRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinMatrixRequest::IsInitialized() const {
  return true;
}

void PinMatrixRequest::Swap(PinMatrixRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PinMatrixRequest::InternalSwap(PinMatrixRequest* other) {
  std::swap(type_, other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PinMatrixRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PinMatrixRequest

// optional .TrezorProtobuf.PinMatrixRequestType type = 1;
bool PinMatrixRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PinMatrixRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void PinMatrixRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void PinMatrixRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
::TrezorProtobuf::PinMatrixRequestType PinMatrixRequest::type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PinMatrixRequest.type)
  return static_cast< ::TrezorProtobuf::PinMatrixRequestType >(type_);
}
void PinMatrixRequest::set_type(::TrezorProtobuf::PinMatrixRequestType value) {
  assert(::TrezorProtobuf::PinMatrixRequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PinMatrixRequest.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PinMatrixAck::kPinFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PinMatrixAck::PinMatrixAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.PinMatrixAck)
}
PinMatrixAck::PinMatrixAck(const PinMatrixAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pin()) {
    pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.PinMatrixAck)
}

void PinMatrixAck::SharedCtor() {
  _cached_size_ = 0;
  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

PinMatrixAck::~PinMatrixAck() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.PinMatrixAck)
  SharedDtor();
}

void PinMatrixAck::SharedDtor() {
  pin_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void PinMatrixAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PinMatrixAck::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PinMatrixAck& PinMatrixAck::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

PinMatrixAck* PinMatrixAck::New(::google::protobuf::Arena* arena) const {
  PinMatrixAck* n = new PinMatrixAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PinMatrixAck::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.PinMatrixAck)
  if (has_pin()) {
    GOOGLE_DCHECK(!pin_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*pin_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PinMatrixAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.PinMatrixAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string pin = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pin().data(), this->pin().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.PinMatrixAck.pin");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.PinMatrixAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.PinMatrixAck)
  return false;
#undef DO_
}

void PinMatrixAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.PinMatrixAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string pin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.PinMatrixAck.pin");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->pin(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.PinMatrixAck)
}

::google::protobuf::uint8* PinMatrixAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.PinMatrixAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string pin = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.PinMatrixAck.pin");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->pin(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.PinMatrixAck)
  return target;
}

size_t PinMatrixAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.PinMatrixAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string pin = 1;
  if (has_pin()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->pin());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PinMatrixAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.PinMatrixAck)
  GOOGLE_DCHECK_NE(&from, this);
  const PinMatrixAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PinMatrixAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.PinMatrixAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.PinMatrixAck)
    MergeFrom(*source);
  }
}

void PinMatrixAck::MergeFrom(const PinMatrixAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.PinMatrixAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_pin()) {
    set_has_pin();
    pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
  }
}

void PinMatrixAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.PinMatrixAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PinMatrixAck::CopyFrom(const PinMatrixAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.PinMatrixAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinMatrixAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void PinMatrixAck::Swap(PinMatrixAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PinMatrixAck::InternalSwap(PinMatrixAck* other) {
  pin_.Swap(&other->pin_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PinMatrixAck::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PinMatrixAck

// required string pin = 1;
bool PinMatrixAck::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PinMatrixAck::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
void PinMatrixAck::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
void PinMatrixAck::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
const ::std::string& PinMatrixAck::pin() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PinMatrixAck.pin)
  return pin_.GetNoArena();
}
void PinMatrixAck::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PinMatrixAck.pin)
}
#if LANG_CXX11
void PinMatrixAck::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.PinMatrixAck.pin)
}
#endif
void PinMatrixAck::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.PinMatrixAck.pin)
}
void PinMatrixAck::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.PinMatrixAck.pin)
}
::std::string* PinMatrixAck::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PinMatrixAck.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* PinMatrixAck::release_pin() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PinMatrixAck.pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void PinMatrixAck::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PinMatrixAck.pin)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Cancel::Cancel()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Cancel)
}
Cancel::Cancel(const Cancel& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Cancel)
}

void Cancel::SharedCtor() {
  _cached_size_ = 0;
}

Cancel::~Cancel() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Cancel)
  SharedDtor();
}

void Cancel::SharedDtor() {
}

void Cancel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Cancel::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Cancel& Cancel::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Cancel* Cancel::New(::google::protobuf::Arena* arena) const {
  Cancel* n = new Cancel;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Cancel::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Cancel)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Cancel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Cancel)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Cancel)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Cancel)
  return false;
#undef DO_
}

void Cancel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Cancel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Cancel)
}

::google::protobuf::uint8* Cancel::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Cancel)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Cancel)
  return target;
}

size_t Cancel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Cancel)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Cancel::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Cancel)
  GOOGLE_DCHECK_NE(&from, this);
  const Cancel* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Cancel>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Cancel)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Cancel)
    MergeFrom(*source);
  }
}

void Cancel::MergeFrom(const Cancel& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Cancel)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void Cancel::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Cancel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cancel::CopyFrom(const Cancel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Cancel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cancel::IsInitialized() const {
  return true;
}

void Cancel::Swap(Cancel* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Cancel::InternalSwap(Cancel* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Cancel::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Cancel

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PassphraseRequest::PassphraseRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.PassphraseRequest)
}
PassphraseRequest::PassphraseRequest(const PassphraseRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.PassphraseRequest)
}

void PassphraseRequest::SharedCtor() {
  _cached_size_ = 0;
}

PassphraseRequest::~PassphraseRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.PassphraseRequest)
  SharedDtor();
}

void PassphraseRequest::SharedDtor() {
}

void PassphraseRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PassphraseRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PassphraseRequest& PassphraseRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

PassphraseRequest* PassphraseRequest::New(::google::protobuf::Arena* arena) const {
  PassphraseRequest* n = new PassphraseRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PassphraseRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.PassphraseRequest)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PassphraseRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.PassphraseRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.PassphraseRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.PassphraseRequest)
  return false;
#undef DO_
}

void PassphraseRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.PassphraseRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.PassphraseRequest)
}

::google::protobuf::uint8* PassphraseRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.PassphraseRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.PassphraseRequest)
  return target;
}

size_t PassphraseRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.PassphraseRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PassphraseRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.PassphraseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const PassphraseRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PassphraseRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.PassphraseRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.PassphraseRequest)
    MergeFrom(*source);
  }
}

void PassphraseRequest::MergeFrom(const PassphraseRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.PassphraseRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void PassphraseRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.PassphraseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PassphraseRequest::CopyFrom(const PassphraseRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.PassphraseRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassphraseRequest::IsInitialized() const {
  return true;
}

void PassphraseRequest::Swap(PassphraseRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PassphraseRequest::InternalSwap(PassphraseRequest* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PassphraseRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PassphraseRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PassphraseAck::kPassphraseFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PassphraseAck::PassphraseAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.PassphraseAck)
}
PassphraseAck::PassphraseAck(const PassphraseAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  passphrase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_passphrase()) {
    passphrase_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.passphrase_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.PassphraseAck)
}

void PassphraseAck::SharedCtor() {
  _cached_size_ = 0;
  passphrase_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

PassphraseAck::~PassphraseAck() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.PassphraseAck)
  SharedDtor();
}

void PassphraseAck::SharedDtor() {
  passphrase_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void PassphraseAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PassphraseAck::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PassphraseAck& PassphraseAck::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

PassphraseAck* PassphraseAck::New(::google::protobuf::Arena* arena) const {
  PassphraseAck* n = new PassphraseAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PassphraseAck::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.PassphraseAck)
  if (has_passphrase()) {
    GOOGLE_DCHECK(!passphrase_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*passphrase_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PassphraseAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.PassphraseAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string passphrase = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_passphrase()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->passphrase().data(), this->passphrase().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.PassphraseAck.passphrase");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.PassphraseAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.PassphraseAck)
  return false;
#undef DO_
}

void PassphraseAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.PassphraseAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string passphrase = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->passphrase().data(), this->passphrase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.PassphraseAck.passphrase");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->passphrase(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.PassphraseAck)
}

::google::protobuf::uint8* PassphraseAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.PassphraseAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string passphrase = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->passphrase().data(), this->passphrase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.PassphraseAck.passphrase");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->passphrase(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.PassphraseAck)
  return target;
}

size_t PassphraseAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.PassphraseAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string passphrase = 1;
  if (has_passphrase()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->passphrase());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PassphraseAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.PassphraseAck)
  GOOGLE_DCHECK_NE(&from, this);
  const PassphraseAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PassphraseAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.PassphraseAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.PassphraseAck)
    MergeFrom(*source);
  }
}

void PassphraseAck::MergeFrom(const PassphraseAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.PassphraseAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_passphrase()) {
    set_has_passphrase();
    passphrase_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.passphrase_);
  }
}

void PassphraseAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.PassphraseAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PassphraseAck::CopyFrom(const PassphraseAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.PassphraseAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassphraseAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void PassphraseAck::Swap(PassphraseAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PassphraseAck::InternalSwap(PassphraseAck* other) {
  passphrase_.Swap(&other->passphrase_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PassphraseAck::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PassphraseAck

// required string passphrase = 1;
bool PassphraseAck::has_passphrase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PassphraseAck::set_has_passphrase() {
  _has_bits_[0] |= 0x00000001u;
}
void PassphraseAck::clear_has_passphrase() {
  _has_bits_[0] &= ~0x00000001u;
}
void PassphraseAck::clear_passphrase() {
  passphrase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_passphrase();
}
const ::std::string& PassphraseAck::passphrase() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PassphraseAck.passphrase)
  return passphrase_.GetNoArena();
}
void PassphraseAck::set_passphrase(const ::std::string& value) {
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PassphraseAck.passphrase)
}
#if LANG_CXX11
void PassphraseAck::set_passphrase(::std::string&& value) {
  set_has_passphrase();
  passphrase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.PassphraseAck.passphrase)
}
#endif
void PassphraseAck::set_passphrase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.PassphraseAck.passphrase)
}
void PassphraseAck::set_passphrase(const char* value, size_t size) {
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.PassphraseAck.passphrase)
}
::std::string* PassphraseAck::mutable_passphrase() {
  set_has_passphrase();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PassphraseAck.passphrase)
  return passphrase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* PassphraseAck::release_passphrase() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PassphraseAck.passphrase)
  clear_has_passphrase();
  return passphrase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void PassphraseAck::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase != NULL) {
    set_has_passphrase();
  } else {
    clear_has_passphrase();
  }
  passphrase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passphrase);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PassphraseAck.passphrase)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetEntropy::kSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetEntropy::GetEntropy()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.GetEntropy)
}
GetEntropy::GetEntropy(const GetEntropy& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.GetEntropy)
}

void GetEntropy::SharedCtor() {
  _cached_size_ = 0;
  size_ = 0u;
}

GetEntropy::~GetEntropy() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.GetEntropy)
  SharedDtor();
}

void GetEntropy::SharedDtor() {
}

void GetEntropy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetEntropy::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetEntropy& GetEntropy::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetEntropy* GetEntropy::New(::google::protobuf::Arena* arena) const {
  GetEntropy* n = new GetEntropy;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetEntropy::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.GetEntropy)
  size_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool GetEntropy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.GetEntropy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 size = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.GetEntropy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.GetEntropy)
  return false;
#undef DO_
}

void GetEntropy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.GetEntropy)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 size = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.GetEntropy)
}

::google::protobuf::uint8* GetEntropy::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.GetEntropy)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->size(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.GetEntropy)
  return target;
}

size_t GetEntropy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.GetEntropy)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required uint32 size = 1;
  if (has_size()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->size());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetEntropy::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.GetEntropy)
  GOOGLE_DCHECK_NE(&from, this);
  const GetEntropy* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetEntropy>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.GetEntropy)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.GetEntropy)
    MergeFrom(*source);
  }
}

void GetEntropy::MergeFrom(const GetEntropy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.GetEntropy)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_size()) {
    set_size(from.size());
  }
}

void GetEntropy::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.GetEntropy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetEntropy::CopyFrom(const GetEntropy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.GetEntropy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetEntropy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void GetEntropy::Swap(GetEntropy* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetEntropy::InternalSwap(GetEntropy* other) {
  std::swap(size_, other->size_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetEntropy::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetEntropy

// required uint32 size = 1;
bool GetEntropy::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetEntropy::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
void GetEntropy::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetEntropy::clear_size() {
  size_ = 0u;
  clear_has_size();
}
::google::protobuf::uint32 GetEntropy::size() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetEntropy.size)
  return size_;
}
void GetEntropy::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetEntropy.size)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Entropy::kEntropyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Entropy::Entropy()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Entropy)
}
Entropy::Entropy(const Entropy& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  entropy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_entropy()) {
    entropy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entropy_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Entropy)
}

void Entropy::SharedCtor() {
  _cached_size_ = 0;
  entropy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Entropy::~Entropy() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Entropy)
  SharedDtor();
}

void Entropy::SharedDtor() {
  entropy_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Entropy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entropy::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Entropy& Entropy::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Entropy* Entropy::New(::google::protobuf::Arena* arena) const {
  Entropy* n = new Entropy;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Entropy::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Entropy)
  if (has_entropy()) {
    GOOGLE_DCHECK(!entropy_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*entropy_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Entropy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Entropy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes entropy = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_entropy()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Entropy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Entropy)
  return false;
#undef DO_
}

void Entropy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Entropy)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes entropy = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->entropy(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Entropy)
}

::google::protobuf::uint8* Entropy::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Entropy)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes entropy = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->entropy(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Entropy)
  return target;
}

size_t Entropy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Entropy)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required bytes entropy = 1;
  if (has_entropy()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->entropy());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entropy::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Entropy)
  GOOGLE_DCHECK_NE(&from, this);
  const Entropy* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Entropy>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Entropy)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Entropy)
    MergeFrom(*source);
  }
}

void Entropy::MergeFrom(const Entropy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Entropy)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_entropy()) {
    set_has_entropy();
    entropy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entropy_);
  }
}

void Entropy::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Entropy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entropy::CopyFrom(const Entropy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Entropy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entropy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Entropy::Swap(Entropy* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Entropy::InternalSwap(Entropy* other) {
  entropy_.Swap(&other->entropy_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Entropy::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Entropy

// required bytes entropy = 1;
bool Entropy::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Entropy::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
void Entropy::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
void Entropy::clear_entropy() {
  entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entropy();
}
const ::std::string& Entropy::entropy() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Entropy.entropy)
  return entropy_.GetNoArena();
}
void Entropy::set_entropy(const ::std::string& value) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Entropy.entropy)
}
#if LANG_CXX11
void Entropy::set_entropy(::std::string&& value) {
  set_has_entropy();
  entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Entropy.entropy)
}
#endif
void Entropy::set_entropy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Entropy.entropy)
}
void Entropy::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Entropy.entropy)
}
::std::string* Entropy::mutable_entropy() {
  set_has_entropy();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Entropy.entropy)
  return entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Entropy::release_entropy() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Entropy.entropy)
  clear_has_entropy();
  return entropy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Entropy::set_allocated_entropy(::std::string* entropy) {
  if (entropy != NULL) {
    set_has_entropy();
  } else {
    clear_has_entropy();
  }
  entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entropy);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Entropy.entropy)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> GetPublicKey::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetPublicKey::kAddressNFieldNumber;
const int GetPublicKey::kEcdsaCurveNameFieldNumber;
const int GetPublicKey::kShowDisplayFieldNumber;
const int GetPublicKey::kCoinNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetPublicKey::GetPublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.GetPublicKey)
}
GetPublicKey::GetPublicKey(const GetPublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ecdsa_curve_name()) {
    ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
  }
  coin_name_.UnsafeSetDefault(&GetPublicKey::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&GetPublicKey::_default_coin_name_.get(), from.coin_name_);
  }
  show_display_ = from.show_display_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.GetPublicKey)
}

void GetPublicKey::SharedCtor() {
  _cached_size_ = 0;
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.UnsafeSetDefault(&GetPublicKey::_default_coin_name_.get());
  show_display_ = false;
}

GetPublicKey::~GetPublicKey() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.GetPublicKey)
  SharedDtor();
}

void GetPublicKey::SharedDtor() {
  ecdsa_curve_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.DestroyNoArena(&GetPublicKey::_default_coin_name_.get());
}

void GetPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPublicKey::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetPublicKey& GetPublicKey::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetPublicKey* GetPublicKey::New(::google::protobuf::Arena* arena) const {
  GetPublicKey* n = new GetPublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.GetPublicKey)
  address_n_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    if (has_ecdsa_curve_name()) {
      GOOGLE_DCHECK(!ecdsa_curve_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*ecdsa_curve_name_.UnsafeRawStringPointer())->clear();
    }
    if (has_coin_name()) {
      GOOGLE_DCHECK(!coin_name_.IsDefault(&GetPublicKey::_default_coin_name_.get()));
      (*coin_name_.UnsafeRawStringPointer())->assign(*&GetPublicKey::_default_coin_name_.get());
    }
  }
  show_display_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool GetPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.GetPublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string ecdsa_curve_name = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ecdsa_curve_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.GetPublicKey.ecdsa_curve_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_show_display();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.GetPublicKey.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.GetPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.GetPublicKey)
  return false;
#undef DO_
}

void GetPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.GetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string ecdsa_curve_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetPublicKey.ecdsa_curve_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ecdsa_curve_name(), output);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetPublicKey.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->coin_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.GetPublicKey)
}

::google::protobuf::uint8* GetPublicKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.GetPublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional string ecdsa_curve_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetPublicKey.ecdsa_curve_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ecdsa_curve_name(), target);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetPublicKey.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.GetPublicKey)
  return target;
}

size_t GetPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.GetPublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional string ecdsa_curve_name = 2;
    if (has_ecdsa_curve_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ecdsa_curve_name());
    }

    // optional string coin_name = 4 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional bool show_display = 3;
    if (has_show_display()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.GetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const GetPublicKey* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetPublicKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.GetPublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.GetPublicKey)
    MergeFrom(*source);
  }
}

void GetPublicKey::MergeFrom(const GetPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.GetPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ecdsa_curve_name();
      ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&GetPublicKey::_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      show_display_ = from.show_display_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GetPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.GetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPublicKey::CopyFrom(const GetPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.GetPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPublicKey::IsInitialized() const {
  return true;
}

void GetPublicKey::Swap(GetPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetPublicKey::InternalSwap(GetPublicKey* other) {
  address_n_.InternalSwap(&other->address_n_);
  ecdsa_curve_name_.Swap(&other->ecdsa_curve_name_);
  coin_name_.Swap(&other->coin_name_);
  std::swap(show_display_, other->show_display_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetPublicKey::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetPublicKey

// repeated uint32 address_n = 1;
int GetPublicKey::address_n_size() const {
  return address_n_.size();
}
void GetPublicKey::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 GetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.address_n)
  return address_n_.Get(index);
}
void GetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.address_n)
}
void GetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.GetPublicKey.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.GetPublicKey.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.GetPublicKey.address_n)
  return &address_n_;
}

// optional string ecdsa_curve_name = 2;
bool GetPublicKey::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetPublicKey::set_has_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetPublicKey::clear_has_ecdsa_curve_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetPublicKey::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecdsa_curve_name();
}
const ::std::string& GetPublicKey::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
void GetPublicKey::set_ecdsa_curve_name(const ::std::string& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
#if LANG_CXX11
void GetPublicKey::set_ecdsa_curve_name(::std::string&& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
#endif
void GetPublicKey::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
void GetPublicKey::set_ecdsa_curve_name(const char* value, size_t size) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
::std::string* GetPublicKey::mutable_ecdsa_curve_name() {
  set_has_ecdsa_curve_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* GetPublicKey::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
  clear_has_ecdsa_curve_name();
  return ecdsa_curve_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void GetPublicKey::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != NULL) {
    set_has_ecdsa_curve_name();
  } else {
    clear_has_ecdsa_curve_name();
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}

// optional bool show_display = 3;
bool GetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GetPublicKey::set_has_show_display() {
  _has_bits_[0] |= 0x00000004u;
}
void GetPublicKey::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000004u;
}
void GetPublicKey::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
bool GetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.show_display)
  return show_display_;
}
void GetPublicKey::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.show_display)
}

// optional string coin_name = 4 [default = "Bitcoin"];
bool GetPublicKey::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetPublicKey::set_has_coin_name() {
  _has_bits_[0] |= 0x00000002u;
}
void GetPublicKey::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetPublicKey::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&GetPublicKey::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& GetPublicKey::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.coin_name)
  return coin_name_.GetNoArena();
}
void GetPublicKey::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetPublicKey::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.coin_name)
}
#if LANG_CXX11
void GetPublicKey::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &GetPublicKey::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetPublicKey.coin_name)
}
#endif
void GetPublicKey::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&GetPublicKey::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetPublicKey.coin_name)
}
void GetPublicKey::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetPublicKey::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetPublicKey.coin_name)
}
::std::string* GetPublicKey::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetPublicKey.coin_name)
  return coin_name_.MutableNoArena(&GetPublicKey::_default_coin_name_.get());
}
::std::string* GetPublicKey::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetPublicKey.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&GetPublicKey::_default_coin_name_.get());
}
void GetPublicKey::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&GetPublicKey::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetPublicKey.coin_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PublicKey::kNodeFieldNumber;
const int PublicKey::kXpubFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PublicKey::PublicKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.PublicKey)
}
PublicKey::PublicKey(const PublicKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_xpub()) {
    xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
  }
  if (from.has_node()) {
    node_ = new ::TrezorProtobuf::HDNodeType(*from.node_);
  } else {
    node_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.PublicKey)
}

void PublicKey::SharedCtor() {
  _cached_size_ = 0;
  xpub_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  node_ = NULL;
}

PublicKey::~PublicKey() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.PublicKey)
  SharedDtor();
}

void PublicKey::SharedDtor() {
  xpub_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete node_;
  }
}

void PublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PublicKey::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const PublicKey& PublicKey::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

PublicKey* PublicKey::New(::google::protobuf::Arena* arena) const {
  PublicKey* n = new PublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.PublicKey)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_xpub()) {
      GOOGLE_DCHECK(!xpub_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*xpub_.UnsafeRawStringPointer())->clear();
    }
    if (has_node()) {
      GOOGLE_DCHECK(node_ != NULL);
      node_->::TrezorProtobuf::HDNodeType::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.PublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .TrezorProtobuf.HDNodeType node = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string xpub = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_xpub()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->xpub().data(), this->xpub().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.PublicKey.xpub");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.PublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.PublicKey)
  return false;
#undef DO_
}

void PublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.PublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .TrezorProtobuf.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->node_, output);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), this->xpub().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.PublicKey.xpub");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->xpub(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.PublicKey)
}

::google::protobuf::uint8* PublicKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.PublicKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .TrezorProtobuf.HDNodeType node = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->node_, deterministic, target);
  }

  // optional string xpub = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->xpub().data(), this->xpub().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.PublicKey.xpub");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->xpub(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.PublicKey)
  return target;
}

size_t PublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.PublicKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required .TrezorProtobuf.HDNodeType node = 1;
  if (has_node()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->node_);
  }
  // optional string xpub = 2;
  if (has_xpub()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->xpub());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PublicKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.PublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const PublicKey* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const PublicKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.PublicKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.PublicKey)
    MergeFrom(*source);
  }
}

void PublicKey::MergeFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.PublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_xpub();
      xpub_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.xpub_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_node()->::TrezorProtobuf::HDNodeType::MergeFrom(from.node());
    }
  }
}

void PublicKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PublicKey::CopyFrom(const PublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void PublicKey::Swap(PublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PublicKey::InternalSwap(PublicKey* other) {
  xpub_.Swap(&other->xpub_);
  std::swap(node_, other->node_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PublicKey::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PublicKey

// required .TrezorProtobuf.HDNodeType node = 1;
bool PublicKey::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PublicKey::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
void PublicKey::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
void PublicKey::clear_node() {
  if (node_ != NULL) node_->::TrezorProtobuf::HDNodeType::Clear();
  clear_has_node();
}
const ::TrezorProtobuf::HDNodeType& PublicKey::node() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PublicKey.node)
  return node_ != NULL ? *node_
                         : *::TrezorProtobuf::HDNodeType::internal_default_instance();
}
::TrezorProtobuf::HDNodeType* PublicKey::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    node_ = new ::TrezorProtobuf::HDNodeType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PublicKey.node)
  return node_;
}
::TrezorProtobuf::HDNodeType* PublicKey::release_node() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PublicKey.node)
  clear_has_node();
  ::TrezorProtobuf::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
void PublicKey::set_allocated_node(::TrezorProtobuf::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PublicKey.node)
}

// optional string xpub = 2;
bool PublicKey::has_xpub() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PublicKey::set_has_xpub() {
  _has_bits_[0] |= 0x00000001u;
}
void PublicKey::clear_has_xpub() {
  _has_bits_[0] &= ~0x00000001u;
}
void PublicKey::clear_xpub() {
  xpub_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xpub();
}
const ::std::string& PublicKey::xpub() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PublicKey.xpub)
  return xpub_.GetNoArena();
}
void PublicKey::set_xpub(const ::std::string& value) {
  set_has_xpub();
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PublicKey.xpub)
}
#if LANG_CXX11
void PublicKey::set_xpub(::std::string&& value) {
  set_has_xpub();
  xpub_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.PublicKey.xpub)
}
#endif
void PublicKey::set_xpub(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xpub();
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.PublicKey.xpub)
}
void PublicKey::set_xpub(const char* value, size_t size) {
  set_has_xpub();
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.PublicKey.xpub)
}
::std::string* PublicKey::mutable_xpub() {
  set_has_xpub();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PublicKey.xpub)
  return xpub_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* PublicKey::release_xpub() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PublicKey.xpub)
  clear_has_xpub();
  return xpub_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void PublicKey::set_allocated_xpub(::std::string* xpub) {
  if (xpub != NULL) {
    set_has_xpub();
  } else {
    clear_has_xpub();
  }
  xpub_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xpub);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PublicKey.xpub)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> GetAddress::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAddress::kAddressNFieldNumber;
const int GetAddress::kCoinNameFieldNumber;
const int GetAddress::kShowDisplayFieldNumber;
const int GetAddress::kMultisigFieldNumber;
const int GetAddress::kScriptTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAddress::GetAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.GetAddress)
}
GetAddress::GetAddress(const GetAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  coin_name_.UnsafeSetDefault(&GetAddress::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&GetAddress::_default_coin_name_.get(), from.coin_name_);
  }
  if (from.has_multisig()) {
    multisig_ = new ::TrezorProtobuf::MultisigRedeemScriptType(*from.multisig_);
  } else {
    multisig_ = NULL;
  }
  ::memcpy(&show_display_, &from.show_display_,
    reinterpret_cast<char*>(&script_type_) -
    reinterpret_cast<char*>(&show_display_) + sizeof(script_type_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.GetAddress)
}

void GetAddress::SharedCtor() {
  _cached_size_ = 0;
  coin_name_.UnsafeSetDefault(&GetAddress::_default_coin_name_.get());
  ::memset(&multisig_, 0, reinterpret_cast<char*>(&script_type_) -
    reinterpret_cast<char*>(&multisig_) + sizeof(script_type_));
}

GetAddress::~GetAddress() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.GetAddress)
  SharedDtor();
}

void GetAddress::SharedDtor() {
  coin_name_.DestroyNoArena(&GetAddress::_default_coin_name_.get());
  if (this != internal_default_instance()) {
    delete multisig_;
  }
}

void GetAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetAddress::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetAddress& GetAddress::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetAddress* GetAddress::New(::google::protobuf::Arena* arena) const {
  GetAddress* n = new GetAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.GetAddress)
  address_n_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    if (has_coin_name()) {
      GOOGLE_DCHECK(!coin_name_.IsDefault(&GetAddress::_default_coin_name_.get()));
      (*coin_name_.UnsafeRawStringPointer())->assign(*&GetAddress::_default_coin_name_.get());
    }
    if (has_multisig()) {
      GOOGLE_DCHECK(multisig_ != NULL);
      multisig_->::TrezorProtobuf::MultisigRedeemScriptType::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 12u) {
    ::memset(&show_display_, 0, reinterpret_cast<char*>(&script_type_) -
      reinterpret_cast<char*>(&show_display_) + sizeof(script_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool GetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.GetAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 2 [default = "Bitcoin"];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.GetAddress.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_show_display();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multisig()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .TrezorProtobuf.InputScriptType script_type = 5 [default = SPENDADDRESS];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TrezorProtobuf::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::TrezorProtobuf::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.GetAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.GetAddress)
  return false;
#undef DO_
}

void GetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.GetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string coin_name = 2 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetAddress.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->coin_name(), output);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  // optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->multisig_, output);
  }

  // optional .TrezorProtobuf.InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->script_type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.GetAddress)
}

::google::protobuf::uint8* GetAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.GetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional string coin_name = 2 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetAddress.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->coin_name(), target);
  }

  // optional bool show_display = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  // optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->multisig_, deterministic, target);
  }

  // optional .TrezorProtobuf.InputScriptType script_type = 5 [default = SPENDADDRESS];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->script_type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.GetAddress)
  return target;
}

size_t GetAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.GetAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 15u) {
    // optional string coin_name = 2 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 4;
    if (has_multisig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->multisig_);
    }

    // optional bool show_display = 3;
    if (has_show_display()) {
      total_size += 1 + 1;
    }

    // optional .TrezorProtobuf.InputScriptType script_type = 5 [default = SPENDADDRESS];
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.GetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const GetAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.GetAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.GetAddress)
    MergeFrom(*source);
  }
}

void GetAddress::MergeFrom(const GetAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.GetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&GetAddress::_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_multisig()->::TrezorProtobuf::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (cached_has_bits & 0x00000004u) {
      show_display_ = from.show_display_;
    }
    if (cached_has_bits & 0x00000008u) {
      script_type_ = from.script_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GetAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.GetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAddress::CopyFrom(const GetAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.GetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAddress::IsInitialized() const {
  if (has_multisig()) {
    if (!this->multisig_->IsInitialized()) return false;
  }
  return true;
}

void GetAddress::Swap(GetAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAddress::InternalSwap(GetAddress* other) {
  address_n_.InternalSwap(&other->address_n_);
  coin_name_.Swap(&other->coin_name_);
  std::swap(multisig_, other->multisig_);
  std::swap(show_display_, other->show_display_);
  std::swap(script_type_, other->script_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetAddress::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetAddress

// repeated uint32 address_n = 1;
int GetAddress::address_n_size() const {
  return address_n_.size();
}
void GetAddress::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 GetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.address_n)
  return address_n_.Get(index);
}
void GetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.address_n)
}
void GetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.GetAddress.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.GetAddress.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.GetAddress.address_n)
  return &address_n_;
}

// optional string coin_name = 2 [default = "Bitcoin"];
bool GetAddress::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetAddress::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
void GetAddress::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetAddress::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&GetAddress::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& GetAddress::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.coin_name)
  return coin_name_.GetNoArena();
}
void GetAddress::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetAddress::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.coin_name)
}
#if LANG_CXX11
void GetAddress::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &GetAddress::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetAddress.coin_name)
}
#endif
void GetAddress::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&GetAddress::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetAddress.coin_name)
}
void GetAddress::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetAddress::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetAddress.coin_name)
}
::std::string* GetAddress::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetAddress.coin_name)
  return coin_name_.MutableNoArena(&GetAddress::_default_coin_name_.get());
}
::std::string* GetAddress::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetAddress.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&GetAddress::_default_coin_name_.get());
}
void GetAddress::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&GetAddress::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetAddress.coin_name)
}

// optional bool show_display = 3;
bool GetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000004u;
}
void GetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000004u;
}
void GetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
bool GetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.show_display)
  return show_display_;
}
void GetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.show_display)
}

// optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 4;
bool GetAddress::has_multisig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetAddress::set_has_multisig() {
  _has_bits_[0] |= 0x00000002u;
}
void GetAddress::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetAddress::clear_multisig() {
  if (multisig_ != NULL) multisig_->::TrezorProtobuf::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
const ::TrezorProtobuf::MultisigRedeemScriptType& GetAddress::multisig() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.multisig)
  return multisig_ != NULL ? *multisig_
                         : *::TrezorProtobuf::MultisigRedeemScriptType::internal_default_instance();
}
::TrezorProtobuf::MultisigRedeemScriptType* GetAddress::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) {
    multisig_ = new ::TrezorProtobuf::MultisigRedeemScriptType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetAddress.multisig)
  return multisig_;
}
::TrezorProtobuf::MultisigRedeemScriptType* GetAddress::release_multisig() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetAddress.multisig)
  clear_has_multisig();
  ::TrezorProtobuf::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
void GetAddress::set_allocated_multisig(::TrezorProtobuf::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetAddress.multisig)
}

// optional .TrezorProtobuf.InputScriptType script_type = 5 [default = SPENDADDRESS];
bool GetAddress::has_script_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void GetAddress::set_has_script_type() {
  _has_bits_[0] |= 0x00000008u;
}
void GetAddress::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void GetAddress::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
::TrezorProtobuf::InputScriptType GetAddress::script_type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.script_type)
  return static_cast< ::TrezorProtobuf::InputScriptType >(script_type_);
}
void GetAddress::set_script_type(::TrezorProtobuf::InputScriptType value) {
  assert(::TrezorProtobuf::InputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.script_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumGetAddress::kAddressNFieldNumber;
const int EthereumGetAddress::kShowDisplayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumGetAddress::EthereumGetAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EthereumGetAddress)
}
EthereumGetAddress::EthereumGetAddress(const EthereumGetAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  show_display_ = from.show_display_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EthereumGetAddress)
}

void EthereumGetAddress::SharedCtor() {
  _cached_size_ = 0;
  show_display_ = false;
}

EthereumGetAddress::~EthereumGetAddress() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EthereumGetAddress)
  SharedDtor();
}

void EthereumGetAddress::SharedDtor() {
}

void EthereumGetAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EthereumGetAddress::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumGetAddress& EthereumGetAddress::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EthereumGetAddress* EthereumGetAddress::New(::google::protobuf::Arena* arena) const {
  EthereumGetAddress* n = new EthereumGetAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EthereumGetAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EthereumGetAddress)
  address_n_.Clear();
  show_display_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumGetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EthereumGetAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool show_display = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_show_display();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EthereumGetAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EthereumGetAddress)
  return false;
#undef DO_
}

void EthereumGetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->show_display(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EthereumGetAddress)
}

::google::protobuf::uint8* EthereumGetAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EthereumGetAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bool show_display = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->show_display(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EthereumGetAddress)
  return target;
}

size_t EthereumGetAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EthereumGetAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional bool show_display = 2;
  if (has_show_display()) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthereumGetAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EthereumGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumGetAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumGetAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EthereumGetAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EthereumGetAddress)
    MergeFrom(*source);
  }
}

void EthereumGetAddress::MergeFrom(const EthereumGetAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EthereumGetAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  if (from.has_show_display()) {
    set_show_display(from.show_display());
  }
}

void EthereumGetAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EthereumGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumGetAddress::CopyFrom(const EthereumGetAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EthereumGetAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumGetAddress::IsInitialized() const {
  return true;
}

void EthereumGetAddress::Swap(EthereumGetAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumGetAddress::InternalSwap(EthereumGetAddress* other) {
  address_n_.InternalSwap(&other->address_n_);
  std::swap(show_display_, other->show_display_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EthereumGetAddress::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EthereumGetAddress

// repeated uint32 address_n = 1;
int EthereumGetAddress::address_n_size() const {
  return address_n_.size();
}
void EthereumGetAddress::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 EthereumGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumGetAddress.address_n)
  return address_n_.Get(index);
}
void EthereumGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumGetAddress.address_n)
}
void EthereumGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.EthereumGetAddress.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.EthereumGetAddress.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.EthereumGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
bool EthereumGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EthereumGetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000001u;
}
void EthereumGetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000001u;
}
void EthereumGetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
bool EthereumGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumGetAddress.show_display)
  return show_display_;
}
void EthereumGetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumGetAddress.show_display)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Address::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Address::Address()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.Address)
}
Address::Address(const Address& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.Address)
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Address::~Address() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.Address)
  SharedDtor();
}

void Address::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Address& Address::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

Address* Address::New(::google::protobuf::Arena* arena) const {
  Address* n = new Address;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Address::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.Address)
  if (has_address()) {
    GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*address_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.Address)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.Address.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.Address)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.Address)
  return false;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Address.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.Address)
}

::google::protobuf::uint8* Address::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.Address)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.Address.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.Address)
  return target;
}

size_t Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.Address)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string address = 1;
  if (has_address()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.Address)
  GOOGLE_DCHECK_NE(&from, this);
  const Address* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Address>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.Address)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.Address)
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.Address)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_address()) {
    set_has_address();
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void Address::Swap(Address* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Address::InternalSwap(Address* other) {
  address_.Swap(&other->address_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Address

// required string address = 1;
bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Address::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void Address::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void Address::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string& Address::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Address.address)
  return address_.GetNoArena();
}
void Address::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Address.address)
}
#if LANG_CXX11
void Address::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Address.address)
}
#endif
void Address::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Address.address)
}
void Address::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Address.address)
}
::std::string* Address::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Address.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Address::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Address.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Address::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Address.address)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumAddress::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumAddress::EthereumAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EthereumAddress)
}
EthereumAddress::EthereumAddress(const EthereumAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EthereumAddress)
}

void EthereumAddress::SharedCtor() {
  _cached_size_ = 0;
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumAddress::~EthereumAddress() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EthereumAddress)
  SharedDtor();
}

void EthereumAddress::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EthereumAddress::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumAddress& EthereumAddress::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EthereumAddress* EthereumAddress::New(::google::protobuf::Arena* arena) const {
  EthereumAddress* n = new EthereumAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EthereumAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EthereumAddress)
  if (has_address()) {
    GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*address_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EthereumAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EthereumAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EthereumAddress)
  return false;
#undef DO_
}

void EthereumAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EthereumAddress)
}

::google::protobuf::uint8* EthereumAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EthereumAddress)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes address = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EthereumAddress)
  return target;
}

size_t EthereumAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EthereumAddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required bytes address = 1;
  if (has_address()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->address());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthereumAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EthereumAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EthereumAddress)
    MergeFrom(*source);
  }
}

void EthereumAddress::MergeFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EthereumAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_address()) {
    set_has_address();
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
}

void EthereumAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumAddress::CopyFrom(const EthereumAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EthereumAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumAddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void EthereumAddress::Swap(EthereumAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumAddress::InternalSwap(EthereumAddress* other) {
  address_.Swap(&other->address_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EthereumAddress::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EthereumAddress

// required bytes address = 1;
bool EthereumAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EthereumAddress::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void EthereumAddress::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void EthereumAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string& EthereumAddress::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumAddress.address)
  return address_.GetNoArena();
}
void EthereumAddress::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumAddress.address)
}
#if LANG_CXX11
void EthereumAddress::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumAddress.address)
}
#endif
void EthereumAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumAddress.address)
}
void EthereumAddress::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumAddress.address)
}
::std::string* EthereumAddress::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumAddress::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumAddress.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumAddress.address)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WipeDevice::WipeDevice()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.WipeDevice)
}
WipeDevice::WipeDevice(const WipeDevice& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.WipeDevice)
}

void WipeDevice::SharedCtor() {
  _cached_size_ = 0;
}

WipeDevice::~WipeDevice() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.WipeDevice)
  SharedDtor();
}

void WipeDevice::SharedDtor() {
}

void WipeDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WipeDevice::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const WipeDevice& WipeDevice::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

WipeDevice* WipeDevice::New(::google::protobuf::Arena* arena) const {
  WipeDevice* n = new WipeDevice;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WipeDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.WipeDevice)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool WipeDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.WipeDevice)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.WipeDevice)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.WipeDevice)
  return false;
#undef DO_
}

void WipeDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.WipeDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.WipeDevice)
}

::google::protobuf::uint8* WipeDevice::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.WipeDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.WipeDevice)
  return target;
}

size_t WipeDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.WipeDevice)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WipeDevice::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.WipeDevice)
  GOOGLE_DCHECK_NE(&from, this);
  const WipeDevice* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const WipeDevice>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.WipeDevice)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.WipeDevice)
    MergeFrom(*source);
  }
}

void WipeDevice::MergeFrom(const WipeDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.WipeDevice)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void WipeDevice::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.WipeDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WipeDevice::CopyFrom(const WipeDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.WipeDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WipeDevice::IsInitialized() const {
  return true;
}

void WipeDevice::Swap(WipeDevice* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WipeDevice::InternalSwap(WipeDevice* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WipeDevice::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WipeDevice

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> LoadDevice::_default_language_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LoadDevice::kMnemonicFieldNumber;
const int LoadDevice::kNodeFieldNumber;
const int LoadDevice::kPinFieldNumber;
const int LoadDevice::kPassphraseProtectionFieldNumber;
const int LoadDevice::kLanguageFieldNumber;
const int LoadDevice::kLabelFieldNumber;
const int LoadDevice::kSkipChecksumFieldNumber;
const int LoadDevice::kU2FCounterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LoadDevice::LoadDevice()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.LoadDevice)
}
LoadDevice::LoadDevice(const LoadDevice& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  mnemonic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_mnemonic()) {
    mnemonic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mnemonic_);
  }
  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pin()) {
    pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
  }
  language_.UnsafeSetDefault(&LoadDevice::_default_language_.get());
  if (from.has_language()) {
    language_.AssignWithDefault(&LoadDevice::_default_language_.get(), from.language_);
  }
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_label()) {
    label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
  }
  if (from.has_node()) {
    node_ = new ::TrezorProtobuf::HDNodeType(*from.node_);
  } else {
    node_ = NULL;
  }
  ::memcpy(&passphrase_protection_, &from.passphrase_protection_,
    reinterpret_cast<char*>(&u2f_counter_) -
    reinterpret_cast<char*>(&passphrase_protection_) + sizeof(u2f_counter_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.LoadDevice)
}

void LoadDevice::SharedCtor() {
  _cached_size_ = 0;
  mnemonic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  language_.UnsafeSetDefault(&LoadDevice::_default_language_.get());
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&node_, 0, reinterpret_cast<char*>(&u2f_counter_) -
    reinterpret_cast<char*>(&node_) + sizeof(u2f_counter_));
}

LoadDevice::~LoadDevice() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.LoadDevice)
  SharedDtor();
}

void LoadDevice::SharedDtor() {
  mnemonic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pin_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  language_.DestroyNoArena(&LoadDevice::_default_language_.get());
  label_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete node_;
  }
}

void LoadDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoadDevice::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const LoadDevice& LoadDevice::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

LoadDevice* LoadDevice::New(::google::protobuf::Arena* arena) const {
  LoadDevice* n = new LoadDevice;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LoadDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.LoadDevice)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_mnemonic()) {
      GOOGLE_DCHECK(!mnemonic_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*mnemonic_.UnsafeRawStringPointer())->clear();
    }
    if (has_pin()) {
      GOOGLE_DCHECK(!pin_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*pin_.UnsafeRawStringPointer())->clear();
    }
    if (has_language()) {
      GOOGLE_DCHECK(!language_.IsDefault(&LoadDevice::_default_language_.get()));
      (*language_.UnsafeRawStringPointer())->assign(*&LoadDevice::_default_language_.get());
    }
    if (has_label()) {
      GOOGLE_DCHECK(!label_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*label_.UnsafeRawStringPointer())->clear();
    }
    if (has_node()) {
      GOOGLE_DCHECK(node_ != NULL);
      node_->::TrezorProtobuf::HDNodeType::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 224u) {
    ::memset(&passphrase_protection_, 0, reinterpret_cast<char*>(&u2f_counter_) -
      reinterpret_cast<char*>(&passphrase_protection_) + sizeof(u2f_counter_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool LoadDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.LoadDevice)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string mnemonic = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mnemonic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mnemonic().data(), this->mnemonic().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.LoadDevice.mnemonic");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .TrezorProtobuf.HDNodeType node = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string pin = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pin().data(), this->pin().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.LoadDevice.pin");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool passphrase_protection = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_passphrase_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 5 [default = "english"];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.LoadDevice.language");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string label = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.LoadDevice.label");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool skip_checksum = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u)) {
          set_has_skip_checksum();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &skip_checksum_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 u2f_counter = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u)) {
          set_has_u2f_counter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u2f_counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.LoadDevice)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.LoadDevice)
  return false;
#undef DO_
}

void LoadDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.LoadDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string mnemonic = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.mnemonic");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->mnemonic(), output);
  }

  // optional .TrezorProtobuf.HDNodeType node = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->node_, output);
  }

  // optional string pin = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.pin");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->pin(), output);
  }

  // optional bool passphrase_protection = 4;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->passphrase_protection(), output);
  }

  // optional string language = 5 [default = "english"];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->language(), output);
  }

  // optional string label = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.label");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->label(), output);
  }

  // optional bool skip_checksum = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->skip_checksum(), output);
  }

  // optional uint32 u2f_counter = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->u2f_counter(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.LoadDevice)
}

::google::protobuf::uint8* LoadDevice::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.LoadDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string mnemonic = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.mnemonic");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mnemonic(), target);
  }

  // optional .TrezorProtobuf.HDNodeType node = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->node_, deterministic, target);
  }

  // optional string pin = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.pin");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->pin(), target);
  }

  // optional bool passphrase_protection = 4;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->passphrase_protection(), target);
  }

  // optional string language = 5 [default = "english"];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->language(), target);
  }

  // optional string label = 6;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.LoadDevice.label");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->label(), target);
  }

  // optional bool skip_checksum = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->skip_checksum(), target);
  }

  // optional uint32 u2f_counter = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->u2f_counter(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.LoadDevice)
  return target;
}

size_t LoadDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.LoadDevice)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional string mnemonic = 1;
    if (has_mnemonic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mnemonic());
    }

    // optional string pin = 3;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pin());
    }

    // optional string language = 5 [default = "english"];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 6;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional .TrezorProtobuf.HDNodeType node = 2;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->node_);
    }

    // optional bool passphrase_protection = 4;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional bool skip_checksum = 7;
    if (has_skip_checksum()) {
      total_size += 1 + 1;
    }

    // optional uint32 u2f_counter = 8;
    if (has_u2f_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->u2f_counter());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadDevice::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.LoadDevice)
  GOOGLE_DCHECK_NE(&from, this);
  const LoadDevice* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const LoadDevice>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.LoadDevice)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.LoadDevice)
    MergeFrom(*source);
  }
}

void LoadDevice::MergeFrom(const LoadDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.LoadDevice)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_mnemonic();
      mnemonic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mnemonic_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_pin();
      pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_language();
      language_.AssignWithDefault(&LoadDevice::_default_language_.get(), from.language_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_label();
      label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_node()->::TrezorProtobuf::HDNodeType::MergeFrom(from.node());
    }
    if (cached_has_bits & 0x00000020u) {
      passphrase_protection_ = from.passphrase_protection_;
    }
    if (cached_has_bits & 0x00000040u) {
      skip_checksum_ = from.skip_checksum_;
    }
    if (cached_has_bits & 0x00000080u) {
      u2f_counter_ = from.u2f_counter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LoadDevice::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.LoadDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoadDevice::CopyFrom(const LoadDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.LoadDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadDevice::IsInitialized() const {
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void LoadDevice::Swap(LoadDevice* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LoadDevice::InternalSwap(LoadDevice* other) {
  mnemonic_.Swap(&other->mnemonic_);
  pin_.Swap(&other->pin_);
  language_.Swap(&other->language_);
  label_.Swap(&other->label_);
  std::swap(node_, other->node_);
  std::swap(passphrase_protection_, other->passphrase_protection_);
  std::swap(skip_checksum_, other->skip_checksum_);
  std::swap(u2f_counter_, other->u2f_counter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LoadDevice::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LoadDevice

// optional string mnemonic = 1;
bool LoadDevice::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LoadDevice::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000001u;
}
void LoadDevice::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000001u;
}
void LoadDevice::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mnemonic();
}
const ::std::string& LoadDevice::mnemonic() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.mnemonic)
  return mnemonic_.GetNoArena();
}
void LoadDevice::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.mnemonic)
}
#if LANG_CXX11
void LoadDevice::set_mnemonic(::std::string&& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.mnemonic)
}
#endif
void LoadDevice::set_mnemonic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.mnemonic)
}
void LoadDevice::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.mnemonic)
}
::std::string* LoadDevice::mutable_mnemonic() {
  set_has_mnemonic();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* LoadDevice::release_mnemonic() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.mnemonic)
  clear_has_mnemonic();
  return mnemonic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void LoadDevice::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    set_has_mnemonic();
  } else {
    clear_has_mnemonic();
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.mnemonic)
}

// optional .TrezorProtobuf.HDNodeType node = 2;
bool LoadDevice::has_node() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LoadDevice::set_has_node() {
  _has_bits_[0] |= 0x00000010u;
}
void LoadDevice::clear_has_node() {
  _has_bits_[0] &= ~0x00000010u;
}
void LoadDevice::clear_node() {
  if (node_ != NULL) node_->::TrezorProtobuf::HDNodeType::Clear();
  clear_has_node();
}
const ::TrezorProtobuf::HDNodeType& LoadDevice::node() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.node)
  return node_ != NULL ? *node_
                         : *::TrezorProtobuf::HDNodeType::internal_default_instance();
}
::TrezorProtobuf::HDNodeType* LoadDevice::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    node_ = new ::TrezorProtobuf::HDNodeType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.node)
  return node_;
}
::TrezorProtobuf::HDNodeType* LoadDevice::release_node() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.node)
  clear_has_node();
  ::TrezorProtobuf::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
void LoadDevice::set_allocated_node(::TrezorProtobuf::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.node)
}

// optional string pin = 3;
bool LoadDevice::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LoadDevice::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
void LoadDevice::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
void LoadDevice::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
const ::std::string& LoadDevice::pin() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.pin)
  return pin_.GetNoArena();
}
void LoadDevice::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.pin)
}
#if LANG_CXX11
void LoadDevice::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.pin)
}
#endif
void LoadDevice::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.pin)
}
void LoadDevice::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.pin)
}
::std::string* LoadDevice::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* LoadDevice::release_pin() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void LoadDevice::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.pin)
}

// optional bool passphrase_protection = 4;
bool LoadDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void LoadDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000020u;
}
void LoadDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000020u;
}
void LoadDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
bool LoadDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.passphrase_protection)
  return passphrase_protection_;
}
void LoadDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.passphrase_protection)
}

// optional string language = 5 [default = "english"];
bool LoadDevice::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LoadDevice::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
void LoadDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
void LoadDevice::clear_language() {
  language_.ClearToDefaultNoArena(&LoadDevice::_default_language_.get());
  clear_has_language();
}
const ::std::string& LoadDevice::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.language)
  return language_.GetNoArena();
}
void LoadDevice::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&LoadDevice::_default_language_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.language)
}
#if LANG_CXX11
void LoadDevice::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &LoadDevice::_default_language_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.language)
}
#endif
void LoadDevice::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&LoadDevice::_default_language_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.language)
}
void LoadDevice::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&LoadDevice::_default_language_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.language)
}
::std::string* LoadDevice::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.language)
  return language_.MutableNoArena(&LoadDevice::_default_language_.get());
}
::std::string* LoadDevice::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.language)
  clear_has_language();
  return language_.ReleaseNoArena(&LoadDevice::_default_language_.get());
}
void LoadDevice::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&LoadDevice::_default_language_.get(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.language)
}

// optional string label = 6;
bool LoadDevice::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LoadDevice::set_has_label() {
  _has_bits_[0] |= 0x00000008u;
}
void LoadDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000008u;
}
void LoadDevice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
const ::std::string& LoadDevice::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.label)
  return label_.GetNoArena();
}
void LoadDevice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.label)
}
#if LANG_CXX11
void LoadDevice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.label)
}
#endif
void LoadDevice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.label)
}
void LoadDevice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.label)
}
::std::string* LoadDevice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* LoadDevice::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void LoadDevice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.label)
}

// optional bool skip_checksum = 7;
bool LoadDevice::has_skip_checksum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void LoadDevice::set_has_skip_checksum() {
  _has_bits_[0] |= 0x00000040u;
}
void LoadDevice::clear_has_skip_checksum() {
  _has_bits_[0] &= ~0x00000040u;
}
void LoadDevice::clear_skip_checksum() {
  skip_checksum_ = false;
  clear_has_skip_checksum();
}
bool LoadDevice::skip_checksum() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.skip_checksum)
  return skip_checksum_;
}
void LoadDevice::set_skip_checksum(bool value) {
  set_has_skip_checksum();
  skip_checksum_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.skip_checksum)
}

// optional uint32 u2f_counter = 8;
bool LoadDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void LoadDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000080u;
}
void LoadDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000080u;
}
void LoadDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
::google::protobuf::uint32 LoadDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.u2f_counter)
  return u2f_counter_;
}
void LoadDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.u2f_counter)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> ResetDevice::_default_language_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResetDevice::kDisplayRandomFieldNumber;
const int ResetDevice::kStrengthFieldNumber;
const int ResetDevice::kPassphraseProtectionFieldNumber;
const int ResetDevice::kPinProtectionFieldNumber;
const int ResetDevice::kLanguageFieldNumber;
const int ResetDevice::kLabelFieldNumber;
const int ResetDevice::kU2FCounterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResetDevice::ResetDevice()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.ResetDevice)
}
ResetDevice::ResetDevice(const ResetDevice& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  language_.UnsafeSetDefault(&ResetDevice::_default_language_.get());
  if (from.has_language()) {
    language_.AssignWithDefault(&ResetDevice::_default_language_.get(), from.language_);
  }
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_label()) {
    label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
  }
  ::memcpy(&display_random_, &from.display_random_,
    reinterpret_cast<char*>(&strength_) -
    reinterpret_cast<char*>(&display_random_) + sizeof(strength_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.ResetDevice)
}

void ResetDevice::SharedCtor() {
  _cached_size_ = 0;
  language_.UnsafeSetDefault(&ResetDevice::_default_language_.get());
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&display_random_, 0, reinterpret_cast<char*>(&u2f_counter_) -
    reinterpret_cast<char*>(&display_random_) + sizeof(u2f_counter_));
  strength_ = 256u;
}

ResetDevice::~ResetDevice() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.ResetDevice)
  SharedDtor();
}

void ResetDevice::SharedDtor() {
  language_.DestroyNoArena(&ResetDevice::_default_language_.get());
  label_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ResetDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResetDevice::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ResetDevice& ResetDevice::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

ResetDevice* ResetDevice::New(::google::protobuf::Arena* arena) const {
  ResetDevice* n = new ResetDevice;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResetDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.ResetDevice)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_language()) {
      GOOGLE_DCHECK(!language_.IsDefault(&ResetDevice::_default_language_.get()));
      (*language_.UnsafeRawStringPointer())->assign(*&ResetDevice::_default_language_.get());
    }
    if (has_label()) {
      GOOGLE_DCHECK(!label_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*label_.UnsafeRawStringPointer())->clear();
    }
  }
  if (_has_bits_[0 / 32] & 124u) {
    ::memset(&display_random_, 0, reinterpret_cast<char*>(&u2f_counter_) -
      reinterpret_cast<char*>(&display_random_) + sizeof(u2f_counter_));
    strength_ = 256u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ResetDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.ResetDevice)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool display_random = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_display_random();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &display_random_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 strength = 2 [default = 256];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_strength();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &strength_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool passphrase_protection = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_passphrase_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool pin_protection = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_pin_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 5 [default = "english"];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.ResetDevice.language");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string label = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.ResetDevice.label");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 u2f_counter = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u)) {
          set_has_u2f_counter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u2f_counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.ResetDevice)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.ResetDevice)
  return false;
#undef DO_
}

void ResetDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.ResetDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool display_random = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->display_random(), output);
  }

  // optional uint32 strength = 2 [default = 256];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->strength(), output);
  }

  // optional bool passphrase_protection = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->passphrase_protection(), output);
  }

  // optional bool pin_protection = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->pin_protection(), output);
  }

  // optional string language = 5 [default = "english"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ResetDevice.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->language(), output);
  }

  // optional string label = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ResetDevice.label");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->label(), output);
  }

  // optional uint32 u2f_counter = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->u2f_counter(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.ResetDevice)
}

::google::protobuf::uint8* ResetDevice::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.ResetDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool display_random = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->display_random(), target);
  }

  // optional uint32 strength = 2 [default = 256];
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->strength(), target);
  }

  // optional bool passphrase_protection = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->passphrase_protection(), target);
  }

  // optional bool pin_protection = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->pin_protection(), target);
  }

  // optional string language = 5 [default = "english"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ResetDevice.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->language(), target);
  }

  // optional string label = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.ResetDevice.label");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->label(), target);
  }

  // optional uint32 u2f_counter = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->u2f_counter(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.ResetDevice)
  return target;
}

size_t ResetDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.ResetDevice)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 127u) {
    // optional string language = 5 [default = "english"];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 6;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional bool display_random = 1;
    if (has_display_random()) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_protection = 3;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 4;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional uint32 u2f_counter = 7;
    if (has_u2f_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->u2f_counter());
    }

    // optional uint32 strength = 2 [default = 256];
    if (has_strength()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->strength());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetDevice::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.ResetDevice)
  GOOGLE_DCHECK_NE(&from, this);
  const ResetDevice* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ResetDevice>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.ResetDevice)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.ResetDevice)
    MergeFrom(*source);
  }
}

void ResetDevice::MergeFrom(const ResetDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.ResetDevice)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_language();
      language_.AssignWithDefault(&ResetDevice::_default_language_.get(), from.language_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_label();
      label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
    }
    if (cached_has_bits & 0x00000004u) {
      display_random_ = from.display_random_;
    }
    if (cached_has_bits & 0x00000008u) {
      passphrase_protection_ = from.passphrase_protection_;
    }
    if (cached_has_bits & 0x00000010u) {
      pin_protection_ = from.pin_protection_;
    }
    if (cached_has_bits & 0x00000020u) {
      u2f_counter_ = from.u2f_counter_;
    }
    if (cached_has_bits & 0x00000040u) {
      strength_ = from.strength_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ResetDevice::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.ResetDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetDevice::CopyFrom(const ResetDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.ResetDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetDevice::IsInitialized() const {
  return true;
}

void ResetDevice::Swap(ResetDevice* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResetDevice::InternalSwap(ResetDevice* other) {
  language_.Swap(&other->language_);
  label_.Swap(&other->label_);
  std::swap(display_random_, other->display_random_);
  std::swap(passphrase_protection_, other->passphrase_protection_);
  std::swap(pin_protection_, other->pin_protection_);
  std::swap(u2f_counter_, other->u2f_counter_);
  std::swap(strength_, other->strength_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResetDevice::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResetDevice

// optional bool display_random = 1;
bool ResetDevice::has_display_random() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResetDevice::set_has_display_random() {
  _has_bits_[0] |= 0x00000004u;
}
void ResetDevice::clear_has_display_random() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResetDevice::clear_display_random() {
  display_random_ = false;
  clear_has_display_random();
}
bool ResetDevice::display_random() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.display_random)
  return display_random_;
}
void ResetDevice::set_display_random(bool value) {
  set_has_display_random();
  display_random_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.display_random)
}

// optional uint32 strength = 2 [default = 256];
bool ResetDevice::has_strength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ResetDevice::set_has_strength() {
  _has_bits_[0] |= 0x00000040u;
}
void ResetDevice::clear_has_strength() {
  _has_bits_[0] &= ~0x00000040u;
}
void ResetDevice::clear_strength() {
  strength_ = 256u;
  clear_has_strength();
}
::google::protobuf::uint32 ResetDevice::strength() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.strength)
  return strength_;
}
void ResetDevice::set_strength(::google::protobuf::uint32 value) {
  set_has_strength();
  strength_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.strength)
}

// optional bool passphrase_protection = 3;
bool ResetDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResetDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
void ResetDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResetDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
bool ResetDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.passphrase_protection)
  return passphrase_protection_;
}
void ResetDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.passphrase_protection)
}

// optional bool pin_protection = 4;
bool ResetDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ResetDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000010u;
}
void ResetDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000010u;
}
void ResetDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
bool ResetDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.pin_protection)
  return pin_protection_;
}
void ResetDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.pin_protection)
}

// optional string language = 5 [default = "english"];
bool ResetDevice::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResetDevice::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
void ResetDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResetDevice::clear_language() {
  language_.ClearToDefaultNoArena(&ResetDevice::_default_language_.get());
  clear_has_language();
}
const ::std::string& ResetDevice::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.language)
  return language_.GetNoArena();
}
void ResetDevice::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&ResetDevice::_default_language_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.language)
}
#if LANG_CXX11
void ResetDevice::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &ResetDevice::_default_language_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ResetDevice.language)
}
#endif
void ResetDevice::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&ResetDevice::_default_language_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ResetDevice.language)
}
void ResetDevice::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&ResetDevice::_default_language_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ResetDevice.language)
}
::std::string* ResetDevice::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ResetDevice.language)
  return language_.MutableNoArena(&ResetDevice::_default_language_.get());
}
::std::string* ResetDevice::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ResetDevice.language)
  clear_has_language();
  return language_.ReleaseNoArena(&ResetDevice::_default_language_.get());
}
void ResetDevice::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&ResetDevice::_default_language_.get(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ResetDevice.language)
}

// optional string label = 6;
bool ResetDevice::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResetDevice::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
void ResetDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResetDevice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
const ::std::string& ResetDevice::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.label)
  return label_.GetNoArena();
}
void ResetDevice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.label)
}
#if LANG_CXX11
void ResetDevice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ResetDevice.label)
}
#endif
void ResetDevice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ResetDevice.label)
}
void ResetDevice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ResetDevice.label)
}
::std::string* ResetDevice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ResetDevice.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ResetDevice::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ResetDevice.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ResetDevice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ResetDevice.label)
}

// optional uint32 u2f_counter = 7;
bool ResetDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ResetDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000020u;
}
void ResetDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000020u;
}
void ResetDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
::google::protobuf::uint32 ResetDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.u2f_counter)
  return u2f_counter_;
}
void ResetDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.u2f_counter)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EntropyRequest::EntropyRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EntropyRequest)
}
EntropyRequest::EntropyRequest(const EntropyRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EntropyRequest)
}

void EntropyRequest::SharedCtor() {
  _cached_size_ = 0;
}

EntropyRequest::~EntropyRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EntropyRequest)
  SharedDtor();
}

void EntropyRequest::SharedDtor() {
}

void EntropyRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntropyRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EntropyRequest& EntropyRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EntropyRequest* EntropyRequest::New(::google::protobuf::Arena* arena) const {
  EntropyRequest* n = new EntropyRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EntropyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EntropyRequest)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EntropyRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EntropyRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EntropyRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EntropyRequest)
  return false;
#undef DO_
}

void EntropyRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EntropyRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EntropyRequest)
}

::google::protobuf::uint8* EntropyRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EntropyRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EntropyRequest)
  return target;
}

size_t EntropyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EntropyRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntropyRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EntropyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const EntropyRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EntropyRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EntropyRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EntropyRequest)
    MergeFrom(*source);
  }
}

void EntropyRequest::MergeFrom(const EntropyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EntropyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void EntropyRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EntropyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntropyRequest::CopyFrom(const EntropyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EntropyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntropyRequest::IsInitialized() const {
  return true;
}

void EntropyRequest::Swap(EntropyRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EntropyRequest::InternalSwap(EntropyRequest* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EntropyRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EntropyRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EntropyAck::kEntropyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EntropyAck::EntropyAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EntropyAck)
}
EntropyAck::EntropyAck(const EntropyAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  entropy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_entropy()) {
    entropy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entropy_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EntropyAck)
}

void EntropyAck::SharedCtor() {
  _cached_size_ = 0;
  entropy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EntropyAck::~EntropyAck() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EntropyAck)
  SharedDtor();
}

void EntropyAck::SharedDtor() {
  entropy_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EntropyAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntropyAck::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EntropyAck& EntropyAck::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EntropyAck* EntropyAck::New(::google::protobuf::Arena* arena) const {
  EntropyAck* n = new EntropyAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EntropyAck::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EntropyAck)
  if (has_entropy()) {
    GOOGLE_DCHECK(!entropy_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*entropy_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EntropyAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EntropyAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes entropy = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_entropy()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EntropyAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EntropyAck)
  return false;
#undef DO_
}

void EntropyAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EntropyAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes entropy = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->entropy(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EntropyAck)
}

::google::protobuf::uint8* EntropyAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EntropyAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes entropy = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->entropy(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EntropyAck)
  return target;
}

size_t EntropyAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EntropyAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional bytes entropy = 1;
  if (has_entropy()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->entropy());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntropyAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EntropyAck)
  GOOGLE_DCHECK_NE(&from, this);
  const EntropyAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EntropyAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EntropyAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EntropyAck)
    MergeFrom(*source);
  }
}

void EntropyAck::MergeFrom(const EntropyAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EntropyAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_entropy()) {
    set_has_entropy();
    entropy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entropy_);
  }
}

void EntropyAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EntropyAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntropyAck::CopyFrom(const EntropyAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EntropyAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntropyAck::IsInitialized() const {
  return true;
}

void EntropyAck::Swap(EntropyAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EntropyAck::InternalSwap(EntropyAck* other) {
  entropy_.Swap(&other->entropy_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EntropyAck::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EntropyAck

// optional bytes entropy = 1;
bool EntropyAck::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EntropyAck::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
void EntropyAck::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
void EntropyAck::clear_entropy() {
  entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entropy();
}
const ::std::string& EntropyAck::entropy() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EntropyAck.entropy)
  return entropy_.GetNoArena();
}
void EntropyAck::set_entropy(const ::std::string& value) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EntropyAck.entropy)
}
#if LANG_CXX11
void EntropyAck::set_entropy(::std::string&& value) {
  set_has_entropy();
  entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EntropyAck.entropy)
}
#endif
void EntropyAck::set_entropy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EntropyAck.entropy)
}
void EntropyAck::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EntropyAck.entropy)
}
::std::string* EntropyAck::mutable_entropy() {
  set_has_entropy();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EntropyAck.entropy)
  return entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EntropyAck::release_entropy() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EntropyAck.entropy)
  clear_has_entropy();
  return entropy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EntropyAck::set_allocated_entropy(::std::string* entropy) {
  if (entropy != NULL) {
    set_has_entropy();
  } else {
    clear_has_entropy();
  }
  entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entropy);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EntropyAck.entropy)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> RecoveryDevice::_default_language_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RecoveryDevice::kWordCountFieldNumber;
const int RecoveryDevice::kPassphraseProtectionFieldNumber;
const int RecoveryDevice::kPinProtectionFieldNumber;
const int RecoveryDevice::kLanguageFieldNumber;
const int RecoveryDevice::kLabelFieldNumber;
const int RecoveryDevice::kEnforceWordlistFieldNumber;
const int RecoveryDevice::kTypeFieldNumber;
const int RecoveryDevice::kU2FCounterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RecoveryDevice::RecoveryDevice()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.RecoveryDevice)
}
RecoveryDevice::RecoveryDevice(const RecoveryDevice& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  language_.UnsafeSetDefault(&RecoveryDevice::_default_language_.get());
  if (from.has_language()) {
    language_.AssignWithDefault(&RecoveryDevice::_default_language_.get(), from.language_);
  }
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_label()) {
    label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
  }
  ::memcpy(&word_count_, &from.word_count_,
    reinterpret_cast<char*>(&u2f_counter_) -
    reinterpret_cast<char*>(&word_count_) + sizeof(u2f_counter_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.RecoveryDevice)
}

void RecoveryDevice::SharedCtor() {
  _cached_size_ = 0;
  language_.UnsafeSetDefault(&RecoveryDevice::_default_language_.get());
  label_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&word_count_, 0, reinterpret_cast<char*>(&u2f_counter_) -
    reinterpret_cast<char*>(&word_count_) + sizeof(u2f_counter_));
}

RecoveryDevice::~RecoveryDevice() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.RecoveryDevice)
  SharedDtor();
}

void RecoveryDevice::SharedDtor() {
  language_.DestroyNoArena(&RecoveryDevice::_default_language_.get());
  label_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RecoveryDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RecoveryDevice::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const RecoveryDevice& RecoveryDevice::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

RecoveryDevice* RecoveryDevice::New(::google::protobuf::Arena* arena) const {
  RecoveryDevice* n = new RecoveryDevice;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RecoveryDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.RecoveryDevice)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_language()) {
      GOOGLE_DCHECK(!language_.IsDefault(&RecoveryDevice::_default_language_.get()));
      (*language_.UnsafeRawStringPointer())->assign(*&RecoveryDevice::_default_language_.get());
    }
    if (has_label()) {
      GOOGLE_DCHECK(!label_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*label_.UnsafeRawStringPointer())->clear();
    }
  }
  if (_has_bits_[0 / 32] & 252u) {
    ::memset(&word_count_, 0, reinterpret_cast<char*>(&u2f_counter_) -
      reinterpret_cast<char*>(&word_count_) + sizeof(u2f_counter_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RecoveryDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.RecoveryDevice)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 word_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_word_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &word_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool passphrase_protection = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_passphrase_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool pin_protection = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_pin_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 4 [default = "english"];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.RecoveryDevice.language");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string label = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.RecoveryDevice.label");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool enforce_wordlist = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u)) {
          set_has_enforce_wordlist();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enforce_wordlist_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 type = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u)) {
          set_has_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 u2f_counter = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u)) {
          set_has_u2f_counter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u2f_counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.RecoveryDevice)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.RecoveryDevice)
  return false;
#undef DO_
}

void RecoveryDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.RecoveryDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 word_count = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->word_count(), output);
  }

  // optional bool passphrase_protection = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->passphrase_protection(), output);
  }

  // optional bool pin_protection = 3;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->pin_protection(), output);
  }

  // optional string language = 4 [default = "english"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.RecoveryDevice.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->language(), output);
  }

  // optional string label = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.RecoveryDevice.label");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->label(), output);
  }

  // optional bool enforce_wordlist = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->enforce_wordlist(), output);
  }

  // optional uint32 type = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->type(), output);
  }

  // optional uint32 u2f_counter = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->u2f_counter(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.RecoveryDevice)
}

::google::protobuf::uint8* RecoveryDevice::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.RecoveryDevice)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 word_count = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->word_count(), target);
  }

  // optional bool passphrase_protection = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->passphrase_protection(), target);
  }

  // optional bool pin_protection = 3;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->pin_protection(), target);
  }

  // optional string language = 4 [default = "english"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.RecoveryDevice.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->language(), target);
  }

  // optional string label = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.RecoveryDevice.label");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->label(), target);
  }

  // optional bool enforce_wordlist = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->enforce_wordlist(), target);
  }

  // optional uint32 type = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->type(), target);
  }

  // optional uint32 u2f_counter = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->u2f_counter(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.RecoveryDevice)
  return target;
}

size_t RecoveryDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.RecoveryDevice)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional string language = 4 [default = "english"];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 5;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional uint32 word_count = 1;
    if (has_word_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->word_count());
    }

    // optional bool passphrase_protection = 2;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 3;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional bool enforce_wordlist = 6;
    if (has_enforce_wordlist()) {
      total_size += 1 + 1;
    }

    // optional uint32 type = 8;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }

    // optional uint32 u2f_counter = 9;
    if (has_u2f_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->u2f_counter());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecoveryDevice::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.RecoveryDevice)
  GOOGLE_DCHECK_NE(&from, this);
  const RecoveryDevice* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const RecoveryDevice>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.RecoveryDevice)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.RecoveryDevice)
    MergeFrom(*source);
  }
}

void RecoveryDevice::MergeFrom(const RecoveryDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.RecoveryDevice)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_language();
      language_.AssignWithDefault(&RecoveryDevice::_default_language_.get(), from.language_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_label();
      label_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.label_);
    }
    if (cached_has_bits & 0x00000004u) {
      word_count_ = from.word_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      passphrase_protection_ = from.passphrase_protection_;
    }
    if (cached_has_bits & 0x00000010u) {
      pin_protection_ = from.pin_protection_;
    }
    if (cached_has_bits & 0x00000020u) {
      enforce_wordlist_ = from.enforce_wordlist_;
    }
    if (cached_has_bits & 0x00000040u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      u2f_counter_ = from.u2f_counter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RecoveryDevice::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.RecoveryDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RecoveryDevice::CopyFrom(const RecoveryDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.RecoveryDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoveryDevice::IsInitialized() const {
  return true;
}

void RecoveryDevice::Swap(RecoveryDevice* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RecoveryDevice::InternalSwap(RecoveryDevice* other) {
  language_.Swap(&other->language_);
  label_.Swap(&other->label_);
  std::swap(word_count_, other->word_count_);
  std::swap(passphrase_protection_, other->passphrase_protection_);
  std::swap(pin_protection_, other->pin_protection_);
  std::swap(enforce_wordlist_, other->enforce_wordlist_);
  std::swap(type_, other->type_);
  std::swap(u2f_counter_, other->u2f_counter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RecoveryDevice::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RecoveryDevice

// optional uint32 word_count = 1;
bool RecoveryDevice::has_word_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RecoveryDevice::set_has_word_count() {
  _has_bits_[0] |= 0x00000004u;
}
void RecoveryDevice::clear_has_word_count() {
  _has_bits_[0] &= ~0x00000004u;
}
void RecoveryDevice::clear_word_count() {
  word_count_ = 0u;
  clear_has_word_count();
}
::google::protobuf::uint32 RecoveryDevice::word_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.word_count)
  return word_count_;
}
void RecoveryDevice::set_word_count(::google::protobuf::uint32 value) {
  set_has_word_count();
  word_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.word_count)
}

// optional bool passphrase_protection = 2;
bool RecoveryDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RecoveryDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
void RecoveryDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
void RecoveryDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
bool RecoveryDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.passphrase_protection)
  return passphrase_protection_;
}
void RecoveryDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.passphrase_protection)
}

// optional bool pin_protection = 3;
bool RecoveryDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RecoveryDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000010u;
}
void RecoveryDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000010u;
}
void RecoveryDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
bool RecoveryDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.pin_protection)
  return pin_protection_;
}
void RecoveryDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.pin_protection)
}

// optional string language = 4 [default = "english"];
bool RecoveryDevice::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RecoveryDevice::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
void RecoveryDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
void RecoveryDevice::clear_language() {
  language_.ClearToDefaultNoArena(&RecoveryDevice::_default_language_.get());
  clear_has_language();
}
const ::std::string& RecoveryDevice::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.language)
  return language_.GetNoArena();
}
void RecoveryDevice::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&RecoveryDevice::_default_language_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.language)
}
#if LANG_CXX11
void RecoveryDevice::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &RecoveryDevice::_default_language_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.RecoveryDevice.language)
}
#endif
void RecoveryDevice::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&RecoveryDevice::_default_language_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.RecoveryDevice.language)
}
void RecoveryDevice::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&RecoveryDevice::_default_language_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.RecoveryDevice.language)
}
::std::string* RecoveryDevice::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.RecoveryDevice.language)
  return language_.MutableNoArena(&RecoveryDevice::_default_language_.get());
}
::std::string* RecoveryDevice::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.RecoveryDevice.language)
  clear_has_language();
  return language_.ReleaseNoArena(&RecoveryDevice::_default_language_.get());
}
void RecoveryDevice::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&RecoveryDevice::_default_language_.get(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.RecoveryDevice.language)
}

// optional string label = 5;
bool RecoveryDevice::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RecoveryDevice::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
void RecoveryDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
void RecoveryDevice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
const ::std::string& RecoveryDevice::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.label)
  return label_.GetNoArena();
}
void RecoveryDevice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.label)
}
#if LANG_CXX11
void RecoveryDevice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.RecoveryDevice.label)
}
#endif
void RecoveryDevice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.RecoveryDevice.label)
}
void RecoveryDevice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.RecoveryDevice.label)
}
::std::string* RecoveryDevice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.RecoveryDevice.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RecoveryDevice::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.RecoveryDevice.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RecoveryDevice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.RecoveryDevice.label)
}

// optional bool enforce_wordlist = 6;
bool RecoveryDevice::has_enforce_wordlist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RecoveryDevice::set_has_enforce_wordlist() {
  _has_bits_[0] |= 0x00000020u;
}
void RecoveryDevice::clear_has_enforce_wordlist() {
  _has_bits_[0] &= ~0x00000020u;
}
void RecoveryDevice::clear_enforce_wordlist() {
  enforce_wordlist_ = false;
  clear_has_enforce_wordlist();
}
bool RecoveryDevice::enforce_wordlist() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.enforce_wordlist)
  return enforce_wordlist_;
}
void RecoveryDevice::set_enforce_wordlist(bool value) {
  set_has_enforce_wordlist();
  enforce_wordlist_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.enforce_wordlist)
}

// optional uint32 type = 8;
bool RecoveryDevice::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RecoveryDevice::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
void RecoveryDevice::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
void RecoveryDevice::clear_type() {
  type_ = 0u;
  clear_has_type();
}
::google::protobuf::uint32 RecoveryDevice::type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.type)
  return type_;
}
void RecoveryDevice::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.type)
}

// optional uint32 u2f_counter = 9;
bool RecoveryDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RecoveryDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000080u;
}
void RecoveryDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000080u;
}
void RecoveryDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
::google::protobuf::uint32 RecoveryDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.u2f_counter)
  return u2f_counter_;
}
void RecoveryDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.u2f_counter)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int WordRequest::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WordRequest::WordRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.WordRequest)
}
WordRequest::WordRequest(const WordRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.WordRequest)
}

void WordRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
}

WordRequest::~WordRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.WordRequest)
  SharedDtor();
}

void WordRequest::SharedDtor() {
}

void WordRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WordRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const WordRequest& WordRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

WordRequest* WordRequest::New(::google::protobuf::Arena* arena) const {
  WordRequest* n = new WordRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WordRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.WordRequest)
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool WordRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.WordRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.WordRequestType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TrezorProtobuf::WordRequestType_IsValid(value)) {
            set_type(static_cast< ::TrezorProtobuf::WordRequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.WordRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.WordRequest)
  return false;
#undef DO_
}

void WordRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.WordRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.WordRequestType type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.WordRequest)
}

::google::protobuf::uint8* WordRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.WordRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.WordRequestType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.WordRequest)
  return target;
}

size_t WordRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.WordRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional .TrezorProtobuf.WordRequestType type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WordRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.WordRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const WordRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const WordRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.WordRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.WordRequest)
    MergeFrom(*source);
  }
}

void WordRequest::MergeFrom(const WordRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.WordRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_type()) {
    set_type(from.type());
  }
}

void WordRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.WordRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WordRequest::CopyFrom(const WordRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.WordRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordRequest::IsInitialized() const {
  return true;
}

void WordRequest::Swap(WordRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WordRequest::InternalSwap(WordRequest* other) {
  std::swap(type_, other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WordRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WordRequest

// optional .TrezorProtobuf.WordRequestType type = 1;
bool WordRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void WordRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void WordRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void WordRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
::TrezorProtobuf::WordRequestType WordRequest::type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.WordRequest.type)
  return static_cast< ::TrezorProtobuf::WordRequestType >(type_);
}
void WordRequest::set_type(::TrezorProtobuf::WordRequestType value) {
  assert(::TrezorProtobuf::WordRequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.WordRequest.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int WordAck::kWordFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WordAck::WordAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.WordAck)
}
WordAck::WordAck(const WordAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  word_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_word()) {
    word_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.word_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.WordAck)
}

void WordAck::SharedCtor() {
  _cached_size_ = 0;
  word_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

WordAck::~WordAck() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.WordAck)
  SharedDtor();
}

void WordAck::SharedDtor() {
  word_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void WordAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WordAck::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const WordAck& WordAck::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

WordAck* WordAck::New(::google::protobuf::Arena* arena) const {
  WordAck* n = new WordAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WordAck::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.WordAck)
  if (has_word()) {
    GOOGLE_DCHECK(!word_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*word_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool WordAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.WordAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string word = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->word().data(), this->word().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.WordAck.word");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.WordAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.WordAck)
  return false;
#undef DO_
}

void WordAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.WordAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string word = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.WordAck.word");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->word(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.WordAck)
}

::google::protobuf::uint8* WordAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.WordAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string word = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.WordAck.word");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->word(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.WordAck)
  return target;
}

size_t WordAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.WordAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required string word = 1;
  if (has_word()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->word());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WordAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.WordAck)
  GOOGLE_DCHECK_NE(&from, this);
  const WordAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const WordAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.WordAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.WordAck)
    MergeFrom(*source);
  }
}

void WordAck::MergeFrom(const WordAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.WordAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_word()) {
    set_has_word();
    word_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.word_);
  }
}

void WordAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.WordAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WordAck::CopyFrom(const WordAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.WordAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void WordAck::Swap(WordAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WordAck::InternalSwap(WordAck* other) {
  word_.Swap(&other->word_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WordAck::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WordAck

// required string word = 1;
bool WordAck::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void WordAck::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
void WordAck::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
void WordAck::clear_word() {
  word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_word();
}
const ::std::string& WordAck::word() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.WordAck.word)
  return word_.GetNoArena();
}
void WordAck::set_word(const ::std::string& value) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.WordAck.word)
}
#if LANG_CXX11
void WordAck::set_word(::std::string&& value) {
  set_has_word();
  word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.WordAck.word)
}
#endif
void WordAck::set_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.WordAck.word)
}
void WordAck::set_word(const char* value, size_t size) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.WordAck.word)
}
::std::string* WordAck::mutable_word() {
  set_has_word();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.WordAck.word)
  return word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* WordAck::release_word() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.WordAck.word)
  clear_has_word();
  return word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void WordAck::set_allocated_word(::std::string* word) {
  if (word != NULL) {
    set_has_word();
  } else {
    clear_has_word();
  }
  word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.WordAck.word)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> SignMessage::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignMessage::kAddressNFieldNumber;
const int SignMessage::kMessageFieldNumber;
const int SignMessage::kCoinNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignMessage::SignMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.SignMessage)
}
SignMessage::SignMessage(const SignMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  coin_name_.UnsafeSetDefault(&SignMessage::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&SignMessage::_default_coin_name_.get(), from.coin_name_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.SignMessage)
}

void SignMessage::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.UnsafeSetDefault(&SignMessage::_default_coin_name_.get());
}

SignMessage::~SignMessage() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.SignMessage)
  SharedDtor();
}

void SignMessage::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.DestroyNoArena(&SignMessage::_default_coin_name_.get());
}

void SignMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignMessage::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SignMessage& SignMessage::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

SignMessage* SignMessage::New(::google::protobuf::Arena* arena) const {
  SignMessage* n = new SignMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SignMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.SignMessage)
  address_n_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    if (has_message()) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (has_coin_name()) {
      GOOGLE_DCHECK(!coin_name_.IsDefault(&SignMessage::_default_coin_name_.get()));
      (*coin_name_.UnsafeRawStringPointer())->assign(*&SignMessage::_default_coin_name_.get());
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.SignMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.SignMessage.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.SignMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.SignMessage)
  return false;
#undef DO_
}

void SignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.SignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // required bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignMessage.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->coin_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.SignMessage)
}

::google::protobuf::uint8* SignMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.SignMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // required bytes message = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignMessage.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.SignMessage)
  return target;
}

size_t SignMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.SignMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required bytes message = 2;
  if (has_message()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->message());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->coin_name());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.SignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const SignMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SignMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.SignMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.SignMessage)
    MergeFrom(*source);
  }
}

void SignMessage::MergeFrom(const SignMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.SignMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&SignMessage::_default_coin_name_.get(), from.coin_name_);
    }
  }
}

void SignMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.SignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignMessage::CopyFrom(const SignMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.SignMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void SignMessage::Swap(SignMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignMessage::InternalSwap(SignMessage* other) {
  address_n_.InternalSwap(&other->address_n_);
  message_.Swap(&other->message_);
  coin_name_.Swap(&other->coin_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SignMessage::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SignMessage

// repeated uint32 address_n = 1;
int SignMessage::address_n_size() const {
  return address_n_.size();
}
void SignMessage::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 SignMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignMessage.address_n)
  return address_n_.Get(index);
}
void SignMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignMessage.address_n)
}
void SignMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SignMessage.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SignMessage::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SignMessage.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SignMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SignMessage.address_n)
  return &address_n_;
}

// required bytes message = 2;
bool SignMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SignMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void SignMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void SignMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& SignMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignMessage.message)
  return message_.GetNoArena();
}
void SignMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignMessage.message)
}
#if LANG_CXX11
void SignMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignMessage.message)
}
#endif
void SignMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignMessage.message)
}
void SignMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignMessage.message)
}
::std::string* SignMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SignMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SignMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignMessage.message)
}

// optional string coin_name = 3 [default = "Bitcoin"];
bool SignMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SignMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000002u;
}
void SignMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void SignMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&SignMessage::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& SignMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignMessage.coin_name)
  return coin_name_.GetNoArena();
}
void SignMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignMessage::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignMessage.coin_name)
}
#if LANG_CXX11
void SignMessage::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &SignMessage::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignMessage.coin_name)
}
#endif
void SignMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&SignMessage::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignMessage.coin_name)
}
void SignMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignMessage::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignMessage.coin_name)
}
::std::string* SignMessage::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignMessage.coin_name)
  return coin_name_.MutableNoArena(&SignMessage::_default_coin_name_.get());
}
::std::string* SignMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignMessage.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&SignMessage::_default_coin_name_.get());
}
void SignMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&SignMessage::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignMessage.coin_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> VerifyMessage::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VerifyMessage::kAddressFieldNumber;
const int VerifyMessage::kSignatureFieldNumber;
const int VerifyMessage::kMessageFieldNumber;
const int VerifyMessage::kCoinNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VerifyMessage::VerifyMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.VerifyMessage)
}
VerifyMessage::VerifyMessage(const VerifyMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  coin_name_.UnsafeSetDefault(&VerifyMessage::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&VerifyMessage::_default_coin_name_.get(), from.coin_name_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.VerifyMessage)
}

void VerifyMessage::SharedCtor() {
  _cached_size_ = 0;
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.UnsafeSetDefault(&VerifyMessage::_default_coin_name_.get());
}

VerifyMessage::~VerifyMessage() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.VerifyMessage)
  SharedDtor();
}

void VerifyMessage::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.DestroyNoArena(&VerifyMessage::_default_coin_name_.get());
}

void VerifyMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VerifyMessage::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const VerifyMessage& VerifyMessage::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

VerifyMessage* VerifyMessage::New(::google::protobuf::Arena* arena) const {
  VerifyMessage* n = new VerifyMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VerifyMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.VerifyMessage)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_address()) {
      GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*address_.UnsafeRawStringPointer())->clear();
    }
    if (has_signature()) {
      GOOGLE_DCHECK(!signature_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*signature_.UnsafeRawStringPointer())->clear();
    }
    if (has_message()) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (has_coin_name()) {
      GOOGLE_DCHECK(!coin_name_.IsDefault(&VerifyMessage::_default_coin_name_.get()));
      (*coin_name_.UnsafeRawStringPointer())->assign(*&VerifyMessage::_default_coin_name_.get());
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool VerifyMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.VerifyMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.VerifyMessage.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.VerifyMessage.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.VerifyMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.VerifyMessage)
  return false;
#undef DO_
}

void VerifyMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.VerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.VerifyMessage.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->message(), output);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.VerifyMessage.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->coin_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.VerifyMessage)
}

::google::protobuf::uint8* VerifyMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.VerifyMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.VerifyMessage.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->message(), target);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.VerifyMessage.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.VerifyMessage)
  return target;
}

size_t VerifyMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.VerifyMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string coin_name = 4 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VerifyMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.VerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const VerifyMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const VerifyMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.VerifyMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.VerifyMessage)
    MergeFrom(*source);
  }
}

void VerifyMessage::MergeFrom(const VerifyMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.VerifyMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&VerifyMessage::_default_coin_name_.get(), from.coin_name_);
    }
  }
}

void VerifyMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.VerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VerifyMessage::CopyFrom(const VerifyMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.VerifyMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyMessage::IsInitialized() const {
  return true;
}

void VerifyMessage::Swap(VerifyMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VerifyMessage::InternalSwap(VerifyMessage* other) {
  address_.Swap(&other->address_);
  signature_.Swap(&other->signature_);
  message_.Swap(&other->message_);
  coin_name_.Swap(&other->coin_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata VerifyMessage::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VerifyMessage

// optional string address = 1;
bool VerifyMessage::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void VerifyMessage::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void VerifyMessage::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void VerifyMessage::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string& VerifyMessage::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.address)
  return address_.GetNoArena();
}
void VerifyMessage::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.address)
}
#if LANG_CXX11
void VerifyMessage::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.address)
}
#endif
void VerifyMessage::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.address)
}
void VerifyMessage::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.address)
}
::std::string* VerifyMessage::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VerifyMessage::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VerifyMessage::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.address)
}

// optional bytes signature = 2;
bool VerifyMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void VerifyMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
void VerifyMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
void VerifyMessage::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
const ::std::string& VerifyMessage::signature() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.signature)
  return signature_.GetNoArena();
}
void VerifyMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.signature)
}
#if LANG_CXX11
void VerifyMessage::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.signature)
}
#endif
void VerifyMessage::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.signature)
}
void VerifyMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.signature)
}
::std::string* VerifyMessage::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VerifyMessage::release_signature() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VerifyMessage::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.signature)
}

// optional bytes message = 3;
bool VerifyMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void VerifyMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
void VerifyMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
void VerifyMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& VerifyMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.message)
  return message_.GetNoArena();
}
void VerifyMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.message)
}
#if LANG_CXX11
void VerifyMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.message)
}
#endif
void VerifyMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.message)
}
void VerifyMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.message)
}
::std::string* VerifyMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VerifyMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VerifyMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.message)
}

// optional string coin_name = 4 [default = "Bitcoin"];
bool VerifyMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void VerifyMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000008u;
}
void VerifyMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000008u;
}
void VerifyMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&VerifyMessage::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& VerifyMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.coin_name)
  return coin_name_.GetNoArena();
}
void VerifyMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&VerifyMessage::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.coin_name)
}
#if LANG_CXX11
void VerifyMessage::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &VerifyMessage::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.coin_name)
}
#endif
void VerifyMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&VerifyMessage::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.coin_name)
}
void VerifyMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&VerifyMessage::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.coin_name)
}
::std::string* VerifyMessage::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.coin_name)
  return coin_name_.MutableNoArena(&VerifyMessage::_default_coin_name_.get());
}
::std::string* VerifyMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&VerifyMessage::_default_coin_name_.get());
}
void VerifyMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&VerifyMessage::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.coin_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MessageSignature::kAddressFieldNumber;
const int MessageSignature::kSignatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MessageSignature::MessageSignature()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.MessageSignature)
}
MessageSignature::MessageSignature(const MessageSignature& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.MessageSignature)
}

void MessageSignature::SharedCtor() {
  _cached_size_ = 0;
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

MessageSignature::~MessageSignature() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.MessageSignature)
  SharedDtor();
}

void MessageSignature::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void MessageSignature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MessageSignature::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const MessageSignature& MessageSignature::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

MessageSignature* MessageSignature::New(::google::protobuf::Arena* arena) const {
  MessageSignature* n = new MessageSignature;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MessageSignature::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.MessageSignature)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_address()) {
      GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*address_.UnsafeRawStringPointer())->clear();
    }
    if (has_signature()) {
      GOOGLE_DCHECK(!signature_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*signature_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool MessageSignature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.MessageSignature)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.MessageSignature.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.MessageSignature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.MessageSignature)
  return false;
#undef DO_
}

void MessageSignature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.MessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.MessageSignature.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.MessageSignature)
}

::google::protobuf::uint8* MessageSignature::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.MessageSignature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.MessageSignature.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.MessageSignature)
  return target;
}

size_t MessageSignature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.MessageSignature)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MessageSignature::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.MessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  const MessageSignature* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const MessageSignature>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.MessageSignature)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.MessageSignature)
    MergeFrom(*source);
  }
}

void MessageSignature::MergeFrom(const MessageSignature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.MessageSignature)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
  }
}

void MessageSignature::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.MessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageSignature::CopyFrom(const MessageSignature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.MessageSignature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageSignature::IsInitialized() const {
  return true;
}

void MessageSignature::Swap(MessageSignature* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MessageSignature::InternalSwap(MessageSignature* other) {
  address_.Swap(&other->address_);
  signature_.Swap(&other->signature_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MessageSignature::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MessageSignature

// optional string address = 1;
bool MessageSignature::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MessageSignature::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void MessageSignature::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void MessageSignature::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string& MessageSignature::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.MessageSignature.address)
  return address_.GetNoArena();
}
void MessageSignature::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.MessageSignature.address)
}
#if LANG_CXX11
void MessageSignature::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.MessageSignature.address)
}
#endif
void MessageSignature::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.MessageSignature.address)
}
void MessageSignature::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.MessageSignature.address)
}
::std::string* MessageSignature::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.MessageSignature.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* MessageSignature::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.MessageSignature.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void MessageSignature::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.MessageSignature.address)
}

// optional bytes signature = 2;
bool MessageSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MessageSignature::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
void MessageSignature::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
void MessageSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
const ::std::string& MessageSignature::signature() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.MessageSignature.signature)
  return signature_.GetNoArena();
}
void MessageSignature::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.MessageSignature.signature)
}
#if LANG_CXX11
void MessageSignature::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.MessageSignature.signature)
}
#endif
void MessageSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.MessageSignature.signature)
}
void MessageSignature::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.MessageSignature.signature)
}
::std::string* MessageSignature::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.MessageSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* MessageSignature::release_signature() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.MessageSignature.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void MessageSignature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.MessageSignature.signature)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> EncryptMessage::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EncryptMessage::kPubkeyFieldNumber;
const int EncryptMessage::kMessageFieldNumber;
const int EncryptMessage::kDisplayOnlyFieldNumber;
const int EncryptMessage::kAddressNFieldNumber;
const int EncryptMessage::kCoinNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EncryptMessage::EncryptMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EncryptMessage)
}
EncryptMessage::EncryptMessage(const EncryptMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pubkey()) {
    pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pubkey_);
  }
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  coin_name_.UnsafeSetDefault(&EncryptMessage::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&EncryptMessage::_default_coin_name_.get(), from.coin_name_);
  }
  display_only_ = from.display_only_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EncryptMessage)
}

void EncryptMessage::SharedCtor() {
  _cached_size_ = 0;
  pubkey_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.UnsafeSetDefault(&EncryptMessage::_default_coin_name_.get());
  display_only_ = false;
}

EncryptMessage::~EncryptMessage() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EncryptMessage)
  SharedDtor();
}

void EncryptMessage::SharedDtor() {
  pubkey_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  coin_name_.DestroyNoArena(&EncryptMessage::_default_coin_name_.get());
}

void EncryptMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EncryptMessage::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EncryptMessage& EncryptMessage::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EncryptMessage* EncryptMessage::New(::google::protobuf::Arena* arena) const {
  EncryptMessage* n = new EncryptMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EncryptMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EncryptMessage)
  address_n_.Clear();
  if (_has_bits_[0 / 32] & 7u) {
    if (has_pubkey()) {
      GOOGLE_DCHECK(!pubkey_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*pubkey_.UnsafeRawStringPointer())->clear();
    }
    if (has_message()) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (has_coin_name()) {
      GOOGLE_DCHECK(!coin_name_.IsDefault(&EncryptMessage::_default_coin_name_.get()));
      (*coin_name_.UnsafeRawStringPointer())->assign(*&EncryptMessage::_default_coin_name_.get());
    }
  }
  display_only_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EncryptMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EncryptMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes pubkey = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool display_only = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_display_only();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &display_only_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 address_n = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(34u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 5 [default = "Bitcoin"];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.EncryptMessage.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EncryptMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EncryptMessage)
  return false;
#undef DO_
}

void EncryptMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EncryptMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes pubkey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->pubkey(), output);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  // optional bool display_only = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->display_only(), output);
  }

  // repeated uint32 address_n = 4;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->address_n(i), output);
  }

  // optional string coin_name = 5 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.EncryptMessage.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->coin_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EncryptMessage)
}

::google::protobuf::uint8* EncryptMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EncryptMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes pubkey = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->pubkey(), target);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  // optional bool display_only = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->display_only(), target);
  }

  // repeated uint32 address_n = 4;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(4, this->address_n_, target);

  // optional string coin_name = 5 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.EncryptMessage.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->coin_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EncryptMessage)
  return target;
}

size_t EncryptMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EncryptMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated uint32 address_n = 4;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 15u) {
    // optional bytes pubkey = 1;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string coin_name = 5 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional bool display_only = 3;
    if (has_display_only()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EncryptMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EncryptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const EncryptMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EncryptMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EncryptMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EncryptMessage)
    MergeFrom(*source);
  }
}

void EncryptMessage::MergeFrom(const EncryptMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EncryptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_pubkey();
      pubkey_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pubkey_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&EncryptMessage::_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000008u) {
      display_only_ = from.display_only_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EncryptMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EncryptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EncryptMessage::CopyFrom(const EncryptMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EncryptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptMessage::IsInitialized() const {
  return true;
}

void EncryptMessage::Swap(EncryptMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EncryptMessage::InternalSwap(EncryptMessage* other) {
  address_n_.InternalSwap(&other->address_n_);
  pubkey_.Swap(&other->pubkey_);
  message_.Swap(&other->message_);
  coin_name_.Swap(&other->coin_name_);
  std::swap(display_only_, other->display_only_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EncryptMessage::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EncryptMessage

// optional bytes pubkey = 1;
bool EncryptMessage::has_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EncryptMessage::set_has_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
void EncryptMessage::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
void EncryptMessage::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pubkey();
}
const ::std::string& EncryptMessage::pubkey() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.pubkey)
  return pubkey_.GetNoArena();
}
void EncryptMessage::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.pubkey)
}
#if LANG_CXX11
void EncryptMessage::set_pubkey(::std::string&& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptMessage.pubkey)
}
#endif
void EncryptMessage::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptMessage.pubkey)
}
void EncryptMessage::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptMessage.pubkey)
}
::std::string* EncryptMessage::mutable_pubkey() {
  set_has_pubkey();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptMessage.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EncryptMessage::release_pubkey() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptMessage.pubkey)
  clear_has_pubkey();
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EncryptMessage::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptMessage.pubkey)
}

// optional bytes message = 2;
bool EncryptMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EncryptMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
void EncryptMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
void EncryptMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& EncryptMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.message)
  return message_.GetNoArena();
}
void EncryptMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.message)
}
#if LANG_CXX11
void EncryptMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptMessage.message)
}
#endif
void EncryptMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptMessage.message)
}
void EncryptMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptMessage.message)
}
::std::string* EncryptMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EncryptMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EncryptMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptMessage.message)
}

// optional bool display_only = 3;
bool EncryptMessage::has_display_only() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void EncryptMessage::set_has_display_only() {
  _has_bits_[0] |= 0x00000008u;
}
void EncryptMessage::clear_has_display_only() {
  _has_bits_[0] &= ~0x00000008u;
}
void EncryptMessage::clear_display_only() {
  display_only_ = false;
  clear_has_display_only();
}
bool EncryptMessage::display_only() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.display_only)
  return display_only_;
}
void EncryptMessage::set_display_only(bool value) {
  set_has_display_only();
  display_only_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.display_only)
}

// repeated uint32 address_n = 4;
int EncryptMessage::address_n_size() const {
  return address_n_.size();
}
void EncryptMessage::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 EncryptMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.address_n)
  return address_n_.Get(index);
}
void EncryptMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.address_n)
}
void EncryptMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.EncryptMessage.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EncryptMessage::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.EncryptMessage.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EncryptMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.EncryptMessage.address_n)
  return &address_n_;
}

// optional string coin_name = 5 [default = "Bitcoin"];
bool EncryptMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EncryptMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000004u;
}
void EncryptMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void EncryptMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&EncryptMessage::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& EncryptMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.coin_name)
  return coin_name_.GetNoArena();
}
void EncryptMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EncryptMessage::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.coin_name)
}
#if LANG_CXX11
void EncryptMessage::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &EncryptMessage::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptMessage.coin_name)
}
#endif
void EncryptMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&EncryptMessage::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptMessage.coin_name)
}
void EncryptMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EncryptMessage::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptMessage.coin_name)
}
::std::string* EncryptMessage::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptMessage.coin_name)
  return coin_name_.MutableNoArena(&EncryptMessage::_default_coin_name_.get());
}
::std::string* EncryptMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptMessage.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&EncryptMessage::_default_coin_name_.get());
}
void EncryptMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&EncryptMessage::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptMessage.coin_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EncryptedMessage::kNonceFieldNumber;
const int EncryptedMessage::kMessageFieldNumber;
const int EncryptedMessage::kHmacFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EncryptedMessage::EncryptedMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EncryptedMessage)
}
EncryptedMessage::EncryptedMessage(const EncryptedMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nonce()) {
    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  hmac_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hmac()) {
    hmac_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hmac_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EncryptedMessage)
}

void EncryptedMessage::SharedCtor() {
  _cached_size_ = 0;
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hmac_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EncryptedMessage::~EncryptedMessage() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EncryptedMessage)
  SharedDtor();
}

void EncryptedMessage::SharedDtor() {
  nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hmac_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EncryptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EncryptedMessage::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EncryptedMessage& EncryptedMessage::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EncryptedMessage* EncryptedMessage::New(::google::protobuf::Arena* arena) const {
  EncryptedMessage* n = new EncryptedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EncryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EncryptedMessage)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_nonce()) {
      GOOGLE_DCHECK(!nonce_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nonce_.UnsafeRawStringPointer())->clear();
    }
    if (has_message()) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (has_hmac()) {
      GOOGLE_DCHECK(!hmac_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*hmac_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EncryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EncryptedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes nonce = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hmac = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hmac()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EncryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EncryptedMessage)
  return false;
#undef DO_
}

void EncryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EncryptedMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->nonce(), output);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->message(), output);
  }

  // optional bytes hmac = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->hmac(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EncryptedMessage)
}

::google::protobuf::uint8* EncryptedMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EncryptedMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->nonce(), target);
  }

  // optional bytes message = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  // optional bytes hmac = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->hmac(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EncryptedMessage)
  return target;
}

size_t EncryptedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EncryptedMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional bytes nonce = 1;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // optional bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional bytes hmac = 3;
    if (has_hmac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hmac());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EncryptedMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EncryptedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const EncryptedMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EncryptedMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EncryptedMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EncryptedMessage)
    MergeFrom(*source);
  }
}

void EncryptedMessage::MergeFrom(const EncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EncryptedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_nonce();
      nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_hmac();
      hmac_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hmac_);
    }
  }
}

void EncryptedMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EncryptedMessage::CopyFrom(const EncryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EncryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptedMessage::IsInitialized() const {
  return true;
}

void EncryptedMessage::Swap(EncryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EncryptedMessage::InternalSwap(EncryptedMessage* other) {
  nonce_.Swap(&other->nonce_);
  message_.Swap(&other->message_);
  hmac_.Swap(&other->hmac_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EncryptedMessage::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EncryptedMessage

// optional bytes nonce = 1;
bool EncryptedMessage::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EncryptedMessage::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
void EncryptedMessage::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
void EncryptedMessage::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
const ::std::string& EncryptedMessage::nonce() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptedMessage.nonce)
  return nonce_.GetNoArena();
}
void EncryptedMessage::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptedMessage.nonce)
}
#if LANG_CXX11
void EncryptedMessage::set_nonce(::std::string&& value) {
  set_has_nonce();
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptedMessage.nonce)
}
#endif
void EncryptedMessage::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptedMessage.nonce)
}
void EncryptedMessage::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptedMessage.nonce)
}
::std::string* EncryptedMessage::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptedMessage.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EncryptedMessage::release_nonce() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptedMessage.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EncryptedMessage::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptedMessage.nonce)
}

// optional bytes message = 2;
bool EncryptedMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EncryptedMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
void EncryptedMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
void EncryptedMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& EncryptedMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptedMessage.message)
  return message_.GetNoArena();
}
void EncryptedMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptedMessage.message)
}
#if LANG_CXX11
void EncryptedMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptedMessage.message)
}
#endif
void EncryptedMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptedMessage.message)
}
void EncryptedMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptedMessage.message)
}
::std::string* EncryptedMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptedMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EncryptedMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptedMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EncryptedMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptedMessage.message)
}

// optional bytes hmac = 3;
bool EncryptedMessage::has_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EncryptedMessage::set_has_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
void EncryptedMessage::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
void EncryptedMessage::clear_hmac() {
  hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hmac();
}
const ::std::string& EncryptedMessage::hmac() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptedMessage.hmac)
  return hmac_.GetNoArena();
}
void EncryptedMessage::set_hmac(const ::std::string& value) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptedMessage.hmac)
}
#if LANG_CXX11
void EncryptedMessage::set_hmac(::std::string&& value) {
  set_has_hmac();
  hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptedMessage.hmac)
}
#endif
void EncryptedMessage::set_hmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptedMessage.hmac)
}
void EncryptedMessage::set_hmac(const void* value, size_t size) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptedMessage.hmac)
}
::std::string* EncryptedMessage::mutable_hmac() {
  set_has_hmac();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptedMessage.hmac)
  return hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EncryptedMessage::release_hmac() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptedMessage.hmac)
  clear_has_hmac();
  return hmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EncryptedMessage::set_allocated_hmac(::std::string* hmac) {
  if (hmac != NULL) {
    set_has_hmac();
  } else {
    clear_has_hmac();
  }
  hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmac);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptedMessage.hmac)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DecryptMessage::kAddressNFieldNumber;
const int DecryptMessage::kNonceFieldNumber;
const int DecryptMessage::kMessageFieldNumber;
const int DecryptMessage::kHmacFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DecryptMessage::DecryptMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DecryptMessage)
}
DecryptMessage::DecryptMessage(const DecryptMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nonce()) {
    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  hmac_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hmac()) {
    hmac_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hmac_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DecryptMessage)
}

void DecryptMessage::SharedCtor() {
  _cached_size_ = 0;
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hmac_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

DecryptMessage::~DecryptMessage() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DecryptMessage)
  SharedDtor();
}

void DecryptMessage::SharedDtor() {
  nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hmac_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void DecryptMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DecryptMessage::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DecryptMessage& DecryptMessage::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DecryptMessage* DecryptMessage::New(::google::protobuf::Arena* arena) const {
  DecryptMessage* n = new DecryptMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DecryptMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DecryptMessage)
  address_n_.Clear();
  if (_has_bits_[0 / 32] & 7u) {
    if (has_nonce()) {
      GOOGLE_DCHECK(!nonce_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nonce_.UnsafeRawStringPointer())->clear();
    }
    if (has_message()) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (has_hmac()) {
      GOOGLE_DCHECK(!hmac_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*hmac_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DecryptMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DecryptMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nonce = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes message = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hmac = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hmac()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DecryptMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DecryptMessage)
  return false;
#undef DO_
}

void DecryptMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DecryptMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->message(), output);
  }

  // optional bytes hmac = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->hmac(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DecryptMessage)
}

::google::protobuf::uint8* DecryptMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DecryptMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nonce(), target);
  }

  // optional bytes message = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->message(), target);
  }

  // optional bytes hmac = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->hmac(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DecryptMessage)
  return target;
}

size_t DecryptMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DecryptMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional bytes nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // optional bytes message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional bytes hmac = 4;
    if (has_hmac()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hmac());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DecryptMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DecryptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const DecryptMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DecryptMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DecryptMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DecryptMessage)
    MergeFrom(*source);
  }
}

void DecryptMessage::MergeFrom(const DecryptMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DecryptMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_nonce();
      nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_hmac();
      hmac_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hmac_);
    }
  }
}

void DecryptMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DecryptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DecryptMessage::CopyFrom(const DecryptMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DecryptMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecryptMessage::IsInitialized() const {
  return true;
}

void DecryptMessage::Swap(DecryptMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DecryptMessage::InternalSwap(DecryptMessage* other) {
  address_n_.InternalSwap(&other->address_n_);
  nonce_.Swap(&other->nonce_);
  message_.Swap(&other->message_);
  hmac_.Swap(&other->hmac_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DecryptMessage::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DecryptMessage

// repeated uint32 address_n = 1;
int DecryptMessage::address_n_size() const {
  return address_n_.size();
}
void DecryptMessage::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 DecryptMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.address_n)
  return address_n_.Get(index);
}
void DecryptMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.address_n)
}
void DecryptMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.DecryptMessage.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DecryptMessage::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.DecryptMessage.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DecryptMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.DecryptMessage.address_n)
  return &address_n_;
}

// optional bytes nonce = 2;
bool DecryptMessage::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DecryptMessage::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
void DecryptMessage::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
void DecryptMessage::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
const ::std::string& DecryptMessage::nonce() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.nonce)
  return nonce_.GetNoArena();
}
void DecryptMessage::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.nonce)
}
#if LANG_CXX11
void DecryptMessage::set_nonce(::std::string&& value) {
  set_has_nonce();
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptMessage.nonce)
}
#endif
void DecryptMessage::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptMessage.nonce)
}
void DecryptMessage::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptMessage.nonce)
}
::std::string* DecryptMessage::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptMessage.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DecryptMessage::release_nonce() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptMessage.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DecryptMessage::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptMessage.nonce)
}

// optional bytes message = 3;
bool DecryptMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DecryptMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
void DecryptMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
void DecryptMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& DecryptMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.message)
  return message_.GetNoArena();
}
void DecryptMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.message)
}
#if LANG_CXX11
void DecryptMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptMessage.message)
}
#endif
void DecryptMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptMessage.message)
}
void DecryptMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptMessage.message)
}
::std::string* DecryptMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DecryptMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DecryptMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptMessage.message)
}

// optional bytes hmac = 4;
bool DecryptMessage::has_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DecryptMessage::set_has_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
void DecryptMessage::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
void DecryptMessage::clear_hmac() {
  hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hmac();
}
const ::std::string& DecryptMessage::hmac() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.hmac)
  return hmac_.GetNoArena();
}
void DecryptMessage::set_hmac(const ::std::string& value) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.hmac)
}
#if LANG_CXX11
void DecryptMessage::set_hmac(::std::string&& value) {
  set_has_hmac();
  hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptMessage.hmac)
}
#endif
void DecryptMessage::set_hmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptMessage.hmac)
}
void DecryptMessage::set_hmac(const void* value, size_t size) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptMessage.hmac)
}
::std::string* DecryptMessage::mutable_hmac() {
  set_has_hmac();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptMessage.hmac)
  return hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DecryptMessage::release_hmac() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptMessage.hmac)
  clear_has_hmac();
  return hmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DecryptMessage::set_allocated_hmac(::std::string* hmac) {
  if (hmac != NULL) {
    set_has_hmac();
  } else {
    clear_has_hmac();
  }
  hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmac);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptMessage.hmac)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DecryptedMessage::kMessageFieldNumber;
const int DecryptedMessage::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DecryptedMessage::DecryptedMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DecryptedMessage)
}
DecryptedMessage::DecryptedMessage(const DecryptedMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message()) {
    message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
  }
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DecryptedMessage)
}

void DecryptedMessage::SharedCtor() {
  _cached_size_ = 0;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

DecryptedMessage::~DecryptedMessage() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DecryptedMessage)
  SharedDtor();
}

void DecryptedMessage::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void DecryptedMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DecryptedMessage::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DecryptedMessage& DecryptedMessage::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DecryptedMessage* DecryptedMessage::New(::google::protobuf::Arena* arena) const {
  DecryptedMessage* n = new DecryptedMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DecryptedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DecryptedMessage)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_message()) {
      GOOGLE_DCHECK(!message_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_.UnsafeRawStringPointer())->clear();
    }
    if (has_address()) {
      GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*address_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DecryptedMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DecryptedMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes message = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string address = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DecryptedMessage.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DecryptedMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DecryptedMessage)
  return false;
#undef DO_
}

void DecryptedMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DecryptedMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes message = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->message(), output);
  }

  // optional string address = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DecryptedMessage.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DecryptedMessage)
}

::google::protobuf::uint8* DecryptedMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DecryptedMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes message = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->message(), target);
  }

  // optional string address = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DecryptedMessage.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DecryptedMessage)
  return target;
}

size_t DecryptedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DecryptedMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string address = 2;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DecryptedMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DecryptedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const DecryptedMessage* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DecryptedMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DecryptedMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DecryptedMessage)
    MergeFrom(*source);
  }
}

void DecryptedMessage::MergeFrom(const DecryptedMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DecryptedMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
  }
}

void DecryptedMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DecryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DecryptedMessage::CopyFrom(const DecryptedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DecryptedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecryptedMessage::IsInitialized() const {
  return true;
}

void DecryptedMessage::Swap(DecryptedMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DecryptedMessage::InternalSwap(DecryptedMessage* other) {
  message_.Swap(&other->message_);
  address_.Swap(&other->address_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DecryptedMessage::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DecryptedMessage

// optional bytes message = 1;
bool DecryptedMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DecryptedMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void DecryptedMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void DecryptedMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
const ::std::string& DecryptedMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptedMessage.message)
  return message_.GetNoArena();
}
void DecryptedMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptedMessage.message)
}
#if LANG_CXX11
void DecryptedMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptedMessage.message)
}
#endif
void DecryptedMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptedMessage.message)
}
void DecryptedMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptedMessage.message)
}
::std::string* DecryptedMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptedMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DecryptedMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptedMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DecryptedMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptedMessage.message)
}

// optional string address = 2;
bool DecryptedMessage::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DecryptedMessage::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
void DecryptedMessage::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
void DecryptedMessage::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string& DecryptedMessage::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptedMessage.address)
  return address_.GetNoArena();
}
void DecryptedMessage::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptedMessage.address)
}
#if LANG_CXX11
void DecryptedMessage::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptedMessage.address)
}
#endif
void DecryptedMessage::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptedMessage.address)
}
void DecryptedMessage::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptedMessage.address)
}
::std::string* DecryptedMessage::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptedMessage.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DecryptedMessage::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptedMessage.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DecryptedMessage::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptedMessage.address)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CipherKeyValue::kAddressNFieldNumber;
const int CipherKeyValue::kKeyFieldNumber;
const int CipherKeyValue::kValueFieldNumber;
const int CipherKeyValue::kEncryptFieldNumber;
const int CipherKeyValue::kAskOnEncryptFieldNumber;
const int CipherKeyValue::kAskOnDecryptFieldNumber;
const int CipherKeyValue::kIvFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CipherKeyValue::CipherKeyValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.CipherKeyValue)
}
CipherKeyValue::CipherKeyValue(const CipherKeyValue& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_key()) {
    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_iv()) {
    iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
  }
  ::memcpy(&encrypt_, &from.encrypt_,
    reinterpret_cast<char*>(&ask_on_decrypt_) -
    reinterpret_cast<char*>(&encrypt_) + sizeof(ask_on_decrypt_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.CipherKeyValue)
}

void CipherKeyValue::SharedCtor() {
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&encrypt_, 0, reinterpret_cast<char*>(&ask_on_decrypt_) -
    reinterpret_cast<char*>(&encrypt_) + sizeof(ask_on_decrypt_));
}

CipherKeyValue::~CipherKeyValue() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.CipherKeyValue)
  SharedDtor();
}

void CipherKeyValue::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CipherKeyValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CipherKeyValue::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CipherKeyValue& CipherKeyValue::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

CipherKeyValue* CipherKeyValue::New(::google::protobuf::Arena* arena) const {
  CipherKeyValue* n = new CipherKeyValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CipherKeyValue::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.CipherKeyValue)
  address_n_.Clear();
  if (_has_bits_[0 / 32] & 7u) {
    if (has_key()) {
      GOOGLE_DCHECK(!key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*key_.UnsafeRawStringPointer())->clear();
    }
    if (has_value()) {
      GOOGLE_DCHECK(!value_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*value_.UnsafeRawStringPointer())->clear();
    }
    if (has_iv()) {
      GOOGLE_DCHECK(!iv_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*iv_.UnsafeRawStringPointer())->clear();
    }
  }
  if (_has_bits_[0 / 32] & 56u) {
    ::memset(&encrypt_, 0, reinterpret_cast<char*>(&ask_on_decrypt_) -
      reinterpret_cast<char*>(&encrypt_) + sizeof(ask_on_decrypt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CipherKeyValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.CipherKeyValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.CipherKeyValue.key");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes value = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool encrypt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_encrypt();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &encrypt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ask_on_encrypt = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_ask_on_encrypt();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ask_on_encrypt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool ask_on_decrypt = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u)) {
          set_has_ask_on_decrypt();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ask_on_decrypt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes iv = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.CipherKeyValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.CipherKeyValue)
  return false;
#undef DO_
}

void CipherKeyValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.CipherKeyValue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string key = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.CipherKeyValue.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  // optional bytes value = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->value(), output);
  }

  // optional bool encrypt = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->encrypt(), output);
  }

  // optional bool ask_on_encrypt = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->ask_on_encrypt(), output);
  }

  // optional bool ask_on_decrypt = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->ask_on_decrypt(), output);
  }

  // optional bytes iv = 7;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->iv(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.CipherKeyValue)
}

::google::protobuf::uint8* CipherKeyValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.CipherKeyValue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional string key = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.CipherKeyValue.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }

  // optional bytes value = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->value(), target);
  }

  // optional bool encrypt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->encrypt(), target);
  }

  // optional bool ask_on_encrypt = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->ask_on_encrypt(), target);
  }

  // optional bool ask_on_decrypt = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->ask_on_decrypt(), target);
  }

  // optional bytes iv = 7;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->iv(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.CipherKeyValue)
  return target;
}

size_t CipherKeyValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.CipherKeyValue)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 63u) {
    // optional string key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional bytes value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->value());
    }

    // optional bytes iv = 7;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

    // optional bool encrypt = 4;
    if (has_encrypt()) {
      total_size += 1 + 1;
    }

    // optional bool ask_on_encrypt = 5;
    if (has_ask_on_encrypt()) {
      total_size += 1 + 1;
    }

    // optional bool ask_on_decrypt = 6;
    if (has_ask_on_decrypt()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CipherKeyValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.CipherKeyValue)
  GOOGLE_DCHECK_NE(&from, this);
  const CipherKeyValue* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CipherKeyValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.CipherKeyValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.CipherKeyValue)
    MergeFrom(*source);
  }
}

void CipherKeyValue::MergeFrom(const CipherKeyValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.CipherKeyValue)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_iv();
      iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
    }
    if (cached_has_bits & 0x00000008u) {
      encrypt_ = from.encrypt_;
    }
    if (cached_has_bits & 0x00000010u) {
      ask_on_encrypt_ = from.ask_on_encrypt_;
    }
    if (cached_has_bits & 0x00000020u) {
      ask_on_decrypt_ = from.ask_on_decrypt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CipherKeyValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.CipherKeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CipherKeyValue::CopyFrom(const CipherKeyValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.CipherKeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CipherKeyValue::IsInitialized() const {
  return true;
}

void CipherKeyValue::Swap(CipherKeyValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CipherKeyValue::InternalSwap(CipherKeyValue* other) {
  address_n_.InternalSwap(&other->address_n_);
  key_.Swap(&other->key_);
  value_.Swap(&other->value_);
  iv_.Swap(&other->iv_);
  std::swap(encrypt_, other->encrypt_);
  std::swap(ask_on_encrypt_, other->ask_on_encrypt_);
  std::swap(ask_on_decrypt_, other->ask_on_decrypt_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CipherKeyValue::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CipherKeyValue

// repeated uint32 address_n = 1;
int CipherKeyValue::address_n_size() const {
  return address_n_.size();
}
void CipherKeyValue::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 CipherKeyValue::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.address_n)
  return address_n_.Get(index);
}
void CipherKeyValue::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.address_n)
}
void CipherKeyValue::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.CipherKeyValue.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CipherKeyValue::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.CipherKeyValue.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CipherKeyValue::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.CipherKeyValue.address_n)
  return &address_n_;
}

// optional string key = 2;
bool CipherKeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CipherKeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void CipherKeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void CipherKeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
const ::std::string& CipherKeyValue::key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.key)
  return key_.GetNoArena();
}
void CipherKeyValue::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.key)
}
#if LANG_CXX11
void CipherKeyValue::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipherKeyValue.key)
}
#endif
void CipherKeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipherKeyValue.key)
}
void CipherKeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipherKeyValue.key)
}
::std::string* CipherKeyValue::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipherKeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* CipherKeyValue::release_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipherKeyValue.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CipherKeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipherKeyValue.key)
}

// optional bytes value = 3;
bool CipherKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CipherKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void CipherKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void CipherKeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
const ::std::string& CipherKeyValue::value() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.value)
  return value_.GetNoArena();
}
void CipherKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.value)
}
#if LANG_CXX11
void CipherKeyValue::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipherKeyValue.value)
}
#endif
void CipherKeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipherKeyValue.value)
}
void CipherKeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipherKeyValue.value)
}
::std::string* CipherKeyValue::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipherKeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* CipherKeyValue::release_value() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipherKeyValue.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CipherKeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipherKeyValue.value)
}

// optional bool encrypt = 4;
bool CipherKeyValue::has_encrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CipherKeyValue::set_has_encrypt() {
  _has_bits_[0] |= 0x00000008u;
}
void CipherKeyValue::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000008u;
}
void CipherKeyValue::clear_encrypt() {
  encrypt_ = false;
  clear_has_encrypt();
}
bool CipherKeyValue::encrypt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.encrypt)
  return encrypt_;
}
void CipherKeyValue::set_encrypt(bool value) {
  set_has_encrypt();
  encrypt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.encrypt)
}

// optional bool ask_on_encrypt = 5;
bool CipherKeyValue::has_ask_on_encrypt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CipherKeyValue::set_has_ask_on_encrypt() {
  _has_bits_[0] |= 0x00000010u;
}
void CipherKeyValue::clear_has_ask_on_encrypt() {
  _has_bits_[0] &= ~0x00000010u;
}
void CipherKeyValue::clear_ask_on_encrypt() {
  ask_on_encrypt_ = false;
  clear_has_ask_on_encrypt();
}
bool CipherKeyValue::ask_on_encrypt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.ask_on_encrypt)
  return ask_on_encrypt_;
}
void CipherKeyValue::set_ask_on_encrypt(bool value) {
  set_has_ask_on_encrypt();
  ask_on_encrypt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.ask_on_encrypt)
}

// optional bool ask_on_decrypt = 6;
bool CipherKeyValue::has_ask_on_decrypt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CipherKeyValue::set_has_ask_on_decrypt() {
  _has_bits_[0] |= 0x00000020u;
}
void CipherKeyValue::clear_has_ask_on_decrypt() {
  _has_bits_[0] &= ~0x00000020u;
}
void CipherKeyValue::clear_ask_on_decrypt() {
  ask_on_decrypt_ = false;
  clear_has_ask_on_decrypt();
}
bool CipherKeyValue::ask_on_decrypt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.ask_on_decrypt)
  return ask_on_decrypt_;
}
void CipherKeyValue::set_ask_on_decrypt(bool value) {
  set_has_ask_on_decrypt();
  ask_on_decrypt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.ask_on_decrypt)
}

// optional bytes iv = 7;
bool CipherKeyValue::has_iv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CipherKeyValue::set_has_iv() {
  _has_bits_[0] |= 0x00000004u;
}
void CipherKeyValue::clear_has_iv() {
  _has_bits_[0] &= ~0x00000004u;
}
void CipherKeyValue::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iv();
}
const ::std::string& CipherKeyValue::iv() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.iv)
  return iv_.GetNoArena();
}
void CipherKeyValue::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.iv)
}
#if LANG_CXX11
void CipherKeyValue::set_iv(::std::string&& value) {
  set_has_iv();
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipherKeyValue.iv)
}
#endif
void CipherKeyValue::set_iv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipherKeyValue.iv)
}
void CipherKeyValue::set_iv(const void* value, size_t size) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipherKeyValue.iv)
}
::std::string* CipherKeyValue::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipherKeyValue.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* CipherKeyValue::release_iv() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipherKeyValue.iv)
  clear_has_iv();
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CipherKeyValue::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipherKeyValue.iv)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CipheredKeyValue::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CipheredKeyValue::CipheredKeyValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.CipheredKeyValue)
}
CipheredKeyValue::CipheredKeyValue(const CipheredKeyValue& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.CipheredKeyValue)
}

void CipheredKeyValue::SharedCtor() {
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

CipheredKeyValue::~CipheredKeyValue() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.CipheredKeyValue)
  SharedDtor();
}

void CipheredKeyValue::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void CipheredKeyValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CipheredKeyValue::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const CipheredKeyValue& CipheredKeyValue::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

CipheredKeyValue* CipheredKeyValue::New(::google::protobuf::Arena* arena) const {
  CipheredKeyValue* n = new CipheredKeyValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CipheredKeyValue::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.CipheredKeyValue)
  if (has_value()) {
    GOOGLE_DCHECK(!value_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*value_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool CipheredKeyValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.CipheredKeyValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes value = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.CipheredKeyValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.CipheredKeyValue)
  return false;
#undef DO_
}

void CipheredKeyValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.CipheredKeyValue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes value = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.CipheredKeyValue)
}

::google::protobuf::uint8* CipheredKeyValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.CipheredKeyValue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes value = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.CipheredKeyValue)
  return target;
}

size_t CipheredKeyValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.CipheredKeyValue)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional bytes value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->value());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CipheredKeyValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.CipheredKeyValue)
  GOOGLE_DCHECK_NE(&from, this);
  const CipheredKeyValue* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const CipheredKeyValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.CipheredKeyValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.CipheredKeyValue)
    MergeFrom(*source);
  }
}

void CipheredKeyValue::MergeFrom(const CipheredKeyValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.CipheredKeyValue)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_value()) {
    set_has_value();
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
}

void CipheredKeyValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.CipheredKeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CipheredKeyValue::CopyFrom(const CipheredKeyValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.CipheredKeyValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CipheredKeyValue::IsInitialized() const {
  return true;
}

void CipheredKeyValue::Swap(CipheredKeyValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CipheredKeyValue::InternalSwap(CipheredKeyValue* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CipheredKeyValue::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CipheredKeyValue

// optional bytes value = 1;
bool CipheredKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CipheredKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void CipheredKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void CipheredKeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
const ::std::string& CipheredKeyValue::value() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipheredKeyValue.value)
  return value_.GetNoArena();
}
void CipheredKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipheredKeyValue.value)
}
#if LANG_CXX11
void CipheredKeyValue::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipheredKeyValue.value)
}
#endif
void CipheredKeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipheredKeyValue.value)
}
void CipheredKeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipheredKeyValue.value)
}
::std::string* CipheredKeyValue::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipheredKeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* CipheredKeyValue::release_value() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipheredKeyValue.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void CipheredKeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipheredKeyValue.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> EstimateTxSize::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EstimateTxSize::kOutputsCountFieldNumber;
const int EstimateTxSize::kInputsCountFieldNumber;
const int EstimateTxSize::kCoinNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EstimateTxSize::EstimateTxSize()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EstimateTxSize)
}
EstimateTxSize::EstimateTxSize(const EstimateTxSize& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  coin_name_.UnsafeSetDefault(&EstimateTxSize::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&EstimateTxSize::_default_coin_name_.get(), from.coin_name_);
  }
  ::memcpy(&outputs_count_, &from.outputs_count_,
    reinterpret_cast<char*>(&inputs_count_) -
    reinterpret_cast<char*>(&outputs_count_) + sizeof(inputs_count_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EstimateTxSize)
}

void EstimateTxSize::SharedCtor() {
  _cached_size_ = 0;
  coin_name_.UnsafeSetDefault(&EstimateTxSize::_default_coin_name_.get());
  ::memset(&outputs_count_, 0, reinterpret_cast<char*>(&inputs_count_) -
    reinterpret_cast<char*>(&outputs_count_) + sizeof(inputs_count_));
}

EstimateTxSize::~EstimateTxSize() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EstimateTxSize)
  SharedDtor();
}

void EstimateTxSize::SharedDtor() {
  coin_name_.DestroyNoArena(&EstimateTxSize::_default_coin_name_.get());
}

void EstimateTxSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EstimateTxSize::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EstimateTxSize& EstimateTxSize::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EstimateTxSize* EstimateTxSize::New(::google::protobuf::Arena* arena) const {
  EstimateTxSize* n = new EstimateTxSize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EstimateTxSize::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EstimateTxSize)
  if (has_coin_name()) {
    GOOGLE_DCHECK(!coin_name_.IsDefault(&EstimateTxSize::_default_coin_name_.get()));
    (*coin_name_.UnsafeRawStringPointer())->assign(*&EstimateTxSize::_default_coin_name_.get());
  }
  if (_has_bits_[0 / 32] & 6u) {
    ::memset(&outputs_count_, 0, reinterpret_cast<char*>(&inputs_count_) -
      reinterpret_cast<char*>(&outputs_count_) + sizeof(inputs_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EstimateTxSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EstimateTxSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 outputs_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_outputs_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 inputs_count = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_inputs_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.EstimateTxSize.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EstimateTxSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EstimateTxSize)
  return false;
#undef DO_
}

void EstimateTxSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EstimateTxSize)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 outputs_count = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->outputs_count(), output);
  }

  // required uint32 inputs_count = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->inputs_count(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.EstimateTxSize.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->coin_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EstimateTxSize)
}

::google::protobuf::uint8* EstimateTxSize::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EstimateTxSize)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 outputs_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->outputs_count(), target);
  }

  // required uint32 inputs_count = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->inputs_count(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.EstimateTxSize.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EstimateTxSize)
  return target;
}

size_t EstimateTxSize::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TrezorProtobuf.EstimateTxSize)
  size_t total_size = 0;

  if (has_outputs_count()) {
    // required uint32 outputs_count = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->outputs_count());
  }

  if (has_inputs_count()) {
    // required uint32 inputs_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->inputs_count());
  }

  return total_size;
}
size_t EstimateTxSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EstimateTxSize)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 outputs_count = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->outputs_count());

    // required uint32 inputs_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->inputs_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->coin_name());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EstimateTxSize::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EstimateTxSize)
  GOOGLE_DCHECK_NE(&from, this);
  const EstimateTxSize* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EstimateTxSize>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EstimateTxSize)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EstimateTxSize)
    MergeFrom(*source);
  }
}

void EstimateTxSize::MergeFrom(const EstimateTxSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EstimateTxSize)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&EstimateTxSize::_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      outputs_count_ = from.outputs_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      inputs_count_ = from.inputs_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EstimateTxSize::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EstimateTxSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EstimateTxSize::CopyFrom(const EstimateTxSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EstimateTxSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EstimateTxSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void EstimateTxSize::Swap(EstimateTxSize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EstimateTxSize::InternalSwap(EstimateTxSize* other) {
  coin_name_.Swap(&other->coin_name_);
  std::swap(outputs_count_, other->outputs_count_);
  std::swap(inputs_count_, other->inputs_count_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EstimateTxSize::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EstimateTxSize

// required uint32 outputs_count = 1;
bool EstimateTxSize::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EstimateTxSize::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
void EstimateTxSize::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
void EstimateTxSize::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
::google::protobuf::uint32 EstimateTxSize::outputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EstimateTxSize.outputs_count)
  return outputs_count_;
}
void EstimateTxSize::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EstimateTxSize.outputs_count)
}

// required uint32 inputs_count = 2;
bool EstimateTxSize::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EstimateTxSize::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000004u;
}
void EstimateTxSize::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000004u;
}
void EstimateTxSize::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
::google::protobuf::uint32 EstimateTxSize::inputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EstimateTxSize.inputs_count)
  return inputs_count_;
}
void EstimateTxSize::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EstimateTxSize.inputs_count)
}

// optional string coin_name = 3 [default = "Bitcoin"];
bool EstimateTxSize::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EstimateTxSize::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
void EstimateTxSize::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void EstimateTxSize::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&EstimateTxSize::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& EstimateTxSize::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EstimateTxSize.coin_name)
  return coin_name_.GetNoArena();
}
void EstimateTxSize::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EstimateTxSize::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EstimateTxSize.coin_name)
}
#if LANG_CXX11
void EstimateTxSize::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &EstimateTxSize::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EstimateTxSize.coin_name)
}
#endif
void EstimateTxSize::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&EstimateTxSize::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EstimateTxSize.coin_name)
}
void EstimateTxSize::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EstimateTxSize::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EstimateTxSize.coin_name)
}
::std::string* EstimateTxSize::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EstimateTxSize.coin_name)
  return coin_name_.MutableNoArena(&EstimateTxSize::_default_coin_name_.get());
}
::std::string* EstimateTxSize::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EstimateTxSize.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&EstimateTxSize::_default_coin_name_.get());
}
void EstimateTxSize::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&EstimateTxSize::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EstimateTxSize.coin_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxSize::kTxSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxSize::TxSize()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.TxSize)
}
TxSize::TxSize(const TxSize& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  tx_size_ = from.tx_size_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.TxSize)
}

void TxSize::SharedCtor() {
  _cached_size_ = 0;
  tx_size_ = 0u;
}

TxSize::~TxSize() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.TxSize)
  SharedDtor();
}

void TxSize::SharedDtor() {
}

void TxSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxSize::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TxSize& TxSize::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

TxSize* TxSize::New(::google::protobuf::Arena* arena) const {
  TxSize* n = new TxSize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TxSize::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.TxSize)
  tx_size_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TxSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.TxSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 tx_size = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_tx_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.TxSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.TxSize)
  return false;
#undef DO_
}

void TxSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.TxSize)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 tx_size = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tx_size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.TxSize)
}

::google::protobuf::uint8* TxSize::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.TxSize)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 tx_size = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->tx_size(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.TxSize)
  return target;
}

size_t TxSize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.TxSize)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional uint32 tx_size = 1;
  if (has_tx_size()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->tx_size());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxSize::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.TxSize)
  GOOGLE_DCHECK_NE(&from, this);
  const TxSize* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TxSize>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.TxSize)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.TxSize)
    MergeFrom(*source);
  }
}

void TxSize::MergeFrom(const TxSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.TxSize)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tx_size()) {
    set_tx_size(from.tx_size());
  }
}

void TxSize::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.TxSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxSize::CopyFrom(const TxSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.TxSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxSize::IsInitialized() const {
  return true;
}

void TxSize::Swap(TxSize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxSize::InternalSwap(TxSize* other) {
  std::swap(tx_size_, other->tx_size_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TxSize::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TxSize

// optional uint32 tx_size = 1;
bool TxSize::has_tx_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TxSize::set_has_tx_size() {
  _has_bits_[0] |= 0x00000001u;
}
void TxSize::clear_has_tx_size() {
  _has_bits_[0] &= ~0x00000001u;
}
void TxSize::clear_tx_size() {
  tx_size_ = 0u;
  clear_has_tx_size();
}
::google::protobuf::uint32 TxSize::tx_size() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxSize.tx_size)
  return tx_size_;
}
void TxSize::set_tx_size(::google::protobuf::uint32 value) {
  set_has_tx_size();
  tx_size_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxSize.tx_size)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> SignTx::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignTx::kOutputsCountFieldNumber;
const int SignTx::kInputsCountFieldNumber;
const int SignTx::kCoinNameFieldNumber;
const int SignTx::kVersionFieldNumber;
const int SignTx::kLockTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignTx::SignTx()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.SignTx)
}
SignTx::SignTx(const SignTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  coin_name_.UnsafeSetDefault(&SignTx::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&SignTx::_default_coin_name_.get(), from.coin_name_);
  }
  ::memcpy(&outputs_count_, &from.outputs_count_,
    reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&outputs_count_) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.SignTx)
}

void SignTx::SharedCtor() {
  _cached_size_ = 0;
  coin_name_.UnsafeSetDefault(&SignTx::_default_coin_name_.get());
  ::memset(&outputs_count_, 0, reinterpret_cast<char*>(&lock_time_) -
    reinterpret_cast<char*>(&outputs_count_) + sizeof(lock_time_));
  version_ = 1u;
}

SignTx::~SignTx() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.SignTx)
  SharedDtor();
}

void SignTx::SharedDtor() {
  coin_name_.DestroyNoArena(&SignTx::_default_coin_name_.get());
}

void SignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignTx::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SignTx& SignTx::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

SignTx* SignTx::New(::google::protobuf::Arena* arena) const {
  SignTx* n = new SignTx;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SignTx::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.SignTx)
  if (has_coin_name()) {
    GOOGLE_DCHECK(!coin_name_.IsDefault(&SignTx::_default_coin_name_.get()));
    (*coin_name_.UnsafeRawStringPointer())->assign(*&SignTx::_default_coin_name_.get());
  }
  if (_has_bits_[0 / 32] & 30u) {
    ::memset(&outputs_count_, 0, reinterpret_cast<char*>(&lock_time_) -
      reinterpret_cast<char*>(&outputs_count_) + sizeof(lock_time_));
    version_ = 1u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.SignTx)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 outputs_count = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_outputs_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 inputs_count = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_inputs_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.SignTx.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 version = 4 [default = 1];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lock_time = 5 [default = 0];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_lock_time();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.SignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.SignTx)
  return false;
#undef DO_
}

void SignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.SignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 outputs_count = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->outputs_count(), output);
  }

  // required uint32 inputs_count = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->inputs_count(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignTx.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->coin_name(), output);
  }

  // optional uint32 version = 4 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->version(), output);
  }

  // optional uint32 lock_time = 5 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->lock_time(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.SignTx)
}

::google::protobuf::uint8* SignTx::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.SignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 outputs_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->outputs_count(), target);
  }

  // required uint32 inputs_count = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->inputs_count(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignTx.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  // optional uint32 version = 4 [default = 1];
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->version(), target);
  }

  // optional uint32 lock_time = 5 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->lock_time(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.SignTx)
  return target;
}

size_t SignTx::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:TrezorProtobuf.SignTx)
  size_t total_size = 0;

  if (has_outputs_count()) {
    // required uint32 outputs_count = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->outputs_count());
  }

  if (has_inputs_count()) {
    // required uint32 inputs_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->inputs_count());
  }

  return total_size;
}
size_t SignTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.SignTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required uint32 outputs_count = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->outputs_count());

    // required uint32 inputs_count = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->inputs_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->coin_name());
  }

  if (_has_bits_[0 / 32] & 24u) {
    // optional uint32 lock_time = 5 [default = 0];
    if (has_lock_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }

    // optional uint32 version = 4 [default = 1];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.SignTx)
  GOOGLE_DCHECK_NE(&from, this);
  const SignTx* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SignTx>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.SignTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.SignTx)
    MergeFrom(*source);
  }
}

void SignTx::MergeFrom(const SignTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.SignTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&SignTx::_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      outputs_count_ = from.outputs_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      inputs_count_ = from.inputs_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      lock_time_ = from.lock_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SignTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.SignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignTx::CopyFrom(const SignTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.SignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignTx::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void SignTx::Swap(SignTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignTx::InternalSwap(SignTx* other) {
  coin_name_.Swap(&other->coin_name_);
  std::swap(outputs_count_, other->outputs_count_);
  std::swap(inputs_count_, other->inputs_count_);
  std::swap(lock_time_, other->lock_time_);
  std::swap(version_, other->version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SignTx::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SignTx

// required uint32 outputs_count = 1;
bool SignTx::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SignTx::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
void SignTx::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
void SignTx::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
::google::protobuf::uint32 SignTx::outputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.outputs_count)
  return outputs_count_;
}
void SignTx::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.outputs_count)
}

// required uint32 inputs_count = 2;
bool SignTx::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SignTx::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000004u;
}
void SignTx::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000004u;
}
void SignTx::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
::google::protobuf::uint32 SignTx::inputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.inputs_count)
  return inputs_count_;
}
void SignTx::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.inputs_count)
}

// optional string coin_name = 3 [default = "Bitcoin"];
bool SignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SignTx::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SignTx::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SignTx::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&SignTx::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& SignTx::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.coin_name)
  return coin_name_.GetNoArena();
}
void SignTx::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignTx::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.coin_name)
}
#if LANG_CXX11
void SignTx::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &SignTx::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignTx.coin_name)
}
#endif
void SignTx::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&SignTx::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignTx.coin_name)
}
void SignTx::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignTx::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignTx.coin_name)
}
::std::string* SignTx::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignTx.coin_name)
  return coin_name_.MutableNoArena(&SignTx::_default_coin_name_.get());
}
::std::string* SignTx::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignTx.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&SignTx::_default_coin_name_.get());
}
void SignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&SignTx::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignTx.coin_name)
}

// optional uint32 version = 4 [default = 1];
bool SignTx::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SignTx::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
void SignTx::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
void SignTx::clear_version() {
  version_ = 1u;
  clear_has_version();
}
::google::protobuf::uint32 SignTx::version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.version)
  return version_;
}
void SignTx::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.version)
}

// optional uint32 lock_time = 5 [default = 0];
bool SignTx::has_lock_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SignTx::set_has_lock_time() {
  _has_bits_[0] |= 0x00000008u;
}
void SignTx::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000008u;
}
void SignTx::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
::google::protobuf::uint32 SignTx::lock_time() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.lock_time)
  return lock_time_;
}
void SignTx::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.lock_time)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

::google::protobuf::internal::ExplicitlyConstructed< ::std::string> SimpleSignTx::_default_coin_name_;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimpleSignTx::kInputsFieldNumber;
const int SimpleSignTx::kOutputsFieldNumber;
const int SimpleSignTx::kTransactionsFieldNumber;
const int SimpleSignTx::kCoinNameFieldNumber;
const int SimpleSignTx::kVersionFieldNumber;
const int SimpleSignTx::kLockTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimpleSignTx::SimpleSignTx()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.SimpleSignTx)
}
SimpleSignTx::SimpleSignTx(const SimpleSignTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      inputs_(from.inputs_),
      outputs_(from.outputs_),
      transactions_(from.transactions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  coin_name_.UnsafeSetDefault(&SimpleSignTx::_default_coin_name_.get());
  if (from.has_coin_name()) {
    coin_name_.AssignWithDefault(&SimpleSignTx::_default_coin_name_.get(), from.coin_name_);
  }
  ::memcpy(&lock_time_, &from.lock_time_,
    reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&lock_time_) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.SimpleSignTx)
}

void SimpleSignTx::SharedCtor() {
  _cached_size_ = 0;
  coin_name_.UnsafeSetDefault(&SimpleSignTx::_default_coin_name_.get());
  lock_time_ = 0u;
  version_ = 1u;
}

SimpleSignTx::~SimpleSignTx() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.SimpleSignTx)
  SharedDtor();
}

void SimpleSignTx::SharedDtor() {
  coin_name_.DestroyNoArena(&SimpleSignTx::_default_coin_name_.get());
}

void SimpleSignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SimpleSignTx::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SimpleSignTx& SimpleSignTx::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

SimpleSignTx* SimpleSignTx::New(::google::protobuf::Arena* arena) const {
  SimpleSignTx* n = new SimpleSignTx;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SimpleSignTx::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.SimpleSignTx)
  inputs_.Clear();
  outputs_.Clear();
  transactions_.Clear();
  if (has_coin_name()) {
    GOOGLE_DCHECK(!coin_name_.IsDefault(&SimpleSignTx::_default_coin_name_.get()));
    (*coin_name_.UnsafeRawStringPointer())->assign(*&SimpleSignTx::_default_coin_name_.get());
  }
  if (_has_bits_[0 / 32] & 6u) {
    lock_time_ = 0u;
    version_ = 1u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SimpleSignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.SimpleSignTx)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .TrezorProtobuf.TxInputType inputs = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inputs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .TrezorProtobuf.TxOutputType outputs = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_outputs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .TrezorProtobuf.TransactionType transactions = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transactions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.SimpleSignTx.coin_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 version = 5 [default = 1];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 lock_time = 6 [default = 0];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u)) {
          set_has_lock_time();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.SimpleSignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.SimpleSignTx)
  return false;
#undef DO_
}

void SimpleSignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.SimpleSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TrezorProtobuf.TxInputType inputs = 1;
  for (unsigned int i = 0, n = this->inputs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inputs(i), output);
  }

  // repeated .TrezorProtobuf.TxOutputType outputs = 2;
  for (unsigned int i = 0, n = this->outputs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->outputs(i), output);
  }

  // repeated .TrezorProtobuf.TransactionType transactions = 3;
  for (unsigned int i = 0, n = this->transactions_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->transactions(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SimpleSignTx.coin_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->coin_name(), output);
  }

  // optional uint32 version = 5 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->version(), output);
  }

  // optional uint32 lock_time = 6 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->lock_time(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.SimpleSignTx)
}

::google::protobuf::uint8* SimpleSignTx::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.SimpleSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .TrezorProtobuf.TxInputType inputs = 1;
  for (unsigned int i = 0, n = this->inputs_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->inputs(i), deterministic, target);
  }

  // repeated .TrezorProtobuf.TxOutputType outputs = 2;
  for (unsigned int i = 0, n = this->outputs_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->outputs(i), deterministic, target);
  }

  // repeated .TrezorProtobuf.TransactionType transactions = 3;
  for (unsigned int i = 0, n = this->transactions_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->transactions(i), deterministic, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string coin_name = 4 [default = "Bitcoin"];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SimpleSignTx.coin_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  // optional uint32 version = 5 [default = 1];
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->version(), target);
  }

  // optional uint32 lock_time = 6 [default = 0];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->lock_time(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.SimpleSignTx)
  return target;
}

size_t SimpleSignTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.SimpleSignTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated .TrezorProtobuf.TxInputType inputs = 1;
  {
    unsigned int count = this->inputs_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inputs(i));
    }
  }

  // repeated .TrezorProtobuf.TxOutputType outputs = 2;
  {
    unsigned int count = this->outputs_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->outputs(i));
    }
  }

  // repeated .TrezorProtobuf.TransactionType transactions = 3;
  {
    unsigned int count = this->transactions_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->transactions(i));
    }
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional string coin_name = 4 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional uint32 lock_time = 6 [default = 0];
    if (has_lock_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }

    // optional uint32 version = 5 [default = 1];
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SimpleSignTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.SimpleSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  const SimpleSignTx* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SimpleSignTx>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.SimpleSignTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.SimpleSignTx)
    MergeFrom(*source);
  }
}

void SimpleSignTx::MergeFrom(const SimpleSignTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.SimpleSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  transactions_.MergeFrom(from.transactions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_coin_name();
      coin_name_.AssignWithDefault(&SimpleSignTx::_default_coin_name_.get(), from.coin_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      lock_time_ = from.lock_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SimpleSignTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.SimpleSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleSignTx::CopyFrom(const SimpleSignTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.SimpleSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleSignTx::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->inputs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->outputs())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->transactions())) return false;
  return true;
}

void SimpleSignTx::Swap(SimpleSignTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimpleSignTx::InternalSwap(SimpleSignTx* other) {
  inputs_.InternalSwap(&other->inputs_);
  outputs_.InternalSwap(&other->outputs_);
  transactions_.InternalSwap(&other->transactions_);
  coin_name_.Swap(&other->coin_name_);
  std::swap(lock_time_, other->lock_time_);
  std::swap(version_, other->version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SimpleSignTx::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SimpleSignTx

// repeated .TrezorProtobuf.TxInputType inputs = 1;
int SimpleSignTx::inputs_size() const {
  return inputs_.size();
}
void SimpleSignTx::clear_inputs() {
  inputs_.Clear();
}
const ::TrezorProtobuf::TxInputType& SimpleSignTx::inputs(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_.Get(index);
}
::TrezorProtobuf::TxInputType* SimpleSignTx::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_.Mutable(index);
}
::TrezorProtobuf::TxInputType* SimpleSignTx::add_inputs() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_.Add();
}
::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >*
SimpleSignTx::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SimpleSignTx.inputs)
  return &inputs_;
}
const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >&
SimpleSignTx::inputs() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_;
}

// repeated .TrezorProtobuf.TxOutputType outputs = 2;
int SimpleSignTx::outputs_size() const {
  return outputs_.size();
}
void SimpleSignTx::clear_outputs() {
  outputs_.Clear();
}
const ::TrezorProtobuf::TxOutputType& SimpleSignTx::outputs(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_.Get(index);
}
::TrezorProtobuf::TxOutputType* SimpleSignTx::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_.Mutable(index);
}
::TrezorProtobuf::TxOutputType* SimpleSignTx::add_outputs() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_.Add();
}
::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >*
SimpleSignTx::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SimpleSignTx.outputs)
  return &outputs_;
}
const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >&
SimpleSignTx::outputs() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_;
}

// repeated .TrezorProtobuf.TransactionType transactions = 3;
int SimpleSignTx::transactions_size() const {
  return transactions_.size();
}
void SimpleSignTx::clear_transactions() {
  transactions_.Clear();
}
const ::TrezorProtobuf::TransactionType& SimpleSignTx::transactions(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_.Get(index);
}
::TrezorProtobuf::TransactionType* SimpleSignTx::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_.Mutable(index);
}
::TrezorProtobuf::TransactionType* SimpleSignTx::add_transactions() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_.Add();
}
::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TransactionType >*
SimpleSignTx::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SimpleSignTx.transactions)
  return &transactions_;
}
const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TransactionType >&
SimpleSignTx::transactions() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_;
}

// optional string coin_name = 4 [default = "Bitcoin"];
bool SimpleSignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SimpleSignTx::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
void SimpleSignTx::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void SimpleSignTx::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&SimpleSignTx::_default_coin_name_.get());
  clear_has_coin_name();
}
const ::std::string& SimpleSignTx::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.coin_name)
  return coin_name_.GetNoArena();
}
void SimpleSignTx::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SimpleSignTx::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SimpleSignTx.coin_name)
}
#if LANG_CXX11
void SimpleSignTx::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &SimpleSignTx::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SimpleSignTx.coin_name)
}
#endif
void SimpleSignTx::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&SimpleSignTx::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SimpleSignTx.coin_name)
}
void SimpleSignTx::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SimpleSignTx::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SimpleSignTx.coin_name)
}
::std::string* SimpleSignTx::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.coin_name)
  return coin_name_.MutableNoArena(&SimpleSignTx::_default_coin_name_.get());
}
::std::string* SimpleSignTx::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SimpleSignTx.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&SimpleSignTx::_default_coin_name_.get());
}
void SimpleSignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&SimpleSignTx::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SimpleSignTx.coin_name)
}

// optional uint32 version = 5 [default = 1];
bool SimpleSignTx::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SimpleSignTx::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
void SimpleSignTx::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
void SimpleSignTx::clear_version() {
  version_ = 1u;
  clear_has_version();
}
::google::protobuf::uint32 SimpleSignTx::version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.version)
  return version_;
}
void SimpleSignTx::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SimpleSignTx.version)
}

// optional uint32 lock_time = 6 [default = 0];
bool SimpleSignTx::has_lock_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SimpleSignTx::set_has_lock_time() {
  _has_bits_[0] |= 0x00000002u;
}
void SimpleSignTx::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000002u;
}
void SimpleSignTx::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
::google::protobuf::uint32 SimpleSignTx::lock_time() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.lock_time)
  return lock_time_;
}
void SimpleSignTx::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SimpleSignTx.lock_time)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxRequest::kRequestTypeFieldNumber;
const int TxRequest::kDetailsFieldNumber;
const int TxRequest::kSerializedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxRequest::TxRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.TxRequest)
}
TxRequest::TxRequest(const TxRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_details()) {
    details_ = new ::TrezorProtobuf::TxRequestDetailsType(*from.details_);
  } else {
    details_ = NULL;
  }
  if (from.has_serialized()) {
    serialized_ = new ::TrezorProtobuf::TxRequestSerializedType(*from.serialized_);
  } else {
    serialized_ = NULL;
  }
  request_type_ = from.request_type_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.TxRequest)
}

void TxRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&details_, 0, reinterpret_cast<char*>(&request_type_) -
    reinterpret_cast<char*>(&details_) + sizeof(request_type_));
}

TxRequest::~TxRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.TxRequest)
  SharedDtor();
}

void TxRequest::SharedDtor() {
  if (this != internal_default_instance()) {
    delete details_;
  }
  if (this != internal_default_instance()) {
    delete serialized_;
  }
}

void TxRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TxRequest& TxRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

TxRequest* TxRequest::New(::google::protobuf::Arena* arena) const {
  TxRequest* n = new TxRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TxRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.TxRequest)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_details()) {
      GOOGLE_DCHECK(details_ != NULL);
      details_->::TrezorProtobuf::TxRequestDetailsType::Clear();
    }
    if (has_serialized()) {
      GOOGLE_DCHECK(serialized_ != NULL);
      serialized_->::TrezorProtobuf::TxRequestSerializedType::Clear();
    }
  }
  request_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.TxRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.RequestType request_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TrezorProtobuf::RequestType_IsValid(value)) {
            set_request_type(static_cast< ::TrezorProtobuf::RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .TrezorProtobuf.TxRequestDetailsType details = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_details()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .TrezorProtobuf.TxRequestSerializedType serialized = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_serialized()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.TxRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.TxRequest)
  return false;
#undef DO_
}

void TxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.TxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.RequestType request_type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->request_type(), output);
  }

  // optional .TrezorProtobuf.TxRequestDetailsType details = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->details_, output);
  }

  // optional .TrezorProtobuf.TxRequestSerializedType serialized = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->serialized_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.TxRequest)
}

::google::protobuf::uint8* TxRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.TxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.RequestType request_type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->request_type(), target);
  }

  // optional .TrezorProtobuf.TxRequestDetailsType details = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->details_, deterministic, target);
  }

  // optional .TrezorProtobuf.TxRequestSerializedType serialized = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->serialized_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.TxRequest)
  return target;
}

size_t TxRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.TxRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional .TrezorProtobuf.TxRequestDetailsType details = 2;
    if (has_details()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->details_);
    }

    // optional .TrezorProtobuf.TxRequestSerializedType serialized = 3;
    if (has_serialized()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->serialized_);
    }

    // optional .TrezorProtobuf.RequestType request_type = 1;
    if (has_request_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->request_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.TxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const TxRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TxRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.TxRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.TxRequest)
    MergeFrom(*source);
  }
}

void TxRequest::MergeFrom(const TxRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.TxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_details()->::TrezorProtobuf::TxRequestDetailsType::MergeFrom(from.details());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_serialized()->::TrezorProtobuf::TxRequestSerializedType::MergeFrom(from.serialized());
    }
    if (cached_has_bits & 0x00000004u) {
      request_type_ = from.request_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TxRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.TxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest::CopyFrom(const TxRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.TxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest::IsInitialized() const {
  return true;
}

void TxRequest::Swap(TxRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxRequest::InternalSwap(TxRequest* other) {
  std::swap(details_, other->details_);
  std::swap(serialized_, other->serialized_);
  std::swap(request_type_, other->request_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TxRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TxRequest

// optional .TrezorProtobuf.RequestType request_type = 1;
bool TxRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TxRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000004u;
}
void TxRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void TxRequest::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
::TrezorProtobuf::RequestType TxRequest::request_type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequest.request_type)
  return static_cast< ::TrezorProtobuf::RequestType >(request_type_);
}
void TxRequest::set_request_type(::TrezorProtobuf::RequestType value) {
  assert(::TrezorProtobuf::RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequest.request_type)
}

// optional .TrezorProtobuf.TxRequestDetailsType details = 2;
bool TxRequest::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TxRequest::set_has_details() {
  _has_bits_[0] |= 0x00000001u;
}
void TxRequest::clear_has_details() {
  _has_bits_[0] &= ~0x00000001u;
}
void TxRequest::clear_details() {
  if (details_ != NULL) details_->::TrezorProtobuf::TxRequestDetailsType::Clear();
  clear_has_details();
}
const ::TrezorProtobuf::TxRequestDetailsType& TxRequest::details() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequest.details)
  return details_ != NULL ? *details_
                         : *::TrezorProtobuf::TxRequestDetailsType::internal_default_instance();
}
::TrezorProtobuf::TxRequestDetailsType* TxRequest::mutable_details() {
  set_has_details();
  if (details_ == NULL) {
    details_ = new ::TrezorProtobuf::TxRequestDetailsType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxRequest.details)
  return details_;
}
::TrezorProtobuf::TxRequestDetailsType* TxRequest::release_details() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxRequest.details)
  clear_has_details();
  ::TrezorProtobuf::TxRequestDetailsType* temp = details_;
  details_ = NULL;
  return temp;
}
void TxRequest::set_allocated_details(::TrezorProtobuf::TxRequestDetailsType* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxRequest.details)
}

// optional .TrezorProtobuf.TxRequestSerializedType serialized = 3;
bool TxRequest::has_serialized() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TxRequest::set_has_serialized() {
  _has_bits_[0] |= 0x00000002u;
}
void TxRequest::clear_has_serialized() {
  _has_bits_[0] &= ~0x00000002u;
}
void TxRequest::clear_serialized() {
  if (serialized_ != NULL) serialized_->::TrezorProtobuf::TxRequestSerializedType::Clear();
  clear_has_serialized();
}
const ::TrezorProtobuf::TxRequestSerializedType& TxRequest::serialized() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequest.serialized)
  return serialized_ != NULL ? *serialized_
                         : *::TrezorProtobuf::TxRequestSerializedType::internal_default_instance();
}
::TrezorProtobuf::TxRequestSerializedType* TxRequest::mutable_serialized() {
  set_has_serialized();
  if (serialized_ == NULL) {
    serialized_ = new ::TrezorProtobuf::TxRequestSerializedType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxRequest.serialized)
  return serialized_;
}
::TrezorProtobuf::TxRequestSerializedType* TxRequest::release_serialized() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxRequest.serialized)
  clear_has_serialized();
  ::TrezorProtobuf::TxRequestSerializedType* temp = serialized_;
  serialized_ = NULL;
  return temp;
}
void TxRequest::set_allocated_serialized(::TrezorProtobuf::TxRequestSerializedType* serialized) {
  delete serialized_;
  serialized_ = serialized;
  if (serialized) {
    set_has_serialized();
  } else {
    clear_has_serialized();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxRequest.serialized)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TxAck::kTxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TxAck::TxAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.TxAck)
}
TxAck::TxAck(const TxAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_tx()) {
    tx_ = new ::TrezorProtobuf::TransactionType(*from.tx_);
  } else {
    tx_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.TxAck)
}

void TxAck::SharedCtor() {
  _cached_size_ = 0;
  tx_ = NULL;
}

TxAck::~TxAck() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.TxAck)
  SharedDtor();
}

void TxAck::SharedDtor() {
  if (this != internal_default_instance()) {
    delete tx_;
  }
}

void TxAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxAck::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TxAck& TxAck::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

TxAck* TxAck::New(::google::protobuf::Arena* arena) const {
  TxAck* n = new TxAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TxAck::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.TxAck)
  if (has_tx()) {
    GOOGLE_DCHECK(tx_ != NULL);
    tx_->::TrezorProtobuf::TransactionType::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TxAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.TxAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.TransactionType tx = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tx()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.TxAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.TxAck)
  return false;
#undef DO_
}

void TxAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.TxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.TransactionType tx = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->tx_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.TxAck)
}

::google::protobuf::uint8* TxAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.TxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.TransactionType tx = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->tx_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.TxAck)
  return target;
}

size_t TxAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.TxAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional .TrezorProtobuf.TransactionType tx = 1;
  if (has_tx()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->tx_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.TxAck)
  GOOGLE_DCHECK_NE(&from, this);
  const TxAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TxAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.TxAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.TxAck)
    MergeFrom(*source);
  }
}

void TxAck::MergeFrom(const TxAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.TxAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_tx()) {
    mutable_tx()->::TrezorProtobuf::TransactionType::MergeFrom(from.tx());
  }
}

void TxAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.TxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck::CopyFrom(const TxAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.TxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck::IsInitialized() const {
  if (has_tx()) {
    if (!this->tx_->IsInitialized()) return false;
  }
  return true;
}

void TxAck::Swap(TxAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TxAck::InternalSwap(TxAck* other) {
  std::swap(tx_, other->tx_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TxAck::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TxAck

// optional .TrezorProtobuf.TransactionType tx = 1;
bool TxAck::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TxAck::set_has_tx() {
  _has_bits_[0] |= 0x00000001u;
}
void TxAck::clear_has_tx() {
  _has_bits_[0] &= ~0x00000001u;
}
void TxAck::clear_tx() {
  if (tx_ != NULL) tx_->::TrezorProtobuf::TransactionType::Clear();
  clear_has_tx();
}
const ::TrezorProtobuf::TransactionType& TxAck::tx() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxAck.tx)
  return tx_ != NULL ? *tx_
                         : *::TrezorProtobuf::TransactionType::internal_default_instance();
}
::TrezorProtobuf::TransactionType* TxAck::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) {
    tx_ = new ::TrezorProtobuf::TransactionType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxAck.tx)
  return tx_;
}
::TrezorProtobuf::TransactionType* TxAck::release_tx() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxAck.tx)
  clear_has_tx();
  ::TrezorProtobuf::TransactionType* temp = tx_;
  tx_ = NULL;
  return temp;
}
void TxAck::set_allocated_tx(::TrezorProtobuf::TransactionType* tx) {
  delete tx_;
  tx_ = tx;
  if (tx) {
    set_has_tx();
  } else {
    clear_has_tx();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxAck.tx)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumSignTx::kAddressNFieldNumber;
const int EthereumSignTx::kNonceFieldNumber;
const int EthereumSignTx::kGasPriceFieldNumber;
const int EthereumSignTx::kGasLimitFieldNumber;
const int EthereumSignTx::kToFieldNumber;
const int EthereumSignTx::kValueFieldNumber;
const int EthereumSignTx::kDataInitialChunkFieldNumber;
const int EthereumSignTx::kDataLengthFieldNumber;
const int EthereumSignTx::kChainIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumSignTx::EthereumSignTx()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EthereumSignTx)
}
EthereumSignTx::EthereumSignTx(const EthereumSignTx& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      address_n_(from.address_n_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nonce()) {
    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  gas_price_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_gas_price()) {
    gas_price_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_price_);
  }
  gas_limit_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_gas_limit()) {
    gas_limit_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_limit_);
  }
  to_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_to()) {
    to_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.to_);
  }
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_value()) {
    value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
  }
  data_initial_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_initial_chunk()) {
    data_initial_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_initial_chunk_);
  }
  ::memcpy(&data_length_, &from.data_length_,
    reinterpret_cast<char*>(&chain_id_) -
    reinterpret_cast<char*>(&data_length_) + sizeof(chain_id_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EthereumSignTx)
}

void EthereumSignTx::SharedCtor() {
  _cached_size_ = 0;
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_price_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_limit_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  to_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_initial_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_length_, 0, reinterpret_cast<char*>(&chain_id_) -
    reinterpret_cast<char*>(&data_length_) + sizeof(chain_id_));
}

EthereumSignTx::~EthereumSignTx() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EthereumSignTx)
  SharedDtor();
}

void EthereumSignTx::SharedDtor() {
  nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_price_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gas_limit_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  to_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_initial_chunk_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumSignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EthereumSignTx::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumSignTx& EthereumSignTx::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EthereumSignTx* EthereumSignTx::New(::google::protobuf::Arena* arena) const {
  EthereumSignTx* n = new EthereumSignTx;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EthereumSignTx::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EthereumSignTx)
  address_n_.Clear();
  if (_has_bits_[0 / 32] & 63u) {
    if (has_nonce()) {
      GOOGLE_DCHECK(!nonce_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nonce_.UnsafeRawStringPointer())->clear();
    }
    if (has_gas_price()) {
      GOOGLE_DCHECK(!gas_price_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*gas_price_.UnsafeRawStringPointer())->clear();
    }
    if (has_gas_limit()) {
      GOOGLE_DCHECK(!gas_limit_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*gas_limit_.UnsafeRawStringPointer())->clear();
    }
    if (has_to()) {
      GOOGLE_DCHECK(!to_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*to_.UnsafeRawStringPointer())->clear();
    }
    if (has_value()) {
      GOOGLE_DCHECK(!value_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*value_.UnsafeRawStringPointer())->clear();
    }
    if (has_data_initial_chunk()) {
      GOOGLE_DCHECK(!data_initial_chunk_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*data_initial_chunk_.UnsafeRawStringPointer())->clear();
    }
  }
  if (_has_bits_[0 / 32] & 192u) {
    ::memset(&data_length_, 0, reinterpret_cast<char*>(&chain_id_) -
      reinterpret_cast<char*>(&data_length_) + sizeof(chain_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumSignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EthereumSignTx)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_address_n())));
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nonce = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes gas_price = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gas_price()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes gas_limit = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gas_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes to = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_to()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes value = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data_initial_chunk = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_initial_chunk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 data_length = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u)) {
          set_has_data_length();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 chain_id = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u)) {
          set_has_chain_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chain_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EthereumSignTx)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EthereumSignTx)
  return false;
#undef DO_
}

void EthereumSignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  for (int i = 0, n = this->address_n_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // optional bytes gas_price = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->gas_price(), output);
  }

  // optional bytes gas_limit = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->gas_limit(), output);
  }

  // optional bytes to = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->to(), output);
  }

  // optional bytes value = 6;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->value(), output);
  }

  // optional bytes data_initial_chunk = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->data_initial_chunk(), output);
  }

  // optional uint32 data_length = 8;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->data_length(), output);
  }

  // optional uint32 chain_id = 9;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->chain_id(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EthereumSignTx)
}

::google::protobuf::uint8* EthereumSignTx::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EthereumSignTx)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 address_n = 1;
  target = ::google::protobuf::internal::WireFormatLite::
    WriteUInt32ToArray(1, this->address_n_, target);

  cached_has_bits = _has_bits_[0];
  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->nonce(), target);
  }

  // optional bytes gas_price = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->gas_price(), target);
  }

  // optional bytes gas_limit = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->gas_limit(), target);
  }

  // optional bytes to = 5;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->to(), target);
  }

  // optional bytes value = 6;
  if (cached_has_bits & 0x00000010u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->value(), target);
  }

  // optional bytes data_initial_chunk = 7;
  if (cached_has_bits & 0x00000020u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->data_initial_chunk(), target);
  }

  // optional uint32 data_length = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->data_length(), target);
  }

  // optional uint32 chain_id = 9;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->chain_id(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EthereumSignTx)
  return target;
}

size_t EthereumSignTx::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EthereumSignTx)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // repeated uint32 address_n = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->address_n_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->address_n_size());
    total_size += data_size;
  }

  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // optional bytes gas_price = 3;
    if (has_gas_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gas_price());
    }

    // optional bytes gas_limit = 4;
    if (has_gas_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gas_limit());
    }

    // optional bytes to = 5;
    if (has_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->to());
    }

    // optional bytes value = 6;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->value());
    }

    // optional bytes data_initial_chunk = 7;
    if (has_data_initial_chunk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data_initial_chunk());
    }

    // optional uint32 data_length = 8;
    if (has_data_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_length());
    }

    // optional uint32 chain_id = 9;
    if (has_chain_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chain_id());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthereumSignTx::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EthereumSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumSignTx* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumSignTx>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EthereumSignTx)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EthereumSignTx)
    MergeFrom(*source);
  }
}

void EthereumSignTx::MergeFrom(const EthereumSignTx& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EthereumSignTx)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  address_n_.MergeFrom(from.address_n_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_nonce();
      nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_gas_price();
      gas_price_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_price_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_gas_limit();
      gas_limit_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gas_limit_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_to();
      to_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.to_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (cached_has_bits & 0x00000020u) {
      set_has_data_initial_chunk();
      data_initial_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_initial_chunk_);
    }
    if (cached_has_bits & 0x00000040u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000080u) {
      chain_id_ = from.chain_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EthereumSignTx::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EthereumSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumSignTx::CopyFrom(const EthereumSignTx& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EthereumSignTx)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumSignTx::IsInitialized() const {
  return true;
}

void EthereumSignTx::Swap(EthereumSignTx* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumSignTx::InternalSwap(EthereumSignTx* other) {
  address_n_.InternalSwap(&other->address_n_);
  nonce_.Swap(&other->nonce_);
  gas_price_.Swap(&other->gas_price_);
  gas_limit_.Swap(&other->gas_limit_);
  to_.Swap(&other->to_);
  value_.Swap(&other->value_);
  data_initial_chunk_.Swap(&other->data_initial_chunk_);
  std::swap(data_length_, other->data_length_);
  std::swap(chain_id_, other->chain_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EthereumSignTx::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EthereumSignTx

// repeated uint32 address_n = 1;
int EthereumSignTx::address_n_size() const {
  return address_n_.size();
}
void EthereumSignTx::clear_address_n() {
  address_n_.Clear();
}
::google::protobuf::uint32 EthereumSignTx::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.address_n)
  return address_n_.Get(index);
}
void EthereumSignTx::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.address_n)
}
void EthereumSignTx::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.EthereumSignTx.address_n)
}
const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumSignTx::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.EthereumSignTx.address_n)
  return address_n_;
}
::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumSignTx::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.EthereumSignTx.address_n)
  return &address_n_;
}

// optional bytes nonce = 2;
bool EthereumSignTx::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EthereumSignTx::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
void EthereumSignTx::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
void EthereumSignTx::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
const ::std::string& EthereumSignTx::nonce() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.nonce)
  return nonce_.GetNoArena();
}
void EthereumSignTx::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.nonce)
}
#if LANG_CXX11
void EthereumSignTx::set_nonce(::std::string&& value) {
  set_has_nonce();
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.nonce)
}
#endif
void EthereumSignTx::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.nonce)
}
void EthereumSignTx::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.nonce)
}
::std::string* EthereumSignTx::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumSignTx::release_nonce() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumSignTx::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.nonce)
}

// optional bytes gas_price = 3;
bool EthereumSignTx::has_gas_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EthereumSignTx::set_has_gas_price() {
  _has_bits_[0] |= 0x00000002u;
}
void EthereumSignTx::clear_has_gas_price() {
  _has_bits_[0] &= ~0x00000002u;
}
void EthereumSignTx::clear_gas_price() {
  gas_price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gas_price();
}
const ::std::string& EthereumSignTx::gas_price() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.gas_price)
  return gas_price_.GetNoArena();
}
void EthereumSignTx::set_gas_price(const ::std::string& value) {
  set_has_gas_price();
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.gas_price)
}
#if LANG_CXX11
void EthereumSignTx::set_gas_price(::std::string&& value) {
  set_has_gas_price();
  gas_price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.gas_price)
}
#endif
void EthereumSignTx::set_gas_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gas_price();
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.gas_price)
}
void EthereumSignTx::set_gas_price(const void* value, size_t size) {
  set_has_gas_price();
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.gas_price)
}
::std::string* EthereumSignTx::mutable_gas_price() {
  set_has_gas_price();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.gas_price)
  return gas_price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumSignTx::release_gas_price() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.gas_price)
  clear_has_gas_price();
  return gas_price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumSignTx::set_allocated_gas_price(::std::string* gas_price) {
  if (gas_price != NULL) {
    set_has_gas_price();
  } else {
    clear_has_gas_price();
  }
  gas_price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_price);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.gas_price)
}

// optional bytes gas_limit = 4;
bool EthereumSignTx::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EthereumSignTx::set_has_gas_limit() {
  _has_bits_[0] |= 0x00000004u;
}
void EthereumSignTx::clear_has_gas_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
void EthereumSignTx::clear_gas_limit() {
  gas_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gas_limit();
}
const ::std::string& EthereumSignTx::gas_limit() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.gas_limit)
  return gas_limit_.GetNoArena();
}
void EthereumSignTx::set_gas_limit(const ::std::string& value) {
  set_has_gas_limit();
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.gas_limit)
}
#if LANG_CXX11
void EthereumSignTx::set_gas_limit(::std::string&& value) {
  set_has_gas_limit();
  gas_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.gas_limit)
}
#endif
void EthereumSignTx::set_gas_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gas_limit();
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.gas_limit)
}
void EthereumSignTx::set_gas_limit(const void* value, size_t size) {
  set_has_gas_limit();
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.gas_limit)
}
::std::string* EthereumSignTx::mutable_gas_limit() {
  set_has_gas_limit();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.gas_limit)
  return gas_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumSignTx::release_gas_limit() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.gas_limit)
  clear_has_gas_limit();
  return gas_limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumSignTx::set_allocated_gas_limit(::std::string* gas_limit) {
  if (gas_limit != NULL) {
    set_has_gas_limit();
  } else {
    clear_has_gas_limit();
  }
  gas_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_limit);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.gas_limit)
}

// optional bytes to = 5;
bool EthereumSignTx::has_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void EthereumSignTx::set_has_to() {
  _has_bits_[0] |= 0x00000008u;
}
void EthereumSignTx::clear_has_to() {
  _has_bits_[0] &= ~0x00000008u;
}
void EthereumSignTx::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
const ::std::string& EthereumSignTx::to() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.to)
  return to_.GetNoArena();
}
void EthereumSignTx::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.to)
}
#if LANG_CXX11
void EthereumSignTx::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.to)
}
#endif
void EthereumSignTx::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.to)
}
void EthereumSignTx::set_to(const void* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.to)
}
::std::string* EthereumSignTx::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumSignTx::release_to() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.to)
  clear_has_to();
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumSignTx::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.to)
}

// optional bytes value = 6;
bool EthereumSignTx::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void EthereumSignTx::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
void EthereumSignTx::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
void EthereumSignTx::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
const ::std::string& EthereumSignTx::value() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.value)
  return value_.GetNoArena();
}
void EthereumSignTx::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.value)
}
#if LANG_CXX11
void EthereumSignTx::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.value)
}
#endif
void EthereumSignTx::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.value)
}
void EthereumSignTx::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.value)
}
::std::string* EthereumSignTx::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumSignTx::release_value() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumSignTx::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.value)
}

// optional bytes data_initial_chunk = 7;
bool EthereumSignTx::has_data_initial_chunk() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void EthereumSignTx::set_has_data_initial_chunk() {
  _has_bits_[0] |= 0x00000020u;
}
void EthereumSignTx::clear_has_data_initial_chunk() {
  _has_bits_[0] &= ~0x00000020u;
}
void EthereumSignTx::clear_data_initial_chunk() {
  data_initial_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_initial_chunk();
}
const ::std::string& EthereumSignTx::data_initial_chunk() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
  return data_initial_chunk_.GetNoArena();
}
void EthereumSignTx::set_data_initial_chunk(const ::std::string& value) {
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
#if LANG_CXX11
void EthereumSignTx::set_data_initial_chunk(::std::string&& value) {
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
#endif
void EthereumSignTx::set_data_initial_chunk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
void EthereumSignTx::set_data_initial_chunk(const void* value, size_t size) {
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
::std::string* EthereumSignTx::mutable_data_initial_chunk() {
  set_has_data_initial_chunk();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
  return data_initial_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumSignTx::release_data_initial_chunk() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
  clear_has_data_initial_chunk();
  return data_initial_chunk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumSignTx::set_allocated_data_initial_chunk(::std::string* data_initial_chunk) {
  if (data_initial_chunk != NULL) {
    set_has_data_initial_chunk();
  } else {
    clear_has_data_initial_chunk();
  }
  data_initial_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_initial_chunk);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}

// optional uint32 data_length = 8;
bool EthereumSignTx::has_data_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void EthereumSignTx::set_has_data_length() {
  _has_bits_[0] |= 0x00000040u;
}
void EthereumSignTx::clear_has_data_length() {
  _has_bits_[0] &= ~0x00000040u;
}
void EthereumSignTx::clear_data_length() {
  data_length_ = 0u;
  clear_has_data_length();
}
::google::protobuf::uint32 EthereumSignTx::data_length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.data_length)
  return data_length_;
}
void EthereumSignTx::set_data_length(::google::protobuf::uint32 value) {
  set_has_data_length();
  data_length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.data_length)
}

// optional uint32 chain_id = 9;
bool EthereumSignTx::has_chain_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void EthereumSignTx::set_has_chain_id() {
  _has_bits_[0] |= 0x00000080u;
}
void EthereumSignTx::clear_has_chain_id() {
  _has_bits_[0] &= ~0x00000080u;
}
void EthereumSignTx::clear_chain_id() {
  chain_id_ = 0u;
  clear_has_chain_id();
}
::google::protobuf::uint32 EthereumSignTx::chain_id() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.chain_id)
  return chain_id_;
}
void EthereumSignTx::set_chain_id(::google::protobuf::uint32 value) {
  set_has_chain_id();
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.chain_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumTxRequest::kDataLengthFieldNumber;
const int EthereumTxRequest::kSignatureVFieldNumber;
const int EthereumTxRequest::kSignatureRFieldNumber;
const int EthereumTxRequest::kSignatureSFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumTxRequest::EthereumTxRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EthereumTxRequest)
}
EthereumTxRequest::EthereumTxRequest(const EthereumTxRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  signature_r_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature_r()) {
    signature_r_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_r_);
  }
  signature_s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature_s()) {
    signature_s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_s_);
  }
  ::memcpy(&data_length_, &from.data_length_,
    reinterpret_cast<char*>(&signature_v_) -
    reinterpret_cast<char*>(&data_length_) + sizeof(signature_v_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EthereumTxRequest)
}

void EthereumTxRequest::SharedCtor() {
  _cached_size_ = 0;
  signature_r_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_s_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_length_, 0, reinterpret_cast<char*>(&signature_v_) -
    reinterpret_cast<char*>(&data_length_) + sizeof(signature_v_));
}

EthereumTxRequest::~EthereumTxRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EthereumTxRequest)
  SharedDtor();
}

void EthereumTxRequest::SharedDtor() {
  signature_r_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_s_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumTxRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EthereumTxRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumTxRequest& EthereumTxRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EthereumTxRequest* EthereumTxRequest::New(::google::protobuf::Arena* arena) const {
  EthereumTxRequest* n = new EthereumTxRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EthereumTxRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EthereumTxRequest)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_signature_r()) {
      GOOGLE_DCHECK(!signature_r_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*signature_r_.UnsafeRawStringPointer())->clear();
    }
    if (has_signature_s()) {
      GOOGLE_DCHECK(!signature_s_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*signature_s_.UnsafeRawStringPointer())->clear();
    }
  }
  if (_has_bits_[0 / 32] & 12u) {
    ::memset(&data_length_, 0, reinterpret_cast<char*>(&signature_v_) -
      reinterpret_cast<char*>(&data_length_) + sizeof(signature_v_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumTxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EthereumTxRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 data_length = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_data_length();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 signature_v = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_signature_v();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &signature_v_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature_r = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature_r()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature_s = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature_s()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EthereumTxRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EthereumTxRequest)
  return false;
#undef DO_
}

void EthereumTxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 data_length = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->data_length(), output);
  }

  // optional uint32 signature_v = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->signature_v(), output);
  }

  // optional bytes signature_r = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature_r(), output);
  }

  // optional bytes signature_s = 4;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->signature_s(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EthereumTxRequest)
}

::google::protobuf::uint8* EthereumTxRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EthereumTxRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 data_length = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->data_length(), target);
  }

  // optional uint32 signature_v = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->signature_v(), target);
  }

  // optional bytes signature_r = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature_r(), target);
  }

  // optional bytes signature_s = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->signature_s(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EthereumTxRequest)
  return target;
}

size_t EthereumTxRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EthereumTxRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional bytes signature_r = 3;
    if (has_signature_r()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature_r());
    }

    // optional bytes signature_s = 4;
    if (has_signature_s()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature_s());
    }

    // optional uint32 data_length = 1;
    if (has_data_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_length());
    }

    // optional uint32 signature_v = 2;
    if (has_signature_v()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->signature_v());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthereumTxRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EthereumTxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumTxRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumTxRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EthereumTxRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EthereumTxRequest)
    MergeFrom(*source);
  }
}

void EthereumTxRequest::MergeFrom(const EthereumTxRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EthereumTxRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_signature_r();
      signature_r_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_r_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_signature_s();
      signature_s_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_s_);
    }
    if (cached_has_bits & 0x00000004u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000008u) {
      signature_v_ = from.signature_v_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EthereumTxRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EthereumTxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumTxRequest::CopyFrom(const EthereumTxRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EthereumTxRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumTxRequest::IsInitialized() const {
  return true;
}

void EthereumTxRequest::Swap(EthereumTxRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumTxRequest::InternalSwap(EthereumTxRequest* other) {
  signature_r_.Swap(&other->signature_r_);
  signature_s_.Swap(&other->signature_s_);
  std::swap(data_length_, other->data_length_);
  std::swap(signature_v_, other->signature_v_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EthereumTxRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EthereumTxRequest

// optional uint32 data_length = 1;
bool EthereumTxRequest::has_data_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void EthereumTxRequest::set_has_data_length() {
  _has_bits_[0] |= 0x00000004u;
}
void EthereumTxRequest::clear_has_data_length() {
  _has_bits_[0] &= ~0x00000004u;
}
void EthereumTxRequest::clear_data_length() {
  data_length_ = 0u;
  clear_has_data_length();
}
::google::protobuf::uint32 EthereumTxRequest::data_length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.data_length)
  return data_length_;
}
void EthereumTxRequest::set_data_length(::google::protobuf::uint32 value) {
  set_has_data_length();
  data_length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.data_length)
}

// optional uint32 signature_v = 2;
bool EthereumTxRequest::has_signature_v() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void EthereumTxRequest::set_has_signature_v() {
  _has_bits_[0] |= 0x00000008u;
}
void EthereumTxRequest::clear_has_signature_v() {
  _has_bits_[0] &= ~0x00000008u;
}
void EthereumTxRequest::clear_signature_v() {
  signature_v_ = 0u;
  clear_has_signature_v();
}
::google::protobuf::uint32 EthereumTxRequest::signature_v() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.signature_v)
  return signature_v_;
}
void EthereumTxRequest::set_signature_v(::google::protobuf::uint32 value) {
  set_has_signature_v();
  signature_v_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.signature_v)
}

// optional bytes signature_r = 3;
bool EthereumTxRequest::has_signature_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EthereumTxRequest::set_has_signature_r() {
  _has_bits_[0] |= 0x00000001u;
}
void EthereumTxRequest::clear_has_signature_r() {
  _has_bits_[0] &= ~0x00000001u;
}
void EthereumTxRequest::clear_signature_r() {
  signature_r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature_r();
}
const ::std::string& EthereumTxRequest::signature_r() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.signature_r)
  return signature_r_.GetNoArena();
}
void EthereumTxRequest::set_signature_r(const ::std::string& value) {
  set_has_signature_r();
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.signature_r)
}
#if LANG_CXX11
void EthereumTxRequest::set_signature_r(::std::string&& value) {
  set_has_signature_r();
  signature_r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumTxRequest.signature_r)
}
#endif
void EthereumTxRequest::set_signature_r(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature_r();
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumTxRequest.signature_r)
}
void EthereumTxRequest::set_signature_r(const void* value, size_t size) {
  set_has_signature_r();
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumTxRequest.signature_r)
}
::std::string* EthereumTxRequest::mutable_signature_r() {
  set_has_signature_r();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumTxRequest.signature_r)
  return signature_r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumTxRequest::release_signature_r() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumTxRequest.signature_r)
  clear_has_signature_r();
  return signature_r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumTxRequest::set_allocated_signature_r(::std::string* signature_r) {
  if (signature_r != NULL) {
    set_has_signature_r();
  } else {
    clear_has_signature_r();
  }
  signature_r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_r);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumTxRequest.signature_r)
}

// optional bytes signature_s = 4;
bool EthereumTxRequest::has_signature_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EthereumTxRequest::set_has_signature_s() {
  _has_bits_[0] |= 0x00000002u;
}
void EthereumTxRequest::clear_has_signature_s() {
  _has_bits_[0] &= ~0x00000002u;
}
void EthereumTxRequest::clear_signature_s() {
  signature_s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature_s();
}
const ::std::string& EthereumTxRequest::signature_s() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.signature_s)
  return signature_s_.GetNoArena();
}
void EthereumTxRequest::set_signature_s(const ::std::string& value) {
  set_has_signature_s();
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.signature_s)
}
#if LANG_CXX11
void EthereumTxRequest::set_signature_s(::std::string&& value) {
  set_has_signature_s();
  signature_s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumTxRequest.signature_s)
}
#endif
void EthereumTxRequest::set_signature_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature_s();
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumTxRequest.signature_s)
}
void EthereumTxRequest::set_signature_s(const void* value, size_t size) {
  set_has_signature_s();
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumTxRequest.signature_s)
}
::std::string* EthereumTxRequest::mutable_signature_s() {
  set_has_signature_s();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumTxRequest.signature_s)
  return signature_s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumTxRequest::release_signature_s() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumTxRequest.signature_s)
  clear_has_signature_s();
  return signature_s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumTxRequest::set_allocated_signature_s(::std::string* signature_s) {
  if (signature_s != NULL) {
    set_has_signature_s();
  } else {
    clear_has_signature_s();
  }
  signature_s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_s);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumTxRequest.signature_s)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EthereumTxAck::kDataChunkFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EthereumTxAck::EthereumTxAck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.EthereumTxAck)
}
EthereumTxAck::EthereumTxAck(const EthereumTxAck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_chunk()) {
    data_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_chunk_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.EthereumTxAck)
}

void EthereumTxAck::SharedCtor() {
  _cached_size_ = 0;
  data_chunk_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EthereumTxAck::~EthereumTxAck() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.EthereumTxAck)
  SharedDtor();
}

void EthereumTxAck::SharedDtor() {
  data_chunk_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EthereumTxAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EthereumTxAck::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const EthereumTxAck& EthereumTxAck::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

EthereumTxAck* EthereumTxAck::New(::google::protobuf::Arena* arena) const {
  EthereumTxAck* n = new EthereumTxAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EthereumTxAck::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.EthereumTxAck)
  if (has_data_chunk()) {
    GOOGLE_DCHECK(!data_chunk_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*data_chunk_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool EthereumTxAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.EthereumTxAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data_chunk = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_chunk()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.EthereumTxAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.EthereumTxAck)
  return false;
#undef DO_
}

void EthereumTxAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data_chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data_chunk(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.EthereumTxAck)
}

::google::protobuf::uint8* EthereumTxAck::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.EthereumTxAck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data_chunk = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data_chunk(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.EthereumTxAck)
  return target;
}

size_t EthereumTxAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.EthereumTxAck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional bytes data_chunk = 1;
  if (has_data_chunk()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data_chunk());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EthereumTxAck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.EthereumTxAck)
  GOOGLE_DCHECK_NE(&from, this);
  const EthereumTxAck* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const EthereumTxAck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.EthereumTxAck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.EthereumTxAck)
    MergeFrom(*source);
  }
}

void EthereumTxAck::MergeFrom(const EthereumTxAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.EthereumTxAck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_data_chunk()) {
    set_has_data_chunk();
    data_chunk_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_chunk_);
  }
}

void EthereumTxAck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.EthereumTxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EthereumTxAck::CopyFrom(const EthereumTxAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.EthereumTxAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EthereumTxAck::IsInitialized() const {
  return true;
}

void EthereumTxAck::Swap(EthereumTxAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EthereumTxAck::InternalSwap(EthereumTxAck* other) {
  data_chunk_.Swap(&other->data_chunk_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata EthereumTxAck::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EthereumTxAck

// optional bytes data_chunk = 1;
bool EthereumTxAck::has_data_chunk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EthereumTxAck::set_has_data_chunk() {
  _has_bits_[0] |= 0x00000001u;
}
void EthereumTxAck::clear_has_data_chunk() {
  _has_bits_[0] &= ~0x00000001u;
}
void EthereumTxAck::clear_data_chunk() {
  data_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_chunk();
}
const ::std::string& EthereumTxAck::data_chunk() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxAck.data_chunk)
  return data_chunk_.GetNoArena();
}
void EthereumTxAck::set_data_chunk(const ::std::string& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxAck.data_chunk)
}
#if LANG_CXX11
void EthereumTxAck::set_data_chunk(::std::string&& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumTxAck.data_chunk)
}
#endif
void EthereumTxAck::set_data_chunk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumTxAck.data_chunk)
}
void EthereumTxAck::set_data_chunk(const void* value, size_t size) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumTxAck.data_chunk)
}
::std::string* EthereumTxAck::mutable_data_chunk() {
  set_has_data_chunk();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumTxAck.data_chunk)
  return data_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* EthereumTxAck::release_data_chunk() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumTxAck.data_chunk)
  clear_has_data_chunk();
  return data_chunk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void EthereumTxAck::set_allocated_data_chunk(::std::string* data_chunk) {
  if (data_chunk != NULL) {
    set_has_data_chunk();
  } else {
    clear_has_data_chunk();
  }
  data_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_chunk);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumTxAck.data_chunk)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignIdentity::kIdentityFieldNumber;
const int SignIdentity::kChallengeHiddenFieldNumber;
const int SignIdentity::kChallengeVisualFieldNumber;
const int SignIdentity::kEcdsaCurveNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignIdentity::SignIdentity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.SignIdentity)
}
SignIdentity::SignIdentity(const SignIdentity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  challenge_hidden_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_challenge_hidden()) {
    challenge_hidden_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.challenge_hidden_);
  }
  challenge_visual_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_challenge_visual()) {
    challenge_visual_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.challenge_visual_);
  }
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ecdsa_curve_name()) {
    ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
  }
  if (from.has_identity()) {
    identity_ = new ::TrezorProtobuf::IdentityType(*from.identity_);
  } else {
    identity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.SignIdentity)
}

void SignIdentity::SharedCtor() {
  _cached_size_ = 0;
  challenge_hidden_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  challenge_visual_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  identity_ = NULL;
}

SignIdentity::~SignIdentity() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.SignIdentity)
  SharedDtor();
}

void SignIdentity::SharedDtor() {
  challenge_hidden_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  challenge_visual_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ecdsa_curve_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete identity_;
  }
}

void SignIdentity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignIdentity::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SignIdentity& SignIdentity::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

SignIdentity* SignIdentity::New(::google::protobuf::Arena* arena) const {
  SignIdentity* n = new SignIdentity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SignIdentity::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.SignIdentity)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_challenge_hidden()) {
      GOOGLE_DCHECK(!challenge_hidden_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*challenge_hidden_.UnsafeRawStringPointer())->clear();
    }
    if (has_challenge_visual()) {
      GOOGLE_DCHECK(!challenge_visual_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*challenge_visual_.UnsafeRawStringPointer())->clear();
    }
    if (has_ecdsa_curve_name()) {
      GOOGLE_DCHECK(!ecdsa_curve_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*ecdsa_curve_name_.UnsafeRawStringPointer())->clear();
    }
    if (has_identity()) {
      GOOGLE_DCHECK(identity_ != NULL);
      identity_->::TrezorProtobuf::IdentityType::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SignIdentity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.SignIdentity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.IdentityType identity = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_identity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes challenge_hidden = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_challenge_hidden()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string challenge_visual = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_challenge_visual()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->challenge_visual().data(), this->challenge_visual().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.SignIdentity.challenge_visual");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string ecdsa_curve_name = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ecdsa_curve_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.SignIdentity.ecdsa_curve_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.SignIdentity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.SignIdentity)
  return false;
#undef DO_
}

void SignIdentity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.SignIdentity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.IdentityType identity = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->identity_, output);
  }

  // optional bytes challenge_hidden = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->challenge_hidden(), output);
  }

  // optional string challenge_visual = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->challenge_visual().data(), this->challenge_visual().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignIdentity.challenge_visual");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->challenge_visual(), output);
  }

  // optional string ecdsa_curve_name = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignIdentity.ecdsa_curve_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->ecdsa_curve_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.SignIdentity)
}

::google::protobuf::uint8* SignIdentity::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.SignIdentity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.IdentityType identity = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->identity_, deterministic, target);
  }

  // optional bytes challenge_hidden = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->challenge_hidden(), target);
  }

  // optional string challenge_visual = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->challenge_visual().data(), this->challenge_visual().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignIdentity.challenge_visual");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->challenge_visual(), target);
  }

  // optional string ecdsa_curve_name = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignIdentity.ecdsa_curve_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->ecdsa_curve_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.SignIdentity)
  return target;
}

size_t SignIdentity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.SignIdentity)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 15u) {
    // optional bytes challenge_hidden = 2;
    if (has_challenge_hidden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->challenge_hidden());
    }

    // optional string challenge_visual = 3;
    if (has_challenge_visual()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->challenge_visual());
    }

    // optional string ecdsa_curve_name = 4;
    if (has_ecdsa_curve_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ecdsa_curve_name());
    }

    // optional .TrezorProtobuf.IdentityType identity = 1;
    if (has_identity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->identity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignIdentity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.SignIdentity)
  GOOGLE_DCHECK_NE(&from, this);
  const SignIdentity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SignIdentity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.SignIdentity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.SignIdentity)
    MergeFrom(*source);
  }
}

void SignIdentity::MergeFrom(const SignIdentity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.SignIdentity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_challenge_hidden();
      challenge_hidden_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.challenge_hidden_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_challenge_visual();
      challenge_visual_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.challenge_visual_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_ecdsa_curve_name();
      ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_identity()->::TrezorProtobuf::IdentityType::MergeFrom(from.identity());
    }
  }
}

void SignIdentity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.SignIdentity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignIdentity::CopyFrom(const SignIdentity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.SignIdentity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignIdentity::IsInitialized() const {
  return true;
}

void SignIdentity::Swap(SignIdentity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignIdentity::InternalSwap(SignIdentity* other) {
  challenge_hidden_.Swap(&other->challenge_hidden_);
  challenge_visual_.Swap(&other->challenge_visual_);
  ecdsa_curve_name_.Swap(&other->ecdsa_curve_name_);
  std::swap(identity_, other->identity_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SignIdentity::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SignIdentity

// optional .TrezorProtobuf.IdentityType identity = 1;
bool SignIdentity::has_identity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SignIdentity::set_has_identity() {
  _has_bits_[0] |= 0x00000008u;
}
void SignIdentity::clear_has_identity() {
  _has_bits_[0] &= ~0x00000008u;
}
void SignIdentity::clear_identity() {
  if (identity_ != NULL) identity_->::TrezorProtobuf::IdentityType::Clear();
  clear_has_identity();
}
const ::TrezorProtobuf::IdentityType& SignIdentity::identity() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.identity)
  return identity_ != NULL ? *identity_
                         : *::TrezorProtobuf::IdentityType::internal_default_instance();
}
::TrezorProtobuf::IdentityType* SignIdentity::mutable_identity() {
  set_has_identity();
  if (identity_ == NULL) {
    identity_ = new ::TrezorProtobuf::IdentityType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.identity)
  return identity_;
}
::TrezorProtobuf::IdentityType* SignIdentity::release_identity() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.identity)
  clear_has_identity();
  ::TrezorProtobuf::IdentityType* temp = identity_;
  identity_ = NULL;
  return temp;
}
void SignIdentity::set_allocated_identity(::TrezorProtobuf::IdentityType* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.identity)
}

// optional bytes challenge_hidden = 2;
bool SignIdentity::has_challenge_hidden() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SignIdentity::set_has_challenge_hidden() {
  _has_bits_[0] |= 0x00000001u;
}
void SignIdentity::clear_has_challenge_hidden() {
  _has_bits_[0] &= ~0x00000001u;
}
void SignIdentity::clear_challenge_hidden() {
  challenge_hidden_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_challenge_hidden();
}
const ::std::string& SignIdentity::challenge_hidden() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.challenge_hidden)
  return challenge_hidden_.GetNoArena();
}
void SignIdentity::set_challenge_hidden(const ::std::string& value) {
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignIdentity.challenge_hidden)
}
#if LANG_CXX11
void SignIdentity::set_challenge_hidden(::std::string&& value) {
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignIdentity.challenge_hidden)
}
#endif
void SignIdentity::set_challenge_hidden(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignIdentity.challenge_hidden)
}
void SignIdentity::set_challenge_hidden(const void* value, size_t size) {
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignIdentity.challenge_hidden)
}
::std::string* SignIdentity::mutable_challenge_hidden() {
  set_has_challenge_hidden();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.challenge_hidden)
  return challenge_hidden_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SignIdentity::release_challenge_hidden() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.challenge_hidden)
  clear_has_challenge_hidden();
  return challenge_hidden_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SignIdentity::set_allocated_challenge_hidden(::std::string* challenge_hidden) {
  if (challenge_hidden != NULL) {
    set_has_challenge_hidden();
  } else {
    clear_has_challenge_hidden();
  }
  challenge_hidden_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), challenge_hidden);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.challenge_hidden)
}

// optional string challenge_visual = 3;
bool SignIdentity::has_challenge_visual() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SignIdentity::set_has_challenge_visual() {
  _has_bits_[0] |= 0x00000002u;
}
void SignIdentity::clear_has_challenge_visual() {
  _has_bits_[0] &= ~0x00000002u;
}
void SignIdentity::clear_challenge_visual() {
  challenge_visual_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_challenge_visual();
}
const ::std::string& SignIdentity::challenge_visual() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.challenge_visual)
  return challenge_visual_.GetNoArena();
}
void SignIdentity::set_challenge_visual(const ::std::string& value) {
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignIdentity.challenge_visual)
}
#if LANG_CXX11
void SignIdentity::set_challenge_visual(::std::string&& value) {
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignIdentity.challenge_visual)
}
#endif
void SignIdentity::set_challenge_visual(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignIdentity.challenge_visual)
}
void SignIdentity::set_challenge_visual(const char* value, size_t size) {
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignIdentity.challenge_visual)
}
::std::string* SignIdentity::mutable_challenge_visual() {
  set_has_challenge_visual();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.challenge_visual)
  return challenge_visual_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SignIdentity::release_challenge_visual() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.challenge_visual)
  clear_has_challenge_visual();
  return challenge_visual_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SignIdentity::set_allocated_challenge_visual(::std::string* challenge_visual) {
  if (challenge_visual != NULL) {
    set_has_challenge_visual();
  } else {
    clear_has_challenge_visual();
  }
  challenge_visual_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), challenge_visual);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.challenge_visual)
}

// optional string ecdsa_curve_name = 4;
bool SignIdentity::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SignIdentity::set_has_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000004u;
}
void SignIdentity::clear_has_ecdsa_curve_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void SignIdentity::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecdsa_curve_name();
}
const ::std::string& SignIdentity::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
void SignIdentity::set_ecdsa_curve_name(const ::std::string& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
#if LANG_CXX11
void SignIdentity::set_ecdsa_curve_name(::std::string&& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
#endif
void SignIdentity::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
void SignIdentity::set_ecdsa_curve_name(const char* value, size_t size) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
::std::string* SignIdentity::mutable_ecdsa_curve_name() {
  set_has_ecdsa_curve_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SignIdentity::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
  clear_has_ecdsa_curve_name();
  return ecdsa_curve_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SignIdentity::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != NULL) {
    set_has_ecdsa_curve_name();
  } else {
    clear_has_ecdsa_curve_name();
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SignedIdentity::kAddressFieldNumber;
const int SignedIdentity::kPublicKeyFieldNumber;
const int SignedIdentity::kSignatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SignedIdentity::SignedIdentity()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.SignedIdentity)
}
SignedIdentity::SignedIdentity(const SignedIdentity& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_address()) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_public_key()) {
    public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
  }
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_signature()) {
    signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.SignedIdentity)
}

void SignedIdentity::SharedCtor() {
  _cached_size_ = 0;
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

SignedIdentity::~SignedIdentity() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.SignedIdentity)
  SharedDtor();
}

void SignedIdentity::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void SignedIdentity::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignedIdentity::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SignedIdentity& SignedIdentity::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

SignedIdentity* SignedIdentity::New(::google::protobuf::Arena* arena) const {
  SignedIdentity* n = new SignedIdentity;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SignedIdentity::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.SignedIdentity)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_address()) {
      GOOGLE_DCHECK(!address_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*address_.UnsafeRawStringPointer())->clear();
    }
    if (has_public_key()) {
      GOOGLE_DCHECK(!public_key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*public_key_.UnsafeRawStringPointer())->clear();
    }
    if (has_signature()) {
      GOOGLE_DCHECK(!signature_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*signature_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SignedIdentity::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.SignedIdentity)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.SignedIdentity.address");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes public_key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes signature = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.SignedIdentity)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.SignedIdentity)
  return false;
#undef DO_
}

void SignedIdentity::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.SignedIdentity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignedIdentity.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->address(), output);
  }

  // optional bytes public_key = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->public_key(), output);
  }

  // optional bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->signature(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.SignedIdentity)
}

::google::protobuf::uint8* SignedIdentity::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.SignedIdentity)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.SignedIdentity.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes public_key = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->public_key(), target);
  }

  // optional bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->signature(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.SignedIdentity)
  return target;
}

size_t SignedIdentity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.SignedIdentity)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes public_key = 2;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional bytes signature = 3;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignedIdentity::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.SignedIdentity)
  GOOGLE_DCHECK_NE(&from, this);
  const SignedIdentity* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SignedIdentity>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.SignedIdentity)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.SignedIdentity)
    MergeFrom(*source);
  }
}

void SignedIdentity::MergeFrom(const SignedIdentity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.SignedIdentity)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_address();
      address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_public_key();
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
  }
}

void SignedIdentity::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.SignedIdentity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignedIdentity::CopyFrom(const SignedIdentity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.SignedIdentity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignedIdentity::IsInitialized() const {
  return true;
}

void SignedIdentity::Swap(SignedIdentity* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SignedIdentity::InternalSwap(SignedIdentity* other) {
  address_.Swap(&other->address_);
  public_key_.Swap(&other->public_key_);
  signature_.Swap(&other->signature_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SignedIdentity::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SignedIdentity

// optional string address = 1;
bool SignedIdentity::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SignedIdentity::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void SignedIdentity::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void SignedIdentity::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
const ::std::string& SignedIdentity::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignedIdentity.address)
  return address_.GetNoArena();
}
void SignedIdentity::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignedIdentity.address)
}
#if LANG_CXX11
void SignedIdentity::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignedIdentity.address)
}
#endif
void SignedIdentity::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignedIdentity.address)
}
void SignedIdentity::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignedIdentity.address)
}
::std::string* SignedIdentity::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignedIdentity.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SignedIdentity::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignedIdentity.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SignedIdentity::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignedIdentity.address)
}

// optional bytes public_key = 2;
bool SignedIdentity::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SignedIdentity::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
void SignedIdentity::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void SignedIdentity::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
const ::std::string& SignedIdentity::public_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignedIdentity.public_key)
  return public_key_.GetNoArena();
}
void SignedIdentity::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignedIdentity.public_key)
}
#if LANG_CXX11
void SignedIdentity::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignedIdentity.public_key)
}
#endif
void SignedIdentity::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignedIdentity.public_key)
}
void SignedIdentity::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignedIdentity.public_key)
}
::std::string* SignedIdentity::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignedIdentity.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SignedIdentity::release_public_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignedIdentity.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SignedIdentity::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignedIdentity.public_key)
}

// optional bytes signature = 3;
bool SignedIdentity::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SignedIdentity::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
void SignedIdentity::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
void SignedIdentity::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
const ::std::string& SignedIdentity::signature() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignedIdentity.signature)
  return signature_.GetNoArena();
}
void SignedIdentity::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignedIdentity.signature)
}
#if LANG_CXX11
void SignedIdentity::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignedIdentity.signature)
}
#endif
void SignedIdentity::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignedIdentity.signature)
}
void SignedIdentity::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignedIdentity.signature)
}
::std::string* SignedIdentity::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignedIdentity.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SignedIdentity::release_signature() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignedIdentity.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SignedIdentity::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignedIdentity.signature)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetECDHSessionKey::kIdentityFieldNumber;
const int GetECDHSessionKey::kPeerPublicKeyFieldNumber;
const int GetECDHSessionKey::kEcdsaCurveNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetECDHSessionKey::GetECDHSessionKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.GetECDHSessionKey)
}
GetECDHSessionKey::GetECDHSessionKey(const GetECDHSessionKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  peer_public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_peer_public_key()) {
    peer_public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peer_public_key_);
  }
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ecdsa_curve_name()) {
    ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
  }
  if (from.has_identity()) {
    identity_ = new ::TrezorProtobuf::IdentityType(*from.identity_);
  } else {
    identity_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.GetECDHSessionKey)
}

void GetECDHSessionKey::SharedCtor() {
  _cached_size_ = 0;
  peer_public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ecdsa_curve_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  identity_ = NULL;
}

GetECDHSessionKey::~GetECDHSessionKey() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.GetECDHSessionKey)
  SharedDtor();
}

void GetECDHSessionKey::SharedDtor() {
  peer_public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ecdsa_curve_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete identity_;
  }
}

void GetECDHSessionKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetECDHSessionKey::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const GetECDHSessionKey& GetECDHSessionKey::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

GetECDHSessionKey* GetECDHSessionKey::New(::google::protobuf::Arena* arena) const {
  GetECDHSessionKey* n = new GetECDHSessionKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetECDHSessionKey::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.GetECDHSessionKey)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_peer_public_key()) {
      GOOGLE_DCHECK(!peer_public_key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*peer_public_key_.UnsafeRawStringPointer())->clear();
    }
    if (has_ecdsa_curve_name()) {
      GOOGLE_DCHECK(!ecdsa_curve_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*ecdsa_curve_name_.UnsafeRawStringPointer())->clear();
    }
    if (has_identity()) {
      GOOGLE_DCHECK(identity_ != NULL);
      identity_->::TrezorProtobuf::IdentityType::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool GetECDHSessionKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.GetECDHSessionKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TrezorProtobuf.IdentityType identity = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_identity()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes peer_public_key = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_peer_public_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string ecdsa_curve_name = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ecdsa_curve_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.GetECDHSessionKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.GetECDHSessionKey)
  return false;
#undef DO_
}

void GetECDHSessionKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.GetECDHSessionKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.IdentityType identity = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->identity_, output);
  }

  // optional bytes peer_public_key = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->peer_public_key(), output);
  }

  // optional string ecdsa_curve_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->ecdsa_curve_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.GetECDHSessionKey)
}

::google::protobuf::uint8* GetECDHSessionKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.GetECDHSessionKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .TrezorProtobuf.IdentityType identity = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->identity_, deterministic, target);
  }

  // optional bytes peer_public_key = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->peer_public_key(), target);
  }

  // optional string ecdsa_curve_name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ecdsa_curve_name().data(), this->ecdsa_curve_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->ecdsa_curve_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.GetECDHSessionKey)
  return target;
}

size_t GetECDHSessionKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.GetECDHSessionKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional bytes peer_public_key = 2;
    if (has_peer_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->peer_public_key());
    }

    // optional string ecdsa_curve_name = 3;
    if (has_ecdsa_curve_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ecdsa_curve_name());
    }

    // optional .TrezorProtobuf.IdentityType identity = 1;
    if (has_identity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->identity_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetECDHSessionKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.GetECDHSessionKey)
  GOOGLE_DCHECK_NE(&from, this);
  const GetECDHSessionKey* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const GetECDHSessionKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.GetECDHSessionKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.GetECDHSessionKey)
    MergeFrom(*source);
  }
}

void GetECDHSessionKey::MergeFrom(const GetECDHSessionKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.GetECDHSessionKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_peer_public_key();
      peer_public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.peer_public_key_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_ecdsa_curve_name();
      ecdsa_curve_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ecdsa_curve_name_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_identity()->::TrezorProtobuf::IdentityType::MergeFrom(from.identity());
    }
  }
}

void GetECDHSessionKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.GetECDHSessionKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetECDHSessionKey::CopyFrom(const GetECDHSessionKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.GetECDHSessionKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetECDHSessionKey::IsInitialized() const {
  return true;
}

void GetECDHSessionKey::Swap(GetECDHSessionKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetECDHSessionKey::InternalSwap(GetECDHSessionKey* other) {
  peer_public_key_.Swap(&other->peer_public_key_);
  ecdsa_curve_name_.Swap(&other->ecdsa_curve_name_);
  std::swap(identity_, other->identity_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata GetECDHSessionKey::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetECDHSessionKey

// optional .TrezorProtobuf.IdentityType identity = 1;
bool GetECDHSessionKey::has_identity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GetECDHSessionKey::set_has_identity() {
  _has_bits_[0] |= 0x00000004u;
}
void GetECDHSessionKey::clear_has_identity() {
  _has_bits_[0] &= ~0x00000004u;
}
void GetECDHSessionKey::clear_identity() {
  if (identity_ != NULL) identity_->::TrezorProtobuf::IdentityType::Clear();
  clear_has_identity();
}
const ::TrezorProtobuf::IdentityType& GetECDHSessionKey::identity() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetECDHSessionKey.identity)
  return identity_ != NULL ? *identity_
                         : *::TrezorProtobuf::IdentityType::internal_default_instance();
}
::TrezorProtobuf::IdentityType* GetECDHSessionKey::mutable_identity() {
  set_has_identity();
  if (identity_ == NULL) {
    identity_ = new ::TrezorProtobuf::IdentityType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetECDHSessionKey.identity)
  return identity_;
}
::TrezorProtobuf::IdentityType* GetECDHSessionKey::release_identity() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetECDHSessionKey.identity)
  clear_has_identity();
  ::TrezorProtobuf::IdentityType* temp = identity_;
  identity_ = NULL;
  return temp;
}
void GetECDHSessionKey::set_allocated_identity(::TrezorProtobuf::IdentityType* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetECDHSessionKey.identity)
}

// optional bytes peer_public_key = 2;
bool GetECDHSessionKey::has_peer_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetECDHSessionKey::set_has_peer_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
void GetECDHSessionKey::clear_has_peer_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetECDHSessionKey::clear_peer_public_key() {
  peer_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_public_key();
}
const ::std::string& GetECDHSessionKey::peer_public_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
  return peer_public_key_.GetNoArena();
}
void GetECDHSessionKey::set_peer_public_key(const ::std::string& value) {
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
#if LANG_CXX11
void GetECDHSessionKey::set_peer_public_key(::std::string&& value) {
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
#endif
void GetECDHSessionKey::set_peer_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
void GetECDHSessionKey::set_peer_public_key(const void* value, size_t size) {
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
::std::string* GetECDHSessionKey::mutable_peer_public_key() {
  set_has_peer_public_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
  return peer_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* GetECDHSessionKey::release_peer_public_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
  clear_has_peer_public_key();
  return peer_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void GetECDHSessionKey::set_allocated_peer_public_key(::std::string* peer_public_key) {
  if (peer_public_key != NULL) {
    set_has_peer_public_key();
  } else {
    clear_has_peer_public_key();
  }
  peer_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_public_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}

// optional string ecdsa_curve_name = 3;
bool GetECDHSessionKey::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetECDHSessionKey::set_has_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000002u;
}
void GetECDHSessionKey::clear_has_ecdsa_curve_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetECDHSessionKey::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecdsa_curve_name();
}
const ::std::string& GetECDHSessionKey::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
void GetECDHSessionKey::set_ecdsa_curve_name(const ::std::string& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
#if LANG_CXX11
void GetECDHSessionKey::set_ecdsa_curve_name(::std::string&& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
#endif
void GetECDHSessionKey::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
void GetECDHSessionKey::set_ecdsa_curve_name(const char* value, size_t size) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
::std::string* GetECDHSessionKey::mutable_ecdsa_curve_name() {
  set_has_ecdsa_curve_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* GetECDHSessionKey::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
  clear_has_ecdsa_curve_name();
  return ecdsa_curve_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void GetECDHSessionKey::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != NULL) {
    set_has_ecdsa_curve_name();
  } else {
    clear_has_ecdsa_curve_name();
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ECDHSessionKey::kSessionKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ECDHSessionKey::ECDHSessionKey()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.ECDHSessionKey)
}
ECDHSessionKey::ECDHSessionKey(const ECDHSessionKey& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  session_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_session_key()) {
    session_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.session_key_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.ECDHSessionKey)
}

void ECDHSessionKey::SharedCtor() {
  _cached_size_ = 0;
  session_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ECDHSessionKey::~ECDHSessionKey() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.ECDHSessionKey)
  SharedDtor();
}

void ECDHSessionKey::SharedDtor() {
  session_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ECDHSessionKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ECDHSessionKey::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ECDHSessionKey& ECDHSessionKey::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

ECDHSessionKey* ECDHSessionKey::New(::google::protobuf::Arena* arena) const {
  ECDHSessionKey* n = new ECDHSessionKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ECDHSessionKey::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.ECDHSessionKey)
  if (has_session_key()) {
    GOOGLE_DCHECK(!session_key_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*session_key_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ECDHSessionKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.ECDHSessionKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes session_key = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_session_key()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.ECDHSessionKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.ECDHSessionKey)
  return false;
#undef DO_
}

void ECDHSessionKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.ECDHSessionKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes session_key = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->session_key(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.ECDHSessionKey)
}

::google::protobuf::uint8* ECDHSessionKey::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.ECDHSessionKey)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes session_key = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->session_key(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.ECDHSessionKey)
  return target;
}

size_t ECDHSessionKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.ECDHSessionKey)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional bytes session_key = 1;
  if (has_session_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->session_key());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ECDHSessionKey::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.ECDHSessionKey)
  GOOGLE_DCHECK_NE(&from, this);
  const ECDHSessionKey* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ECDHSessionKey>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.ECDHSessionKey)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.ECDHSessionKey)
    MergeFrom(*source);
  }
}

void ECDHSessionKey::MergeFrom(const ECDHSessionKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.ECDHSessionKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_session_key()) {
    set_has_session_key();
    session_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.session_key_);
  }
}

void ECDHSessionKey::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.ECDHSessionKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ECDHSessionKey::CopyFrom(const ECDHSessionKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.ECDHSessionKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ECDHSessionKey::IsInitialized() const {
  return true;
}

void ECDHSessionKey::Swap(ECDHSessionKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ECDHSessionKey::InternalSwap(ECDHSessionKey* other) {
  session_key_.Swap(&other->session_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ECDHSessionKey::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ECDHSessionKey

// optional bytes session_key = 1;
bool ECDHSessionKey::has_session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ECDHSessionKey::set_has_session_key() {
  _has_bits_[0] |= 0x00000001u;
}
void ECDHSessionKey::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void ECDHSessionKey::clear_session_key() {
  session_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_key();
}
const ::std::string& ECDHSessionKey::session_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ECDHSessionKey.session_key)
  return session_key_.GetNoArena();
}
void ECDHSessionKey::set_session_key(const ::std::string& value) {
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ECDHSessionKey.session_key)
}
#if LANG_CXX11
void ECDHSessionKey::set_session_key(::std::string&& value) {
  set_has_session_key();
  session_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ECDHSessionKey.session_key)
}
#endif
void ECDHSessionKey::set_session_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ECDHSessionKey.session_key)
}
void ECDHSessionKey::set_session_key(const void* value, size_t size) {
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ECDHSessionKey.session_key)
}
::std::string* ECDHSessionKey::mutable_session_key() {
  set_has_session_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ECDHSessionKey.session_key)
  return session_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ECDHSessionKey::release_session_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ECDHSessionKey.session_key)
  clear_has_session_key();
  return session_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ECDHSessionKey::set_allocated_session_key(::std::string* session_key) {
  if (session_key != NULL) {
    set_has_session_key();
  } else {
    clear_has_session_key();
  }
  session_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ECDHSessionKey.session_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetU2FCounter::kU2FCounterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetU2FCounter::SetU2FCounter()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.SetU2FCounter)
}
SetU2FCounter::SetU2FCounter(const SetU2FCounter& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  u2f_counter_ = from.u2f_counter_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.SetU2FCounter)
}

void SetU2FCounter::SharedCtor() {
  _cached_size_ = 0;
  u2f_counter_ = 0u;
}

SetU2FCounter::~SetU2FCounter() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.SetU2FCounter)
  SharedDtor();
}

void SetU2FCounter::SharedDtor() {
}

void SetU2FCounter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetU2FCounter::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const SetU2FCounter& SetU2FCounter::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

SetU2FCounter* SetU2FCounter::New(::google::protobuf::Arena* arena) const {
  SetU2FCounter* n = new SetU2FCounter;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetU2FCounter::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.SetU2FCounter)
  u2f_counter_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool SetU2FCounter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.SetU2FCounter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 u2f_counter = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_u2f_counter();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &u2f_counter_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.SetU2FCounter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.SetU2FCounter)
  return false;
#undef DO_
}

void SetU2FCounter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.SetU2FCounter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 u2f_counter = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->u2f_counter(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.SetU2FCounter)
}

::google::protobuf::uint8* SetU2FCounter::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.SetU2FCounter)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 u2f_counter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->u2f_counter(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.SetU2FCounter)
  return target;
}

size_t SetU2FCounter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.SetU2FCounter)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional uint32 u2f_counter = 1;
  if (has_u2f_counter()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->u2f_counter());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetU2FCounter::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.SetU2FCounter)
  GOOGLE_DCHECK_NE(&from, this);
  const SetU2FCounter* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SetU2FCounter>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.SetU2FCounter)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.SetU2FCounter)
    MergeFrom(*source);
  }
}

void SetU2FCounter::MergeFrom(const SetU2FCounter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.SetU2FCounter)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_u2f_counter()) {
    set_u2f_counter(from.u2f_counter());
  }
}

void SetU2FCounter::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.SetU2FCounter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetU2FCounter::CopyFrom(const SetU2FCounter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.SetU2FCounter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetU2FCounter::IsInitialized() const {
  return true;
}

void SetU2FCounter::Swap(SetU2FCounter* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetU2FCounter::InternalSwap(SetU2FCounter* other) {
  std::swap(u2f_counter_, other->u2f_counter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SetU2FCounter::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetU2FCounter

// optional uint32 u2f_counter = 1;
bool SetU2FCounter::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetU2FCounter::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000001u;
}
void SetU2FCounter::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetU2FCounter::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
::google::protobuf::uint32 SetU2FCounter::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SetU2FCounter.u2f_counter)
  return u2f_counter_;
}
void SetU2FCounter::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SetU2FCounter.u2f_counter)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FirmwareErase::FirmwareErase()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.FirmwareErase)
}
FirmwareErase::FirmwareErase(const FirmwareErase& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.FirmwareErase)
}

void FirmwareErase::SharedCtor() {
  _cached_size_ = 0;
}

FirmwareErase::~FirmwareErase() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.FirmwareErase)
  SharedDtor();
}

void FirmwareErase::SharedDtor() {
}

void FirmwareErase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirmwareErase::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const FirmwareErase& FirmwareErase::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

FirmwareErase* FirmwareErase::New(::google::protobuf::Arena* arena) const {
  FirmwareErase* n = new FirmwareErase;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FirmwareErase::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.FirmwareErase)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FirmwareErase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.FirmwareErase)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.FirmwareErase)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.FirmwareErase)
  return false;
#undef DO_
}

void FirmwareErase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.FirmwareErase)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.FirmwareErase)
}

::google::protobuf::uint8* FirmwareErase::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.FirmwareErase)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.FirmwareErase)
  return target;
}

size_t FirmwareErase::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.FirmwareErase)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareErase::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.FirmwareErase)
  GOOGLE_DCHECK_NE(&from, this);
  const FirmwareErase* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const FirmwareErase>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.FirmwareErase)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.FirmwareErase)
    MergeFrom(*source);
  }
}

void FirmwareErase::MergeFrom(const FirmwareErase& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.FirmwareErase)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void FirmwareErase::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.FirmwareErase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirmwareErase::CopyFrom(const FirmwareErase& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.FirmwareErase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareErase::IsInitialized() const {
  return true;
}

void FirmwareErase::Swap(FirmwareErase* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FirmwareErase::InternalSwap(FirmwareErase* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FirmwareErase::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FirmwareErase

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FirmwareRequest::kOffsetFieldNumber;
const int FirmwareRequest::kLengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FirmwareRequest::FirmwareRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.FirmwareRequest)
}
FirmwareRequest::FirmwareRequest(const FirmwareRequest& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&offset_, &from.offset_,
    reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&offset_) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.FirmwareRequest)
}

void FirmwareRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&offset_, 0, reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&offset_) + sizeof(length_));
}

FirmwareRequest::~FirmwareRequest() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.FirmwareRequest)
  SharedDtor();
}

void FirmwareRequest::SharedDtor() {
}

void FirmwareRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirmwareRequest::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const FirmwareRequest& FirmwareRequest::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

FirmwareRequest* FirmwareRequest::New(::google::protobuf::Arena* arena) const {
  FirmwareRequest* n = new FirmwareRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FirmwareRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.FirmwareRequest)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&offset_, 0, reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&offset_) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FirmwareRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.FirmwareRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 offset = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_offset();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 length = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_length();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.FirmwareRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.FirmwareRequest)
  return false;
#undef DO_
}

void FirmwareRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.FirmwareRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 offset = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->offset(), output);
  }

  // optional uint32 length = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->length(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.FirmwareRequest)
}

::google::protobuf::uint8* FirmwareRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.FirmwareRequest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 offset = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->offset(), target);
  }

  // optional uint32 length = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->length(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.FirmwareRequest)
  return target;
}

size_t FirmwareRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.FirmwareRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // optional uint32 length = 2;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->length());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.FirmwareRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const FirmwareRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const FirmwareRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.FirmwareRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.FirmwareRequest)
    MergeFrom(*source);
  }
}

void FirmwareRequest::MergeFrom(const FirmwareRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.FirmwareRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000002u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FirmwareRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.FirmwareRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirmwareRequest::CopyFrom(const FirmwareRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.FirmwareRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareRequest::IsInitialized() const {
  return true;
}

void FirmwareRequest::Swap(FirmwareRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FirmwareRequest::InternalSwap(FirmwareRequest* other) {
  std::swap(offset_, other->offset_);
  std::swap(length_, other->length_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FirmwareRequest::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FirmwareRequest

// optional uint32 offset = 1;
bool FirmwareRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FirmwareRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
void FirmwareRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
void FirmwareRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
::google::protobuf::uint32 FirmwareRequest::offset() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareRequest.offset)
  return offset_;
}
void FirmwareRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareRequest.offset)
}

// optional uint32 length = 2;
bool FirmwareRequest::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FirmwareRequest::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
void FirmwareRequest::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
void FirmwareRequest::clear_length() {
  length_ = 0u;
  clear_has_length();
}
::google::protobuf::uint32 FirmwareRequest::length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareRequest.length)
  return length_;
}
void FirmwareRequest::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareRequest.length)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FirmwareUpload::kPayloadFieldNumber;
const int FirmwareUpload::kHashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FirmwareUpload::FirmwareUpload()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.FirmwareUpload)
}
FirmwareUpload::FirmwareUpload(const FirmwareUpload& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.FirmwareUpload)
}

void FirmwareUpload::SharedCtor() {
  _cached_size_ = 0;
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

FirmwareUpload::~FirmwareUpload() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.FirmwareUpload)
  SharedDtor();
}

void FirmwareUpload::SharedDtor() {
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void FirmwareUpload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirmwareUpload::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const FirmwareUpload& FirmwareUpload::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

FirmwareUpload* FirmwareUpload::New(::google::protobuf::Arena* arena) const {
  FirmwareUpload* n = new FirmwareUpload;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FirmwareUpload::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.FirmwareUpload)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_payload()) {
      GOOGLE_DCHECK(!payload_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*payload_.UnsafeRawStringPointer())->clear();
    }
    if (has_hash()) {
      GOOGLE_DCHECK(!hash_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*hash_.UnsafeRawStringPointer())->clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FirmwareUpload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.FirmwareUpload)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes payload = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hash = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.FirmwareUpload)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.FirmwareUpload)
  return false;
#undef DO_
}

void FirmwareUpload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.FirmwareUpload)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes payload = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->payload(), output);
  }

  // optional bytes hash = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->hash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.FirmwareUpload)
}

::google::protobuf::uint8* FirmwareUpload::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.FirmwareUpload)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes payload = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->payload(), target);
  }

  // optional bytes hash = 2;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->hash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.FirmwareUpload)
  return target;
}

size_t FirmwareUpload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.FirmwareUpload)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required bytes payload = 1;
  if (has_payload()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->payload());
  }
  // optional bytes hash = 2;
  if (has_hash()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->hash());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareUpload::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.FirmwareUpload)
  GOOGLE_DCHECK_NE(&from, this);
  const FirmwareUpload* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const FirmwareUpload>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.FirmwareUpload)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.FirmwareUpload)
    MergeFrom(*source);
  }
}

void FirmwareUpload::MergeFrom(const FirmwareUpload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.FirmwareUpload)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_payload();
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_hash();
      hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
  }
}

void FirmwareUpload::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.FirmwareUpload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirmwareUpload::CopyFrom(const FirmwareUpload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.FirmwareUpload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareUpload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void FirmwareUpload::Swap(FirmwareUpload* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FirmwareUpload::InternalSwap(FirmwareUpload* other) {
  payload_.Swap(&other->payload_);
  hash_.Swap(&other->hash_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FirmwareUpload::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FirmwareUpload

// required bytes payload = 1;
bool FirmwareUpload::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FirmwareUpload::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
void FirmwareUpload::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
void FirmwareUpload::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
const ::std::string& FirmwareUpload::payload() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareUpload.payload)
  return payload_.GetNoArena();
}
void FirmwareUpload::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareUpload.payload)
}
#if LANG_CXX11
void FirmwareUpload::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.FirmwareUpload.payload)
}
#endif
void FirmwareUpload::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.FirmwareUpload.payload)
}
void FirmwareUpload::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.FirmwareUpload.payload)
}
::std::string* FirmwareUpload::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.FirmwareUpload.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FirmwareUpload::release_payload() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.FirmwareUpload.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FirmwareUpload::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.FirmwareUpload.payload)
}

// optional bytes hash = 2;
bool FirmwareUpload::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FirmwareUpload::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
void FirmwareUpload::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
void FirmwareUpload::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
const ::std::string& FirmwareUpload::hash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareUpload.hash)
  return hash_.GetNoArena();
}
void FirmwareUpload::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareUpload.hash)
}
#if LANG_CXX11
void FirmwareUpload::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.FirmwareUpload.hash)
}
#endif
void FirmwareUpload::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.FirmwareUpload.hash)
}
void FirmwareUpload::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.FirmwareUpload.hash)
}
::std::string* FirmwareUpload::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.FirmwareUpload.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* FirmwareUpload::release_hash() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.FirmwareUpload.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void FirmwareUpload::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.FirmwareUpload.hash)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DebugLinkDecision::kYesNoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkDecision::DebugLinkDecision()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkDecision)
}
DebugLinkDecision::DebugLinkDecision(const DebugLinkDecision& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  yes_no_ = from.yes_no_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkDecision)
}

void DebugLinkDecision::SharedCtor() {
  _cached_size_ = 0;
  yes_no_ = false;
}

DebugLinkDecision::~DebugLinkDecision() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkDecision)
  SharedDtor();
}

void DebugLinkDecision::SharedDtor() {
}

void DebugLinkDecision::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkDecision::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkDecision& DebugLinkDecision::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkDecision* DebugLinkDecision::New(::google::protobuf::Arena* arena) const {
  DebugLinkDecision* n = new DebugLinkDecision;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkDecision::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkDecision)
  yes_no_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkDecision::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkDecision)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool yes_no = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_yes_no();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &yes_no_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkDecision)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkDecision)
  return false;
#undef DO_
}

void DebugLinkDecision::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkDecision)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool yes_no = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->yes_no(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkDecision)
}

::google::protobuf::uint8* DebugLinkDecision::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkDecision)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool yes_no = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->yes_no(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkDecision)
  return target;
}

size_t DebugLinkDecision::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkDecision)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // required bool yes_no = 1;
  if (has_yes_no()) {
    total_size += 1 + 1;
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkDecision::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkDecision)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkDecision* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkDecision>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkDecision)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkDecision)
    MergeFrom(*source);
  }
}

void DebugLinkDecision::MergeFrom(const DebugLinkDecision& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkDecision)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_yes_no()) {
    set_yes_no(from.yes_no());
  }
}

void DebugLinkDecision::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkDecision)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkDecision::CopyFrom(const DebugLinkDecision& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkDecision)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkDecision::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void DebugLinkDecision::Swap(DebugLinkDecision* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkDecision::InternalSwap(DebugLinkDecision* other) {
  std::swap(yes_no_, other->yes_no_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkDecision::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkDecision

// required bool yes_no = 1;
bool DebugLinkDecision::has_yes_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DebugLinkDecision::set_has_yes_no() {
  _has_bits_[0] |= 0x00000001u;
}
void DebugLinkDecision::clear_has_yes_no() {
  _has_bits_[0] &= ~0x00000001u;
}
void DebugLinkDecision::clear_yes_no() {
  yes_no_ = false;
  clear_has_yes_no();
}
bool DebugLinkDecision::yes_no() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkDecision.yes_no)
  return yes_no_;
}
void DebugLinkDecision::set_yes_no(bool value) {
  set_has_yes_no();
  yes_no_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkDecision.yes_no)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkGetState::DebugLinkGetState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkGetState)
}
DebugLinkGetState::DebugLinkGetState(const DebugLinkGetState& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkGetState)
}

void DebugLinkGetState::SharedCtor() {
  _cached_size_ = 0;
}

DebugLinkGetState::~DebugLinkGetState() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkGetState)
  SharedDtor();
}

void DebugLinkGetState::SharedDtor() {
}

void DebugLinkGetState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkGetState::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkGetState& DebugLinkGetState::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkGetState* DebugLinkGetState::New(::google::protobuf::Arena* arena) const {
  DebugLinkGetState* n = new DebugLinkGetState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkGetState::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkGetState)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkGetState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkGetState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkGetState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkGetState)
  return false;
#undef DO_
}

void DebugLinkGetState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkGetState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkGetState)
}

::google::protobuf::uint8* DebugLinkGetState::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkGetState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkGetState)
  return target;
}

size_t DebugLinkGetState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkGetState)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkGetState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkGetState)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkGetState* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkGetState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkGetState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkGetState)
    MergeFrom(*source);
  }
}

void DebugLinkGetState::MergeFrom(const DebugLinkGetState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkGetState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void DebugLinkGetState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkGetState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkGetState::CopyFrom(const DebugLinkGetState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkGetState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkGetState::IsInitialized() const {
  return true;
}

void DebugLinkGetState::Swap(DebugLinkGetState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkGetState::InternalSwap(DebugLinkGetState* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkGetState::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkGetState

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DebugLinkState::kLayoutFieldNumber;
const int DebugLinkState::kPinFieldNumber;
const int DebugLinkState::kMatrixFieldNumber;
const int DebugLinkState::kMnemonicFieldNumber;
const int DebugLinkState::kNodeFieldNumber;
const int DebugLinkState::kPassphraseProtectionFieldNumber;
const int DebugLinkState::kResetWordFieldNumber;
const int DebugLinkState::kResetEntropyFieldNumber;
const int DebugLinkState::kRecoveryFakeWordFieldNumber;
const int DebugLinkState::kRecoveryWordPosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkState::DebugLinkState()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkState)
}
DebugLinkState::DebugLinkState(const DebugLinkState& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  layout_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_layout()) {
    layout_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.layout_);
  }
  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_pin()) {
    pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
  }
  matrix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_matrix()) {
    matrix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.matrix_);
  }
  mnemonic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_mnemonic()) {
    mnemonic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mnemonic_);
  }
  reset_word_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_reset_word()) {
    reset_word_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.reset_word_);
  }
  reset_entropy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_reset_entropy()) {
    reset_entropy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.reset_entropy_);
  }
  recovery_fake_word_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_recovery_fake_word()) {
    recovery_fake_word_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.recovery_fake_word_);
  }
  if (from.has_node()) {
    node_ = new ::TrezorProtobuf::HDNodeType(*from.node_);
  } else {
    node_ = NULL;
  }
  ::memcpy(&passphrase_protection_, &from.passphrase_protection_,
    reinterpret_cast<char*>(&recovery_word_pos_) -
    reinterpret_cast<char*>(&passphrase_protection_) + sizeof(recovery_word_pos_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkState)
}

void DebugLinkState::SharedCtor() {
  _cached_size_ = 0;
  layout_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  matrix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mnemonic_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  reset_word_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  reset_entropy_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  recovery_fake_word_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&node_, 0, reinterpret_cast<char*>(&recovery_word_pos_) -
    reinterpret_cast<char*>(&node_) + sizeof(recovery_word_pos_));
}

DebugLinkState::~DebugLinkState() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkState)
  SharedDtor();
}

void DebugLinkState::SharedDtor() {
  layout_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pin_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  matrix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mnemonic_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  reset_word_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  reset_entropy_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  recovery_fake_word_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete node_;
  }
}

void DebugLinkState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkState::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkState& DebugLinkState::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkState* DebugLinkState::New(::google::protobuf::Arena* arena) const {
  DebugLinkState* n = new DebugLinkState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkState::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkState)
  if (_has_bits_[0 / 32] & 255u) {
    if (has_layout()) {
      GOOGLE_DCHECK(!layout_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*layout_.UnsafeRawStringPointer())->clear();
    }
    if (has_pin()) {
      GOOGLE_DCHECK(!pin_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*pin_.UnsafeRawStringPointer())->clear();
    }
    if (has_matrix()) {
      GOOGLE_DCHECK(!matrix_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*matrix_.UnsafeRawStringPointer())->clear();
    }
    if (has_mnemonic()) {
      GOOGLE_DCHECK(!mnemonic_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*mnemonic_.UnsafeRawStringPointer())->clear();
    }
    if (has_reset_word()) {
      GOOGLE_DCHECK(!reset_word_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*reset_word_.UnsafeRawStringPointer())->clear();
    }
    if (has_reset_entropy()) {
      GOOGLE_DCHECK(!reset_entropy_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*reset_entropy_.UnsafeRawStringPointer())->clear();
    }
    if (has_recovery_fake_word()) {
      GOOGLE_DCHECK(!recovery_fake_word_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*recovery_fake_word_.UnsafeRawStringPointer())->clear();
    }
    if (has_node()) {
      GOOGLE_DCHECK(node_ != NULL);
      node_->::TrezorProtobuf::HDNodeType::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 768u) {
    ::memset(&passphrase_protection_, 0, reinterpret_cast<char*>(&recovery_word_pos_) -
      reinterpret_cast<char*>(&passphrase_protection_) + sizeof(recovery_word_pos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes layout = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_layout()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string pin = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pin().data(), this->pin().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DebugLinkState.pin");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string matrix = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_matrix()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->matrix().data(), this->matrix().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DebugLinkState.matrix");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string mnemonic = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mnemonic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mnemonic().data(), this->mnemonic().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DebugLinkState.mnemonic");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .TrezorProtobuf.HDNodeType node = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool passphrase_protection = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u)) {
          set_has_passphrase_protection();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string reset_word = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_reset_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->reset_word().data(), this->reset_word().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DebugLinkState.reset_word");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes reset_entropy = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reset_entropy()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string recovery_fake_word = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(74u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_recovery_fake_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->recovery_fake_word().data(), this->recovery_fake_word().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DebugLinkState.recovery_fake_word");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 recovery_word_pos = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(80u)) {
          set_has_recovery_word_pos();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &recovery_word_pos_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkState)
  return false;
#undef DO_
}

void DebugLinkState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes layout = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->layout(), output);
  }

  // optional string pin = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.pin");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->pin(), output);
  }

  // optional string matrix = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->matrix().data(), this->matrix().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.matrix");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->matrix(), output);
  }

  // optional string mnemonic = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.mnemonic");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->mnemonic(), output);
  }

  // optional .TrezorProtobuf.HDNodeType node = 5;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->node_, output);
  }

  // optional bool passphrase_protection = 6;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->passphrase_protection(), output);
  }

  // optional string reset_word = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->reset_word().data(), this->reset_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.reset_word");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->reset_word(), output);
  }

  // optional bytes reset_entropy = 8;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->reset_entropy(), output);
  }

  // optional string recovery_fake_word = 9;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->recovery_fake_word().data(), this->recovery_fake_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.recovery_fake_word");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->recovery_fake_word(), output);
  }

  // optional uint32 recovery_word_pos = 10;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->recovery_word_pos(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkState)
}

::google::protobuf::uint8* DebugLinkState::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkState)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes layout = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->layout(), target);
  }

  // optional string pin = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.pin");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pin(), target);
  }

  // optional string matrix = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->matrix().data(), this->matrix().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.matrix");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->matrix(), target);
  }

  // optional string mnemonic = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.mnemonic");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->mnemonic(), target);
  }

  // optional .TrezorProtobuf.HDNodeType node = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->node_, deterministic, target);
  }

  // optional bool passphrase_protection = 6;
  if (cached_has_bits & 0x00000100u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->passphrase_protection(), target);
  }

  // optional string reset_word = 7;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->reset_word().data(), this->reset_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.reset_word");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->reset_word(), target);
  }

  // optional bytes reset_entropy = 8;
  if (cached_has_bits & 0x00000020u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->reset_entropy(), target);
  }

  // optional string recovery_fake_word = 9;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->recovery_fake_word().data(), this->recovery_fake_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkState.recovery_fake_word");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->recovery_fake_word(), target);
  }

  // optional uint32 recovery_word_pos = 10;
  if (cached_has_bits & 0x00000200u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->recovery_word_pos(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkState)
  return target;
}

size_t DebugLinkState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkState)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 255u) {
    // optional bytes layout = 1;
    if (has_layout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->layout());
    }

    // optional string pin = 2;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pin());
    }

    // optional string matrix = 3;
    if (has_matrix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->matrix());
    }

    // optional string mnemonic = 4;
    if (has_mnemonic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mnemonic());
    }

    // optional string reset_word = 7;
    if (has_reset_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->reset_word());
    }

    // optional bytes reset_entropy = 8;
    if (has_reset_entropy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reset_entropy());
    }

    // optional string recovery_fake_word = 9;
    if (has_recovery_fake_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->recovery_fake_word());
    }

    // optional .TrezorProtobuf.HDNodeType node = 5;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->node_);
    }

  }
  if (_has_bits_[8 / 32] & 768u) {
    // optional bool passphrase_protection = 6;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional uint32 recovery_word_pos = 10;
    if (has_recovery_word_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->recovery_word_pos());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkState::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkState)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkState* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkState>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkState)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkState)
    MergeFrom(*source);
  }
}

void DebugLinkState::MergeFrom(const DebugLinkState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_layout();
      layout_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.layout_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_pin();
      pin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pin_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_matrix();
      matrix_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.matrix_);
    }
    if (cached_has_bits & 0x00000008u) {
      set_has_mnemonic();
      mnemonic_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mnemonic_);
    }
    if (cached_has_bits & 0x00000010u) {
      set_has_reset_word();
      reset_word_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.reset_word_);
    }
    if (cached_has_bits & 0x00000020u) {
      set_has_reset_entropy();
      reset_entropy_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.reset_entropy_);
    }
    if (cached_has_bits & 0x00000040u) {
      set_has_recovery_fake_word();
      recovery_fake_word_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.recovery_fake_word_);
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_node()->::TrezorProtobuf::HDNodeType::MergeFrom(from.node());
    }
  }
  if (cached_has_bits & 768u) {
    if (cached_has_bits & 0x00000100u) {
      passphrase_protection_ = from.passphrase_protection_;
    }
    if (cached_has_bits & 0x00000200u) {
      recovery_word_pos_ = from.recovery_word_pos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DebugLinkState::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkState::CopyFrom(const DebugLinkState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkState::IsInitialized() const {
  if (has_node()) {
    if (!this->node_->IsInitialized()) return false;
  }
  return true;
}

void DebugLinkState::Swap(DebugLinkState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkState::InternalSwap(DebugLinkState* other) {
  layout_.Swap(&other->layout_);
  pin_.Swap(&other->pin_);
  matrix_.Swap(&other->matrix_);
  mnemonic_.Swap(&other->mnemonic_);
  reset_word_.Swap(&other->reset_word_);
  reset_entropy_.Swap(&other->reset_entropy_);
  recovery_fake_word_.Swap(&other->recovery_fake_word_);
  std::swap(node_, other->node_);
  std::swap(passphrase_protection_, other->passphrase_protection_);
  std::swap(recovery_word_pos_, other->recovery_word_pos_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkState::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkState

// optional bytes layout = 1;
bool DebugLinkState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DebugLinkState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
void DebugLinkState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
void DebugLinkState::clear_layout() {
  layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_layout();
}
const ::std::string& DebugLinkState::layout() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.layout)
  return layout_.GetNoArena();
}
void DebugLinkState::set_layout(const ::std::string& value) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.layout)
}
#if LANG_CXX11
void DebugLinkState::set_layout(::std::string&& value) {
  set_has_layout();
  layout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.layout)
}
#endif
void DebugLinkState::set_layout(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.layout)
}
void DebugLinkState::set_layout(const void* value, size_t size) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.layout)
}
::std::string* DebugLinkState::mutable_layout() {
  set_has_layout();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.layout)
  return layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkState::release_layout() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.layout)
  clear_has_layout();
  return layout_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkState::set_allocated_layout(::std::string* layout) {
  if (layout != NULL) {
    set_has_layout();
  } else {
    clear_has_layout();
  }
  layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layout);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.layout)
}

// optional string pin = 2;
bool DebugLinkState::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DebugLinkState::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
void DebugLinkState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
void DebugLinkState::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
const ::std::string& DebugLinkState::pin() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.pin)
  return pin_.GetNoArena();
}
void DebugLinkState::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.pin)
}
#if LANG_CXX11
void DebugLinkState::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.pin)
}
#endif
void DebugLinkState::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.pin)
}
void DebugLinkState::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.pin)
}
::std::string* DebugLinkState::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkState::release_pin() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkState::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.pin)
}

// optional string matrix = 3;
bool DebugLinkState::has_matrix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DebugLinkState::set_has_matrix() {
  _has_bits_[0] |= 0x00000004u;
}
void DebugLinkState::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000004u;
}
void DebugLinkState::clear_matrix() {
  matrix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_matrix();
}
const ::std::string& DebugLinkState::matrix() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.matrix)
  return matrix_.GetNoArena();
}
void DebugLinkState::set_matrix(const ::std::string& value) {
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.matrix)
}
#if LANG_CXX11
void DebugLinkState::set_matrix(::std::string&& value) {
  set_has_matrix();
  matrix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.matrix)
}
#endif
void DebugLinkState::set_matrix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.matrix)
}
void DebugLinkState::set_matrix(const char* value, size_t size) {
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.matrix)
}
::std::string* DebugLinkState::mutable_matrix() {
  set_has_matrix();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.matrix)
  return matrix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkState::release_matrix() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.matrix)
  clear_has_matrix();
  return matrix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkState::set_allocated_matrix(::std::string* matrix) {
  if (matrix != NULL) {
    set_has_matrix();
  } else {
    clear_has_matrix();
  }
  matrix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), matrix);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.matrix)
}

// optional string mnemonic = 4;
bool DebugLinkState::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DebugLinkState::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000008u;
}
void DebugLinkState::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000008u;
}
void DebugLinkState::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mnemonic();
}
const ::std::string& DebugLinkState::mnemonic() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.mnemonic)
  return mnemonic_.GetNoArena();
}
void DebugLinkState::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.mnemonic)
}
#if LANG_CXX11
void DebugLinkState::set_mnemonic(::std::string&& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.mnemonic)
}
#endif
void DebugLinkState::set_mnemonic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.mnemonic)
}
void DebugLinkState::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.mnemonic)
}
::std::string* DebugLinkState::mutable_mnemonic() {
  set_has_mnemonic();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkState::release_mnemonic() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.mnemonic)
  clear_has_mnemonic();
  return mnemonic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkState::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    set_has_mnemonic();
  } else {
    clear_has_mnemonic();
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.mnemonic)
}

// optional .TrezorProtobuf.HDNodeType node = 5;
bool DebugLinkState::has_node() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void DebugLinkState::set_has_node() {
  _has_bits_[0] |= 0x00000080u;
}
void DebugLinkState::clear_has_node() {
  _has_bits_[0] &= ~0x00000080u;
}
void DebugLinkState::clear_node() {
  if (node_ != NULL) node_->::TrezorProtobuf::HDNodeType::Clear();
  clear_has_node();
}
const ::TrezorProtobuf::HDNodeType& DebugLinkState::node() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.node)
  return node_ != NULL ? *node_
                         : *::TrezorProtobuf::HDNodeType::internal_default_instance();
}
::TrezorProtobuf::HDNodeType* DebugLinkState::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    node_ = new ::TrezorProtobuf::HDNodeType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.node)
  return node_;
}
::TrezorProtobuf::HDNodeType* DebugLinkState::release_node() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.node)
  clear_has_node();
  ::TrezorProtobuf::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
void DebugLinkState::set_allocated_node(::TrezorProtobuf::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.node)
}

// optional bool passphrase_protection = 6;
bool DebugLinkState::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void DebugLinkState::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000100u;
}
void DebugLinkState::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000100u;
}
void DebugLinkState::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
bool DebugLinkState::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.passphrase_protection)
  return passphrase_protection_;
}
void DebugLinkState::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.passphrase_protection)
}

// optional string reset_word = 7;
bool DebugLinkState::has_reset_word() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DebugLinkState::set_has_reset_word() {
  _has_bits_[0] |= 0x00000010u;
}
void DebugLinkState::clear_has_reset_word() {
  _has_bits_[0] &= ~0x00000010u;
}
void DebugLinkState::clear_reset_word() {
  reset_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reset_word();
}
const ::std::string& DebugLinkState::reset_word() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.reset_word)
  return reset_word_.GetNoArena();
}
void DebugLinkState::set_reset_word(const ::std::string& value) {
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.reset_word)
}
#if LANG_CXX11
void DebugLinkState::set_reset_word(::std::string&& value) {
  set_has_reset_word();
  reset_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.reset_word)
}
#endif
void DebugLinkState::set_reset_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.reset_word)
}
void DebugLinkState::set_reset_word(const char* value, size_t size) {
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.reset_word)
}
::std::string* DebugLinkState::mutable_reset_word() {
  set_has_reset_word();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.reset_word)
  return reset_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkState::release_reset_word() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.reset_word)
  clear_has_reset_word();
  return reset_word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkState::set_allocated_reset_word(::std::string* reset_word) {
  if (reset_word != NULL) {
    set_has_reset_word();
  } else {
    clear_has_reset_word();
  }
  reset_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_word);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.reset_word)
}

// optional bytes reset_entropy = 8;
bool DebugLinkState::has_reset_entropy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DebugLinkState::set_has_reset_entropy() {
  _has_bits_[0] |= 0x00000020u;
}
void DebugLinkState::clear_has_reset_entropy() {
  _has_bits_[0] &= ~0x00000020u;
}
void DebugLinkState::clear_reset_entropy() {
  reset_entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reset_entropy();
}
const ::std::string& DebugLinkState::reset_entropy() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.reset_entropy)
  return reset_entropy_.GetNoArena();
}
void DebugLinkState::set_reset_entropy(const ::std::string& value) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.reset_entropy)
}
#if LANG_CXX11
void DebugLinkState::set_reset_entropy(::std::string&& value) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.reset_entropy)
}
#endif
void DebugLinkState::set_reset_entropy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.reset_entropy)
}
void DebugLinkState::set_reset_entropy(const void* value, size_t size) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.reset_entropy)
}
::std::string* DebugLinkState::mutable_reset_entropy() {
  set_has_reset_entropy();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.reset_entropy)
  return reset_entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkState::release_reset_entropy() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.reset_entropy)
  clear_has_reset_entropy();
  return reset_entropy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkState::set_allocated_reset_entropy(::std::string* reset_entropy) {
  if (reset_entropy != NULL) {
    set_has_reset_entropy();
  } else {
    clear_has_reset_entropy();
  }
  reset_entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_entropy);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.reset_entropy)
}

// optional string recovery_fake_word = 9;
bool DebugLinkState::has_recovery_fake_word() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DebugLinkState::set_has_recovery_fake_word() {
  _has_bits_[0] |= 0x00000040u;
}
void DebugLinkState::clear_has_recovery_fake_word() {
  _has_bits_[0] &= ~0x00000040u;
}
void DebugLinkState::clear_recovery_fake_word() {
  recovery_fake_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_recovery_fake_word();
}
const ::std::string& DebugLinkState::recovery_fake_word() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.GetNoArena();
}
void DebugLinkState::set_recovery_fake_word(const ::std::string& value) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
#if LANG_CXX11
void DebugLinkState::set_recovery_fake_word(::std::string&& value) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
#endif
void DebugLinkState::set_recovery_fake_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
void DebugLinkState::set_recovery_fake_word(const char* value, size_t size) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
::std::string* DebugLinkState::mutable_recovery_fake_word() {
  set_has_recovery_fake_word();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkState::release_recovery_fake_word() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.recovery_fake_word)
  clear_has_recovery_fake_word();
  return recovery_fake_word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkState::set_allocated_recovery_fake_word(::std::string* recovery_fake_word) {
  if (recovery_fake_word != NULL) {
    set_has_recovery_fake_word();
  } else {
    clear_has_recovery_fake_word();
  }
  recovery_fake_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recovery_fake_word);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}

// optional uint32 recovery_word_pos = 10;
bool DebugLinkState::has_recovery_word_pos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void DebugLinkState::set_has_recovery_word_pos() {
  _has_bits_[0] |= 0x00000200u;
}
void DebugLinkState::clear_has_recovery_word_pos() {
  _has_bits_[0] &= ~0x00000200u;
}
void DebugLinkState::clear_recovery_word_pos() {
  recovery_word_pos_ = 0u;
  clear_has_recovery_word_pos();
}
::google::protobuf::uint32 DebugLinkState::recovery_word_pos() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.recovery_word_pos)
  return recovery_word_pos_;
}
void DebugLinkState::set_recovery_word_pos(::google::protobuf::uint32 value) {
  set_has_recovery_word_pos();
  recovery_word_pos_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.recovery_word_pos)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkStop::DebugLinkStop()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkStop)
}
DebugLinkStop::DebugLinkStop(const DebugLinkStop& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkStop)
}

void DebugLinkStop::SharedCtor() {
  _cached_size_ = 0;
}

DebugLinkStop::~DebugLinkStop() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkStop)
  SharedDtor();
}

void DebugLinkStop::SharedDtor() {
}

void DebugLinkStop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkStop::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkStop& DebugLinkStop::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkStop* DebugLinkStop::New(::google::protobuf::Arena* arena) const {
  DebugLinkStop* n = new DebugLinkStop;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkStop::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkStop)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkStop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkStop)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkStop)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkStop)
  return false;
#undef DO_
}

void DebugLinkStop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkStop)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkStop)
}

::google::protobuf::uint8* DebugLinkStop::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkStop)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkStop)
  return target;
}

size_t DebugLinkStop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkStop)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkStop::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkStop)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkStop* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkStop>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkStop)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkStop)
    MergeFrom(*source);
  }
}

void DebugLinkStop::MergeFrom(const DebugLinkStop& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkStop)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void DebugLinkStop::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkStop::CopyFrom(const DebugLinkStop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkStop::IsInitialized() const {
  return true;
}

void DebugLinkStop::Swap(DebugLinkStop* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkStop::InternalSwap(DebugLinkStop* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkStop::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkStop

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DebugLinkLog::kLevelFieldNumber;
const int DebugLinkLog::kBucketFieldNumber;
const int DebugLinkLog::kTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkLog::DebugLinkLog()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkLog)
}
DebugLinkLog::DebugLinkLog(const DebugLinkLog& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  bucket_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_bucket()) {
    bucket_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bucket_);
  }
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_text()) {
    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  level_ = from.level_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkLog)
}

void DebugLinkLog::SharedCtor() {
  _cached_size_ = 0;
  bucket_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  level_ = 0u;
}

DebugLinkLog::~DebugLinkLog() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkLog)
  SharedDtor();
}

void DebugLinkLog::SharedDtor() {
  bucket_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void DebugLinkLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkLog::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkLog& DebugLinkLog::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkLog* DebugLinkLog::New(::google::protobuf::Arena* arena) const {
  DebugLinkLog* n = new DebugLinkLog;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkLog::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkLog)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_bucket()) {
      GOOGLE_DCHECK(!bucket_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*bucket_.UnsafeRawStringPointer())->clear();
    }
    if (has_text()) {
      GOOGLE_DCHECK(!text_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*text_.UnsafeRawStringPointer())->clear();
    }
  }
  level_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 level = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_level();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string bucket = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bucket()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->bucket().data(), this->bucket().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DebugLinkLog.bucket");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string text = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "TrezorProtobuf.DebugLinkLog.text");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkLog)
  return false;
#undef DO_
}

void DebugLinkLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkLog)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 level = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->level(), output);
  }

  // optional string bucket = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->bucket().data(), this->bucket().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkLog.bucket");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->bucket(), output);
  }

  // optional string text = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkLog.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->text(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkLog)
}

::google::protobuf::uint8* DebugLinkLog::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkLog)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 level = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->level(), target);
  }

  // optional string bucket = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->bucket().data(), this->bucket().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkLog.bucket");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->bucket(), target);
  }

  // optional string text = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "TrezorProtobuf.DebugLinkLog.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->text(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkLog)
  return target;
}

size_t DebugLinkLog::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkLog)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional string bucket = 2;
    if (has_bucket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bucket());
    }

    // optional string text = 3;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

    // optional uint32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkLog::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkLog)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkLog* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkLog>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkLog)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkLog)
    MergeFrom(*source);
  }
}

void DebugLinkLog::MergeFrom(const DebugLinkLog& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkLog)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_bucket();
      bucket_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bucket_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_text();
      text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
    }
    if (cached_has_bits & 0x00000004u) {
      level_ = from.level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DebugLinkLog::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkLog::CopyFrom(const DebugLinkLog& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkLog)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkLog::IsInitialized() const {
  return true;
}

void DebugLinkLog::Swap(DebugLinkLog* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkLog::InternalSwap(DebugLinkLog* other) {
  bucket_.Swap(&other->bucket_);
  text_.Swap(&other->text_);
  std::swap(level_, other->level_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkLog::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkLog

// optional uint32 level = 1;
bool DebugLinkLog::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DebugLinkLog::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
void DebugLinkLog::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
void DebugLinkLog::clear_level() {
  level_ = 0u;
  clear_has_level();
}
::google::protobuf::uint32 DebugLinkLog::level() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkLog.level)
  return level_;
}
void DebugLinkLog::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkLog.level)
}

// optional string bucket = 2;
bool DebugLinkLog::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DebugLinkLog::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
void DebugLinkLog::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
void DebugLinkLog::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bucket();
}
const ::std::string& DebugLinkLog::bucket() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkLog.bucket)
  return bucket_.GetNoArena();
}
void DebugLinkLog::set_bucket(const ::std::string& value) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkLog.bucket)
}
#if LANG_CXX11
void DebugLinkLog::set_bucket(::std::string&& value) {
  set_has_bucket();
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkLog.bucket)
}
#endif
void DebugLinkLog::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkLog.bucket)
}
void DebugLinkLog::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkLog.bucket)
}
::std::string* DebugLinkLog::mutable_bucket() {
  set_has_bucket();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkLog.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkLog::release_bucket() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkLog.bucket)
  clear_has_bucket();
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkLog::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    set_has_bucket();
  } else {
    clear_has_bucket();
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkLog.bucket)
}

// optional string text = 3;
bool DebugLinkLog::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DebugLinkLog::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
void DebugLinkLog::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
void DebugLinkLog::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
const ::std::string& DebugLinkLog::text() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkLog.text)
  return text_.GetNoArena();
}
void DebugLinkLog::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkLog.text)
}
#if LANG_CXX11
void DebugLinkLog::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkLog.text)
}
#endif
void DebugLinkLog::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkLog.text)
}
void DebugLinkLog::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkLog.text)
}
::std::string* DebugLinkLog::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkLog.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkLog::release_text() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkLog.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkLog::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkLog.text)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DebugLinkMemoryRead::kAddressFieldNumber;
const int DebugLinkMemoryRead::kLengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkMemoryRead::DebugLinkMemoryRead()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkMemoryRead)
}
DebugLinkMemoryRead::DebugLinkMemoryRead(const DebugLinkMemoryRead& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&address_, &from.address_,
    reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&address_) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkMemoryRead)
}

void DebugLinkMemoryRead::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&address_, 0, reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&address_) + sizeof(length_));
}

DebugLinkMemoryRead::~DebugLinkMemoryRead() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkMemoryRead)
  SharedDtor();
}

void DebugLinkMemoryRead::SharedDtor() {
}

void DebugLinkMemoryRead::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkMemoryRead::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkMemoryRead& DebugLinkMemoryRead::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkMemoryRead* DebugLinkMemoryRead::New(::google::protobuf::Arena* arena) const {
  DebugLinkMemoryRead* n = new DebugLinkMemoryRead;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkMemoryRead::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkMemoryRead)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&address_, 0, reinterpret_cast<char*>(&length_) -
      reinterpret_cast<char*>(&address_) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkMemoryRead::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkMemoryRead)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_address();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &address_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 length = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_length();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkMemoryRead)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkMemoryRead)
  return false;
#undef DO_
}

void DebugLinkMemoryRead::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkMemoryRead)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->address(), output);
  }

  // optional uint32 length = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->length(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkMemoryRead)
}

::google::protobuf::uint8* DebugLinkMemoryRead::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkMemoryRead)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->address(), target);
  }

  // optional uint32 length = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->length(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkMemoryRead)
  return target;
}

size_t DebugLinkMemoryRead::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkMemoryRead)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->address());
    }

    // optional uint32 length = 2;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->length());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkMemoryRead::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkMemoryRead)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkMemoryRead* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkMemoryRead>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkMemoryRead)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkMemoryRead)
    MergeFrom(*source);
  }
}

void DebugLinkMemoryRead::MergeFrom(const DebugLinkMemoryRead& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkMemoryRead)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      address_ = from.address_;
    }
    if (cached_has_bits & 0x00000002u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DebugLinkMemoryRead::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkMemoryRead)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkMemoryRead::CopyFrom(const DebugLinkMemoryRead& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkMemoryRead)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkMemoryRead::IsInitialized() const {
  return true;
}

void DebugLinkMemoryRead::Swap(DebugLinkMemoryRead* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkMemoryRead::InternalSwap(DebugLinkMemoryRead* other) {
  std::swap(address_, other->address_);
  std::swap(length_, other->length_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkMemoryRead::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkMemoryRead

// optional uint32 address = 1;
bool DebugLinkMemoryRead::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DebugLinkMemoryRead::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
void DebugLinkMemoryRead::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void DebugLinkMemoryRead::clear_address() {
  address_ = 0u;
  clear_has_address();
}
::google::protobuf::uint32 DebugLinkMemoryRead::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryRead.address)
  return address_;
}
void DebugLinkMemoryRead::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryRead.address)
}

// optional uint32 length = 2;
bool DebugLinkMemoryRead::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DebugLinkMemoryRead::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
void DebugLinkMemoryRead::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
void DebugLinkMemoryRead::clear_length() {
  length_ = 0u;
  clear_has_length();
}
::google::protobuf::uint32 DebugLinkMemoryRead::length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryRead.length)
  return length_;
}
void DebugLinkMemoryRead::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryRead.length)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DebugLinkMemory::kMemoryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkMemory::DebugLinkMemory()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkMemory)
}
DebugLinkMemory::DebugLinkMemory(const DebugLinkMemory& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  memory_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_memory()) {
    memory_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.memory_);
  }
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkMemory)
}

void DebugLinkMemory::SharedCtor() {
  _cached_size_ = 0;
  memory_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

DebugLinkMemory::~DebugLinkMemory() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkMemory)
  SharedDtor();
}

void DebugLinkMemory::SharedDtor() {
  memory_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void DebugLinkMemory::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkMemory::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkMemory& DebugLinkMemory::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkMemory* DebugLinkMemory::New(::google::protobuf::Arena* arena) const {
  DebugLinkMemory* n = new DebugLinkMemory;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkMemory::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkMemory)
  if (has_memory()) {
    GOOGLE_DCHECK(!memory_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*memory_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkMemory::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkMemory)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes memory = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_memory()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkMemory)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkMemory)
  return false;
#undef DO_
}

void DebugLinkMemory::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkMemory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes memory = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->memory(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkMemory)
}

::google::protobuf::uint8* DebugLinkMemory::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkMemory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes memory = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->memory(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkMemory)
  return target;
}

size_t DebugLinkMemory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkMemory)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional bytes memory = 1;
  if (has_memory()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->memory());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkMemory::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkMemory)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkMemory* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkMemory>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkMemory)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkMemory)
    MergeFrom(*source);
  }
}

void DebugLinkMemory::MergeFrom(const DebugLinkMemory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkMemory)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_memory()) {
    set_has_memory();
    memory_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.memory_);
  }
}

void DebugLinkMemory::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkMemory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkMemory::CopyFrom(const DebugLinkMemory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkMemory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkMemory::IsInitialized() const {
  return true;
}

void DebugLinkMemory::Swap(DebugLinkMemory* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkMemory::InternalSwap(DebugLinkMemory* other) {
  memory_.Swap(&other->memory_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkMemory::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkMemory

// optional bytes memory = 1;
bool DebugLinkMemory::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DebugLinkMemory::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
void DebugLinkMemory::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
void DebugLinkMemory::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory();
}
const ::std::string& DebugLinkMemory::memory() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemory.memory)
  return memory_.GetNoArena();
}
void DebugLinkMemory::set_memory(const ::std::string& value) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemory.memory)
}
#if LANG_CXX11
void DebugLinkMemory::set_memory(::std::string&& value) {
  set_has_memory();
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkMemory.memory)
}
#endif
void DebugLinkMemory::set_memory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkMemory.memory)
}
void DebugLinkMemory::set_memory(const void* value, size_t size) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkMemory.memory)
}
::std::string* DebugLinkMemory::mutable_memory() {
  set_has_memory();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkMemory.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkMemory::release_memory() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkMemory.memory)
  clear_has_memory();
  return memory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkMemory::set_allocated_memory(::std::string* memory) {
  if (memory != NULL) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkMemory.memory)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DebugLinkMemoryWrite::kAddressFieldNumber;
const int DebugLinkMemoryWrite::kMemoryFieldNumber;
const int DebugLinkMemoryWrite::kFlashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkMemoryWrite::DebugLinkMemoryWrite()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkMemoryWrite)
}
DebugLinkMemoryWrite::DebugLinkMemoryWrite(const DebugLinkMemoryWrite& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  memory_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_memory()) {
    memory_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.memory_);
  }
  ::memcpy(&address_, &from.address_,
    reinterpret_cast<char*>(&flash_) -
    reinterpret_cast<char*>(&address_) + sizeof(flash_));
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkMemoryWrite)
}

void DebugLinkMemoryWrite::SharedCtor() {
  _cached_size_ = 0;
  memory_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&address_, 0, reinterpret_cast<char*>(&flash_) -
    reinterpret_cast<char*>(&address_) + sizeof(flash_));
}

DebugLinkMemoryWrite::~DebugLinkMemoryWrite() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkMemoryWrite)
  SharedDtor();
}

void DebugLinkMemoryWrite::SharedDtor() {
  memory_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void DebugLinkMemoryWrite::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkMemoryWrite::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkMemoryWrite& DebugLinkMemoryWrite::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkMemoryWrite* DebugLinkMemoryWrite::New(::google::protobuf::Arena* arena) const {
  DebugLinkMemoryWrite* n = new DebugLinkMemoryWrite;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkMemoryWrite::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkMemoryWrite)
  if (has_memory()) {
    GOOGLE_DCHECK(!memory_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*memory_.UnsafeRawStringPointer())->clear();
  }
  if (_has_bits_[0 / 32] & 6u) {
    ::memset(&address_, 0, reinterpret_cast<char*>(&flash_) -
      reinterpret_cast<char*>(&address_) + sizeof(flash_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkMemoryWrite::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkMemoryWrite)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 address = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_address();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &address_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes memory = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_memory()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool flash = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_flash();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flash_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkMemoryWrite)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkMemoryWrite)
  return false;
#undef DO_
}

void DebugLinkMemoryWrite::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkMemoryWrite)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 address = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->address(), output);
  }

  // optional bytes memory = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->memory(), output);
  }

  // optional bool flash = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->flash(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkMemoryWrite)
}

::google::protobuf::uint8* DebugLinkMemoryWrite::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkMemoryWrite)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 address = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->address(), target);
  }

  // optional bytes memory = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->memory(), target);
  }

  // optional bool flash = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->flash(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkMemoryWrite)
  return target;
}

size_t DebugLinkMemoryWrite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkMemoryWrite)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional bytes memory = 2;
    if (has_memory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->memory());
    }

    // optional uint32 address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->address());
    }

    // optional bool flash = 3;
    if (has_flash()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkMemoryWrite::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkMemoryWrite)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkMemoryWrite* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkMemoryWrite>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkMemoryWrite)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkMemoryWrite)
    MergeFrom(*source);
  }
}

void DebugLinkMemoryWrite::MergeFrom(const DebugLinkMemoryWrite& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkMemoryWrite)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_memory();
      memory_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.memory_);
    }
    if (cached_has_bits & 0x00000002u) {
      address_ = from.address_;
    }
    if (cached_has_bits & 0x00000004u) {
      flash_ = from.flash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DebugLinkMemoryWrite::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkMemoryWrite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkMemoryWrite::CopyFrom(const DebugLinkMemoryWrite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkMemoryWrite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkMemoryWrite::IsInitialized() const {
  return true;
}

void DebugLinkMemoryWrite::Swap(DebugLinkMemoryWrite* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkMemoryWrite::InternalSwap(DebugLinkMemoryWrite* other) {
  memory_.Swap(&other->memory_);
  std::swap(address_, other->address_);
  std::swap(flash_, other->flash_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkMemoryWrite::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkMemoryWrite

// optional uint32 address = 1;
bool DebugLinkMemoryWrite::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DebugLinkMemoryWrite::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
void DebugLinkMemoryWrite::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
void DebugLinkMemoryWrite::clear_address() {
  address_ = 0u;
  clear_has_address();
}
::google::protobuf::uint32 DebugLinkMemoryWrite::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryWrite.address)
  return address_;
}
void DebugLinkMemoryWrite::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryWrite.address)
}

// optional bytes memory = 2;
bool DebugLinkMemoryWrite::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DebugLinkMemoryWrite::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
void DebugLinkMemoryWrite::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
void DebugLinkMemoryWrite::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory();
}
const ::std::string& DebugLinkMemoryWrite::memory() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryWrite.memory)
  return memory_.GetNoArena();
}
void DebugLinkMemoryWrite::set_memory(const ::std::string& value) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
#if LANG_CXX11
void DebugLinkMemoryWrite::set_memory(::std::string&& value) {
  set_has_memory();
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
#endif
void DebugLinkMemoryWrite::set_memory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
void DebugLinkMemoryWrite::set_memory(const void* value, size_t size) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
::std::string* DebugLinkMemoryWrite::mutable_memory() {
  set_has_memory();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkMemoryWrite.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* DebugLinkMemoryWrite::release_memory() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkMemoryWrite.memory)
  clear_has_memory();
  return memory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void DebugLinkMemoryWrite::set_allocated_memory(::std::string* memory) {
  if (memory != NULL) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}

// optional bool flash = 3;
bool DebugLinkMemoryWrite::has_flash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DebugLinkMemoryWrite::set_has_flash() {
  _has_bits_[0] |= 0x00000004u;
}
void DebugLinkMemoryWrite::clear_has_flash() {
  _has_bits_[0] &= ~0x00000004u;
}
void DebugLinkMemoryWrite::clear_flash() {
  flash_ = false;
  clear_has_flash();
}
bool DebugLinkMemoryWrite::flash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryWrite.flash)
  return flash_;
}
void DebugLinkMemoryWrite::set_flash(bool value) {
  set_has_flash();
  flash_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryWrite.flash)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DebugLinkFlashErase::kSectorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DebugLinkFlashErase::DebugLinkFlashErase()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_messages_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:TrezorProtobuf.DebugLinkFlashErase)
}
DebugLinkFlashErase::DebugLinkFlashErase(const DebugLinkFlashErase& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  sector_ = from.sector_;
  // @@protoc_insertion_point(copy_constructor:TrezorProtobuf.DebugLinkFlashErase)
}

void DebugLinkFlashErase::SharedCtor() {
  _cached_size_ = 0;
  sector_ = 0u;
}

DebugLinkFlashErase::~DebugLinkFlashErase() {
  // @@protoc_insertion_point(destructor:TrezorProtobuf.DebugLinkFlashErase)
  SharedDtor();
}

void DebugLinkFlashErase::SharedDtor() {
}

void DebugLinkFlashErase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkFlashErase::descriptor() {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const DebugLinkFlashErase& DebugLinkFlashErase::default_instance() {
  protobuf_messages_2eproto::InitDefaults();
  return *internal_default_instance();
}

DebugLinkFlashErase* DebugLinkFlashErase::New(::google::protobuf::Arena* arena) const {
  DebugLinkFlashErase* n = new DebugLinkFlashErase;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DebugLinkFlashErase::Clear() {
// @@protoc_insertion_point(message_clear_start:TrezorProtobuf.DebugLinkFlashErase)
  sector_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool DebugLinkFlashErase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:TrezorProtobuf.DebugLinkFlashErase)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 sector = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_sector();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sector_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:TrezorProtobuf.DebugLinkFlashErase)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:TrezorProtobuf.DebugLinkFlashErase)
  return false;
#undef DO_
}

void DebugLinkFlashErase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:TrezorProtobuf.DebugLinkFlashErase)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sector = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sector(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:TrezorProtobuf.DebugLinkFlashErase)
}

::google::protobuf::uint8* DebugLinkFlashErase::InternalSerializeWithCachedSizesToArray(
    bool deterministic __attribute__((unused)), ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:TrezorProtobuf.DebugLinkFlashErase)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sector = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->sector(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TrezorProtobuf.DebugLinkFlashErase)
  return target;
}

size_t DebugLinkFlashErase::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TrezorProtobuf.DebugLinkFlashErase)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  // optional uint32 sector = 1;
  if (has_sector()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->sector());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkFlashErase::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:TrezorProtobuf.DebugLinkFlashErase)
  GOOGLE_DCHECK_NE(&from, this);
  const DebugLinkFlashErase* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const DebugLinkFlashErase>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:TrezorProtobuf.DebugLinkFlashErase)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:TrezorProtobuf.DebugLinkFlashErase)
    MergeFrom(*source);
  }
}

void DebugLinkFlashErase::MergeFrom(const DebugLinkFlashErase& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:TrezorProtobuf.DebugLinkFlashErase)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_sector()) {
    set_sector(from.sector());
  }
}

void DebugLinkFlashErase::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:TrezorProtobuf.DebugLinkFlashErase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkFlashErase::CopyFrom(const DebugLinkFlashErase& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TrezorProtobuf.DebugLinkFlashErase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkFlashErase::IsInitialized() const {
  return true;
}

void DebugLinkFlashErase::Swap(DebugLinkFlashErase* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DebugLinkFlashErase::InternalSwap(DebugLinkFlashErase* other) {
  std::swap(sector_, other->sector_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DebugLinkFlashErase::GetMetadata() const {
  protobuf_messages_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_messages_2eproto::file_level_metadata[kIndexInFileMessages];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DebugLinkFlashErase

// optional uint32 sector = 1;
bool DebugLinkFlashErase::has_sector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DebugLinkFlashErase::set_has_sector() {
  _has_bits_[0] |= 0x00000001u;
}
void DebugLinkFlashErase::clear_has_sector() {
  _has_bits_[0] &= ~0x00000001u;
}
void DebugLinkFlashErase::clear_sector() {
  sector_ = 0u;
  clear_has_sector();
}
::google::protobuf::uint32 DebugLinkFlashErase::sector() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkFlashErase.sector)
  return sector_;
}
void DebugLinkFlashErase::set_sector(::google::protobuf::uint32 value) {
  set_has_sector();
  sector_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkFlashErase.sector)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace TrezorProtobuf

// @@protoc_insertion_point(global_scope)
