// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"
// @@protoc_insertion_point(includes)
namespace TrezorProtobuf {
class Address;
class AddressDefaultTypeInternal;
extern AddressDefaultTypeInternal _Address_default_instance_;
class ApplySettings;
class ApplySettingsDefaultTypeInternal;
extern ApplySettingsDefaultTypeInternal _ApplySettings_default_instance_;
class ButtonAck;
class ButtonAckDefaultTypeInternal;
extern ButtonAckDefaultTypeInternal _ButtonAck_default_instance_;
class ButtonRequest;
class ButtonRequestDefaultTypeInternal;
extern ButtonRequestDefaultTypeInternal _ButtonRequest_default_instance_;
class Cancel;
class CancelDefaultTypeInternal;
extern CancelDefaultTypeInternal _Cancel_default_instance_;
class ChangePin;
class ChangePinDefaultTypeInternal;
extern ChangePinDefaultTypeInternal _ChangePin_default_instance_;
class CipherKeyValue;
class CipherKeyValueDefaultTypeInternal;
extern CipherKeyValueDefaultTypeInternal _CipherKeyValue_default_instance_;
class CipheredKeyValue;
class CipheredKeyValueDefaultTypeInternal;
extern CipheredKeyValueDefaultTypeInternal _CipheredKeyValue_default_instance_;
class ClearSession;
class ClearSessionDefaultTypeInternal;
extern ClearSessionDefaultTypeInternal _ClearSession_default_instance_;
class CoinType;
class CoinTypeDefaultTypeInternal;
extern CoinTypeDefaultTypeInternal _CoinType_default_instance_;
class DebugLinkDecision;
class DebugLinkDecisionDefaultTypeInternal;
extern DebugLinkDecisionDefaultTypeInternal _DebugLinkDecision_default_instance_;
class DebugLinkFlashErase;
class DebugLinkFlashEraseDefaultTypeInternal;
extern DebugLinkFlashEraseDefaultTypeInternal _DebugLinkFlashErase_default_instance_;
class DebugLinkGetState;
class DebugLinkGetStateDefaultTypeInternal;
extern DebugLinkGetStateDefaultTypeInternal _DebugLinkGetState_default_instance_;
class DebugLinkLog;
class DebugLinkLogDefaultTypeInternal;
extern DebugLinkLogDefaultTypeInternal _DebugLinkLog_default_instance_;
class DebugLinkMemory;
class DebugLinkMemoryDefaultTypeInternal;
extern DebugLinkMemoryDefaultTypeInternal _DebugLinkMemory_default_instance_;
class DebugLinkMemoryRead;
class DebugLinkMemoryReadDefaultTypeInternal;
extern DebugLinkMemoryReadDefaultTypeInternal _DebugLinkMemoryRead_default_instance_;
class DebugLinkMemoryWrite;
class DebugLinkMemoryWriteDefaultTypeInternal;
extern DebugLinkMemoryWriteDefaultTypeInternal _DebugLinkMemoryWrite_default_instance_;
class DebugLinkState;
class DebugLinkStateDefaultTypeInternal;
extern DebugLinkStateDefaultTypeInternal _DebugLinkState_default_instance_;
class DebugLinkStop;
class DebugLinkStopDefaultTypeInternal;
extern DebugLinkStopDefaultTypeInternal _DebugLinkStop_default_instance_;
class DecryptMessage;
class DecryptMessageDefaultTypeInternal;
extern DecryptMessageDefaultTypeInternal _DecryptMessage_default_instance_;
class DecryptedMessage;
class DecryptedMessageDefaultTypeInternal;
extern DecryptedMessageDefaultTypeInternal _DecryptedMessage_default_instance_;
class ECDHSessionKey;
class ECDHSessionKeyDefaultTypeInternal;
extern ECDHSessionKeyDefaultTypeInternal _ECDHSessionKey_default_instance_;
class EncryptMessage;
class EncryptMessageDefaultTypeInternal;
extern EncryptMessageDefaultTypeInternal _EncryptMessage_default_instance_;
class EncryptedMessage;
class EncryptedMessageDefaultTypeInternal;
extern EncryptedMessageDefaultTypeInternal _EncryptedMessage_default_instance_;
class Entropy;
class EntropyDefaultTypeInternal;
extern EntropyDefaultTypeInternal _Entropy_default_instance_;
class EntropyAck;
class EntropyAckDefaultTypeInternal;
extern EntropyAckDefaultTypeInternal _EntropyAck_default_instance_;
class EntropyRequest;
class EntropyRequestDefaultTypeInternal;
extern EntropyRequestDefaultTypeInternal _EntropyRequest_default_instance_;
class EstimateTxSize;
class EstimateTxSizeDefaultTypeInternal;
extern EstimateTxSizeDefaultTypeInternal _EstimateTxSize_default_instance_;
class EthereumAddress;
class EthereumAddressDefaultTypeInternal;
extern EthereumAddressDefaultTypeInternal _EthereumAddress_default_instance_;
class EthereumGetAddress;
class EthereumGetAddressDefaultTypeInternal;
extern EthereumGetAddressDefaultTypeInternal _EthereumGetAddress_default_instance_;
class EthereumSignTx;
class EthereumSignTxDefaultTypeInternal;
extern EthereumSignTxDefaultTypeInternal _EthereumSignTx_default_instance_;
class EthereumTxAck;
class EthereumTxAckDefaultTypeInternal;
extern EthereumTxAckDefaultTypeInternal _EthereumTxAck_default_instance_;
class EthereumTxRequest;
class EthereumTxRequestDefaultTypeInternal;
extern EthereumTxRequestDefaultTypeInternal _EthereumTxRequest_default_instance_;
class Failure;
class FailureDefaultTypeInternal;
extern FailureDefaultTypeInternal _Failure_default_instance_;
class Features;
class FeaturesDefaultTypeInternal;
extern FeaturesDefaultTypeInternal _Features_default_instance_;
class FirmwareErase;
class FirmwareEraseDefaultTypeInternal;
extern FirmwareEraseDefaultTypeInternal _FirmwareErase_default_instance_;
class FirmwareRequest;
class FirmwareRequestDefaultTypeInternal;
extern FirmwareRequestDefaultTypeInternal _FirmwareRequest_default_instance_;
class FirmwareUpload;
class FirmwareUploadDefaultTypeInternal;
extern FirmwareUploadDefaultTypeInternal _FirmwareUpload_default_instance_;
class GetAddress;
class GetAddressDefaultTypeInternal;
extern GetAddressDefaultTypeInternal _GetAddress_default_instance_;
class GetECDHSessionKey;
class GetECDHSessionKeyDefaultTypeInternal;
extern GetECDHSessionKeyDefaultTypeInternal _GetECDHSessionKey_default_instance_;
class GetEntropy;
class GetEntropyDefaultTypeInternal;
extern GetEntropyDefaultTypeInternal _GetEntropy_default_instance_;
class GetFeatures;
class GetFeaturesDefaultTypeInternal;
extern GetFeaturesDefaultTypeInternal _GetFeatures_default_instance_;
class GetPublicKey;
class GetPublicKeyDefaultTypeInternal;
extern GetPublicKeyDefaultTypeInternal _GetPublicKey_default_instance_;
class HDNodePathType;
class HDNodePathTypeDefaultTypeInternal;
extern HDNodePathTypeDefaultTypeInternal _HDNodePathType_default_instance_;
class HDNodeType;
class HDNodeTypeDefaultTypeInternal;
extern HDNodeTypeDefaultTypeInternal _HDNodeType_default_instance_;
class IdentityType;
class IdentityTypeDefaultTypeInternal;
extern IdentityTypeDefaultTypeInternal _IdentityType_default_instance_;
class Initialize;
class InitializeDefaultTypeInternal;
extern InitializeDefaultTypeInternal _Initialize_default_instance_;
class LoadDevice;
class LoadDeviceDefaultTypeInternal;
extern LoadDeviceDefaultTypeInternal _LoadDevice_default_instance_;
class MessageSignature;
class MessageSignatureDefaultTypeInternal;
extern MessageSignatureDefaultTypeInternal _MessageSignature_default_instance_;
class MultisigRedeemScriptType;
class MultisigRedeemScriptTypeDefaultTypeInternal;
extern MultisigRedeemScriptTypeDefaultTypeInternal _MultisigRedeemScriptType_default_instance_;
class PassphraseAck;
class PassphraseAckDefaultTypeInternal;
extern PassphraseAckDefaultTypeInternal _PassphraseAck_default_instance_;
class PassphraseRequest;
class PassphraseRequestDefaultTypeInternal;
extern PassphraseRequestDefaultTypeInternal _PassphraseRequest_default_instance_;
class PinMatrixAck;
class PinMatrixAckDefaultTypeInternal;
extern PinMatrixAckDefaultTypeInternal _PinMatrixAck_default_instance_;
class PinMatrixRequest;
class PinMatrixRequestDefaultTypeInternal;
extern PinMatrixRequestDefaultTypeInternal _PinMatrixRequest_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PublicKey;
class PublicKeyDefaultTypeInternal;
extern PublicKeyDefaultTypeInternal _PublicKey_default_instance_;
class RecoveryDevice;
class RecoveryDeviceDefaultTypeInternal;
extern RecoveryDeviceDefaultTypeInternal _RecoveryDevice_default_instance_;
class ResetDevice;
class ResetDeviceDefaultTypeInternal;
extern ResetDeviceDefaultTypeInternal _ResetDevice_default_instance_;
class SetU2FCounter;
class SetU2FCounterDefaultTypeInternal;
extern SetU2FCounterDefaultTypeInternal _SetU2FCounter_default_instance_;
class SignIdentity;
class SignIdentityDefaultTypeInternal;
extern SignIdentityDefaultTypeInternal _SignIdentity_default_instance_;
class SignMessage;
class SignMessageDefaultTypeInternal;
extern SignMessageDefaultTypeInternal _SignMessage_default_instance_;
class SignTx;
class SignTxDefaultTypeInternal;
extern SignTxDefaultTypeInternal _SignTx_default_instance_;
class SignedIdentity;
class SignedIdentityDefaultTypeInternal;
extern SignedIdentityDefaultTypeInternal _SignedIdentity_default_instance_;
class SimpleSignTx;
class SimpleSignTxDefaultTypeInternal;
extern SimpleSignTxDefaultTypeInternal _SimpleSignTx_default_instance_;
class Success;
class SuccessDefaultTypeInternal;
extern SuccessDefaultTypeInternal _Success_default_instance_;
class TransactionType;
class TransactionTypeDefaultTypeInternal;
extern TransactionTypeDefaultTypeInternal _TransactionType_default_instance_;
class TxAck;
class TxAckDefaultTypeInternal;
extern TxAckDefaultTypeInternal _TxAck_default_instance_;
class TxInputType;
class TxInputTypeDefaultTypeInternal;
extern TxInputTypeDefaultTypeInternal _TxInputType_default_instance_;
class TxOutputBinType;
class TxOutputBinTypeDefaultTypeInternal;
extern TxOutputBinTypeDefaultTypeInternal _TxOutputBinType_default_instance_;
class TxOutputType;
class TxOutputTypeDefaultTypeInternal;
extern TxOutputTypeDefaultTypeInternal _TxOutputType_default_instance_;
class TxRequest;
class TxRequestDefaultTypeInternal;
extern TxRequestDefaultTypeInternal _TxRequest_default_instance_;
class TxRequestDetailsType;
class TxRequestDetailsTypeDefaultTypeInternal;
extern TxRequestDetailsTypeDefaultTypeInternal _TxRequestDetailsType_default_instance_;
class TxRequestSerializedType;
class TxRequestSerializedTypeDefaultTypeInternal;
extern TxRequestSerializedTypeDefaultTypeInternal _TxRequestSerializedType_default_instance_;
class TxSize;
class TxSizeDefaultTypeInternal;
extern TxSizeDefaultTypeInternal _TxSize_default_instance_;
class VerifyMessage;
class VerifyMessageDefaultTypeInternal;
extern VerifyMessageDefaultTypeInternal _VerifyMessage_default_instance_;
class WipeDevice;
class WipeDeviceDefaultTypeInternal;
extern WipeDeviceDefaultTypeInternal _WipeDevice_default_instance_;
class WordAck;
class WordAckDefaultTypeInternal;
extern WordAckDefaultTypeInternal _WordAck_default_instance_;
class WordRequest;
class WordRequestDefaultTypeInternal;
extern WordRequestDefaultTypeInternal _WordRequest_default_instance_;
}  // namespace TrezorProtobuf

namespace TrezorProtobuf {

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_messages_2eproto

enum MessageType {
  MessageType_Initialize = 0,
  MessageType_Ping = 1,
  MessageType_Success = 2,
  MessageType_Failure = 3,
  MessageType_ChangePin = 4,
  MessageType_WipeDevice = 5,
  MessageType_FirmwareErase = 6,
  MessageType_FirmwareUpload = 7,
  MessageType_FirmwareRequest = 8,
  MessageType_GetEntropy = 9,
  MessageType_Entropy = 10,
  MessageType_GetPublicKey = 11,
  MessageType_PublicKey = 12,
  MessageType_LoadDevice = 13,
  MessageType_ResetDevice = 14,
  MessageType_SignTx = 15,
  MessageType_SimpleSignTx = 16,
  MessageType_Features = 17,
  MessageType_PinMatrixRequest = 18,
  MessageType_PinMatrixAck = 19,
  MessageType_Cancel = 20,
  MessageType_TxRequest = 21,
  MessageType_TxAck = 22,
  MessageType_CipherKeyValue = 23,
  MessageType_ClearSession = 24,
  MessageType_ApplySettings = 25,
  MessageType_ButtonRequest = 26,
  MessageType_ButtonAck = 27,
  MessageType_GetAddress = 29,
  MessageType_Address = 30,
  MessageType_EntropyRequest = 35,
  MessageType_EntropyAck = 36,
  MessageType_SignMessage = 38,
  MessageType_VerifyMessage = 39,
  MessageType_MessageSignature = 40,
  MessageType_PassphraseRequest = 41,
  MessageType_PassphraseAck = 42,
  MessageType_EstimateTxSize = 43,
  MessageType_TxSize = 44,
  MessageType_RecoveryDevice = 45,
  MessageType_WordRequest = 46,
  MessageType_WordAck = 47,
  MessageType_CipheredKeyValue = 48,
  MessageType_EncryptMessage = 49,
  MessageType_EncryptedMessage = 50,
  MessageType_DecryptMessage = 51,
  MessageType_DecryptedMessage = 52,
  MessageType_SignIdentity = 53,
  MessageType_SignedIdentity = 54,
  MessageType_GetFeatures = 55,
  MessageType_EthereumGetAddress = 56,
  MessageType_EthereumAddress = 57,
  MessageType_EthereumSignTx = 58,
  MessageType_EthereumTxRequest = 59,
  MessageType_EthereumTxAck = 60,
  MessageType_GetECDHSessionKey = 61,
  MessageType_ECDHSessionKey = 62,
  MessageType_SetU2FCounter = 63,
  MessageType_DebugLinkDecision = 100,
  MessageType_DebugLinkGetState = 101,
  MessageType_DebugLinkState = 102,
  MessageType_DebugLinkStop = 103,
  MessageType_DebugLinkLog = 104,
  MessageType_DebugLinkMemoryRead = 110,
  MessageType_DebugLinkMemory = 111,
  MessageType_DebugLinkMemoryWrite = 112,
  MessageType_DebugLinkFlashErase = 113
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MessageType_Initialize;
const MessageType MessageType_MAX = MessageType_DebugLinkFlashErase;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Initialize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Initialize) */ {
 public:
  Initialize();
  virtual ~Initialize();

  Initialize(const Initialize& from);

  inline Initialize& operator=(const Initialize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Initialize& default_instance();

  static inline const Initialize* internal_default_instance() {
    return reinterpret_cast<const Initialize*>(
               &_Initialize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Initialize* other);

  // implements Message ----------------------------------------------

  inline Initialize* New() const PROTOBUF_FINAL { return New(NULL); }

  Initialize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Initialize& from);
  void MergeFrom(const Initialize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Initialize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Initialize)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetFeatures : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.GetFeatures) */ {
 public:
  GetFeatures();
  virtual ~GetFeatures();

  GetFeatures(const GetFeatures& from);

  inline GetFeatures& operator=(const GetFeatures& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetFeatures& default_instance();

  static inline const GetFeatures* internal_default_instance() {
    return reinterpret_cast<const GetFeatures*>(
               &_GetFeatures_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(GetFeatures* other);

  // implements Message ----------------------------------------------

  inline GetFeatures* New() const PROTOBUF_FINAL { return New(NULL); }

  GetFeatures* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetFeatures& from);
  void MergeFrom(const GetFeatures& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetFeatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.GetFeatures)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Features : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Features) */ {
 public:
  Features();
  virtual ~Features();

  Features(const Features& from);

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Features& default_instance();

  static inline const Features* internal_default_instance() {
    return reinterpret_cast<const Features*>(
               &_Features_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Features* other);

  // implements Message ----------------------------------------------

  inline Features* New() const PROTOBUF_FINAL { return New(NULL); }

  Features* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Features& from);
  void MergeFrom(const Features& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Features* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TrezorProtobuf.CoinType coins = 11;
  int coins_size() const;
  void clear_coins();
  static const int kCoinsFieldNumber = 11;
  const ::TrezorProtobuf::CoinType& coins(int index) const;
  ::TrezorProtobuf::CoinType* mutable_coins(int index);
  ::TrezorProtobuf::CoinType* add_coins();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::CoinType >*
      mutable_coins();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::CoinType >&
      coins() const;

  // optional string vendor = 1;
  bool has_vendor() const;
  void clear_vendor();
  static const int kVendorFieldNumber = 1;
  const ::std::string& vendor() const;
  void set_vendor(const ::std::string& value);
  #if LANG_CXX11
  void set_vendor(::std::string&& value);
  #endif
  void set_vendor(const char* value);
  void set_vendor(const char* value, size_t size);
  ::std::string* mutable_vendor();
  ::std::string* release_vendor();
  void set_allocated_vendor(::std::string* vendor);

  // optional string device_id = 6;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 6;
  const ::std::string& device_id() const;
  void set_device_id(const ::std::string& value);
  #if LANG_CXX11
  void set_device_id(::std::string&& value);
  #endif
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  ::std::string* mutable_device_id();
  ::std::string* release_device_id();
  void set_allocated_device_id(::std::string* device_id);

  // optional string language = 9;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 9;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string label = 10;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 10;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional bytes revision = 13;
  bool has_revision() const;
  void clear_revision();
  static const int kRevisionFieldNumber = 13;
  const ::std::string& revision() const;
  void set_revision(const ::std::string& value);
  #if LANG_CXX11
  void set_revision(::std::string&& value);
  #endif
  void set_revision(const char* value);
  void set_revision(const void* value, size_t size);
  ::std::string* mutable_revision();
  ::std::string* release_revision();
  void set_allocated_revision(::std::string* revision);

  // optional bytes bootloader_hash = 14;
  bool has_bootloader_hash() const;
  void clear_bootloader_hash();
  static const int kBootloaderHashFieldNumber = 14;
  const ::std::string& bootloader_hash() const;
  void set_bootloader_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_bootloader_hash(::std::string&& value);
  #endif
  void set_bootloader_hash(const char* value);
  void set_bootloader_hash(const void* value, size_t size);
  ::std::string* mutable_bootloader_hash();
  ::std::string* release_bootloader_hash();
  void set_allocated_bootloader_hash(::std::string* bootloader_hash);

  // optional uint32 major_version = 2;
  bool has_major_version() const;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 2;
  ::google::protobuf::uint32 major_version() const;
  void set_major_version(::google::protobuf::uint32 value);

  // optional uint32 minor_version = 3;
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 3;
  ::google::protobuf::uint32 minor_version() const;
  void set_minor_version(::google::protobuf::uint32 value);

  // optional uint32 patch_version = 4;
  bool has_patch_version() const;
  void clear_patch_version();
  static const int kPatchVersionFieldNumber = 4;
  ::google::protobuf::uint32 patch_version() const;
  void set_patch_version(::google::protobuf::uint32 value);

  // optional bool bootloader_mode = 5;
  bool has_bootloader_mode() const;
  void clear_bootloader_mode();
  static const int kBootloaderModeFieldNumber = 5;
  bool bootloader_mode() const;
  void set_bootloader_mode(bool value);

  // optional bool pin_protection = 7;
  bool has_pin_protection() const;
  void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 7;
  bool pin_protection() const;
  void set_pin_protection(bool value);

  // optional bool passphrase_protection = 8;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 8;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // optional bool initialized = 12;
  bool has_initialized() const;
  void clear_initialized();
  static const int kInitializedFieldNumber = 12;
  bool initialized() const;
  void set_initialized(bool value);

  // optional bool imported = 15;
  bool has_imported() const;
  void clear_imported();
  static const int kImportedFieldNumber = 15;
  bool imported() const;
  void set_imported(bool value);

  // optional bool pin_cached = 16;
  bool has_pin_cached() const;
  void clear_pin_cached();
  static const int kPinCachedFieldNumber = 16;
  bool pin_cached() const;
  void set_pin_cached(bool value);

  // optional bool passphrase_cached = 17;
  bool has_passphrase_cached() const;
  void clear_passphrase_cached();
  static const int kPassphraseCachedFieldNumber = 17;
  bool passphrase_cached() const;
  void set_passphrase_cached(bool value);

  // optional bool firmware_present = 18;
  bool has_firmware_present() const;
  void clear_firmware_present();
  static const int kFirmwarePresentFieldNumber = 18;
  bool firmware_present() const;
  void set_firmware_present(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Features)
 private:
  void set_has_vendor();
  void clear_has_vendor();
  void set_has_major_version();
  void clear_has_major_version();
  void set_has_minor_version();
  void clear_has_minor_version();
  void set_has_patch_version();
  void clear_has_patch_version();
  void set_has_bootloader_mode();
  void clear_has_bootloader_mode();
  void set_has_device_id();
  void clear_has_device_id();
  void set_has_pin_protection();
  void clear_has_pin_protection();
  void set_has_passphrase_protection();
  void clear_has_passphrase_protection();
  void set_has_language();
  void clear_has_language();
  void set_has_label();
  void clear_has_label();
  void set_has_initialized();
  void clear_has_initialized();
  void set_has_revision();
  void clear_has_revision();
  void set_has_bootloader_hash();
  void clear_has_bootloader_hash();
  void set_has_imported();
  void clear_has_imported();
  void set_has_pin_cached();
  void clear_has_pin_cached();
  void set_has_passphrase_cached();
  void clear_has_passphrase_cached();
  void set_has_firmware_present();
  void clear_has_firmware_present();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::CoinType > coins_;
  ::google::protobuf::internal::ArenaStringPtr vendor_;
  ::google::protobuf::internal::ArenaStringPtr device_id_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr revision_;
  ::google::protobuf::internal::ArenaStringPtr bootloader_hash_;
  ::google::protobuf::uint32 major_version_;
  ::google::protobuf::uint32 minor_version_;
  ::google::protobuf::uint32 patch_version_;
  bool bootloader_mode_;
  bool pin_protection_;
  bool passphrase_protection_;
  bool initialized_;
  bool imported_;
  bool pin_cached_;
  bool passphrase_cached_;
  bool firmware_present_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClearSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.ClearSession) */ {
 public:
  ClearSession();
  virtual ~ClearSession();

  ClearSession(const ClearSession& from);

  inline ClearSession& operator=(const ClearSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearSession& default_instance();

  static inline const ClearSession* internal_default_instance() {
    return reinterpret_cast<const ClearSession*>(
               &_ClearSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ClearSession* other);

  // implements Message ----------------------------------------------

  inline ClearSession* New() const PROTOBUF_FINAL { return New(NULL); }

  ClearSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClearSession& from);
  void MergeFrom(const ClearSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClearSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.ClearSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApplySettings : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.ApplySettings) */ {
 public:
  ApplySettings();
  virtual ~ApplySettings();

  ApplySettings(const ApplySettings& from);

  inline ApplySettings& operator=(const ApplySettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplySettings& default_instance();

  static inline const ApplySettings* internal_default_instance() {
    return reinterpret_cast<const ApplySettings*>(
               &_ApplySettings_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(ApplySettings* other);

  // implements Message ----------------------------------------------

  inline ApplySettings* New() const PROTOBUF_FINAL { return New(NULL); }

  ApplySettings* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ApplySettings& from);
  void MergeFrom(const ApplySettings& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ApplySettings* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string language = 1;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional bytes homescreen = 4;
  bool has_homescreen() const;
  void clear_homescreen();
  static const int kHomescreenFieldNumber = 4;
  const ::std::string& homescreen() const;
  void set_homescreen(const ::std::string& value);
  #if LANG_CXX11
  void set_homescreen(::std::string&& value);
  #endif
  void set_homescreen(const char* value);
  void set_homescreen(const void* value, size_t size);
  ::std::string* mutable_homescreen();
  ::std::string* release_homescreen();
  void set_allocated_homescreen(::std::string* homescreen);

  // optional bool use_passphrase = 3;
  bool has_use_passphrase() const;
  void clear_use_passphrase();
  static const int kUsePassphraseFieldNumber = 3;
  bool use_passphrase() const;
  void set_use_passphrase(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.ApplySettings)
 private:
  void set_has_language();
  void clear_has_language();
  void set_has_label();
  void clear_has_label();
  void set_has_use_passphrase();
  void clear_has_use_passphrase();
  void set_has_homescreen();
  void clear_has_homescreen();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr homescreen_;
  bool use_passphrase_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChangePin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.ChangePin) */ {
 public:
  ChangePin();
  virtual ~ChangePin();

  ChangePin(const ChangePin& from);

  inline ChangePin& operator=(const ChangePin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePin& default_instance();

  static inline const ChangePin* internal_default_instance() {
    return reinterpret_cast<const ChangePin*>(
               &_ChangePin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ChangePin* other);

  // implements Message ----------------------------------------------

  inline ChangePin* New() const PROTOBUF_FINAL { return New(NULL); }

  ChangePin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChangePin& from);
  void MergeFrom(const ChangePin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChangePin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool remove = 1;
  bool has_remove() const;
  void clear_remove();
  static const int kRemoveFieldNumber = 1;
  bool remove() const;
  void set_remove(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.ChangePin)
 private:
  void set_has_remove();
  void clear_has_remove();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool remove_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  inline Ping* New() const PROTOBUF_FINAL { return New(NULL); }

  Ping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional bool button_protection = 2;
  bool has_button_protection() const;
  void clear_button_protection();
  static const int kButtonProtectionFieldNumber = 2;
  bool button_protection() const;
  void set_button_protection(bool value);

  // optional bool pin_protection = 3;
  bool has_pin_protection() const;
  void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 3;
  bool pin_protection() const;
  void set_pin_protection(bool value);

  // optional bool passphrase_protection = 4;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 4;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Ping)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_button_protection();
  void clear_has_button_protection();
  void set_has_pin_protection();
  void clear_has_pin_protection();
  void set_has_passphrase_protection();
  void clear_has_passphrase_protection();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  bool button_protection_;
  bool pin_protection_;
  bool passphrase_protection_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Success : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Success) */ {
 public:
  Success();
  virtual ~Success();

  Success(const Success& from);

  inline Success& operator=(const Success& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Success& default_instance();

  static inline const Success* internal_default_instance() {
    return reinterpret_cast<const Success*>(
               &_Success_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Success* other);

  // implements Message ----------------------------------------------

  inline Success* New() const PROTOBUF_FINAL { return New(NULL); }

  Success* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Success& from);
  void MergeFrom(const Success& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Success* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Success)
 private:
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Failure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Failure) */ {
 public:
  Failure();
  virtual ~Failure();

  Failure(const Failure& from);

  inline Failure& operator=(const Failure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Failure& default_instance();

  static inline const Failure* internal_default_instance() {
    return reinterpret_cast<const Failure*>(
               &_Failure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Failure* other);

  // implements Message ----------------------------------------------

  inline Failure* New() const PROTOBUF_FINAL { return New(NULL); }

  Failure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Failure& from);
  void MergeFrom(const Failure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Failure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .TrezorProtobuf.FailureType code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::TrezorProtobuf::FailureType code() const;
  void set_code(::TrezorProtobuf::FailureType value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Failure)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int code_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ButtonRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.ButtonRequest) */ {
 public:
  ButtonRequest();
  virtual ~ButtonRequest();

  ButtonRequest(const ButtonRequest& from);

  inline ButtonRequest& operator=(const ButtonRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonRequest& default_instance();

  static inline const ButtonRequest* internal_default_instance() {
    return reinterpret_cast<const ButtonRequest*>(
               &_ButtonRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(ButtonRequest* other);

  // implements Message ----------------------------------------------

  inline ButtonRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ButtonRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ButtonRequest& from);
  void MergeFrom(const ButtonRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ButtonRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional .TrezorProtobuf.ButtonRequestType code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::TrezorProtobuf::ButtonRequestType code() const;
  void set_code(::TrezorProtobuf::ButtonRequestType value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.ButtonRequest)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  int code_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ButtonAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.ButtonAck) */ {
 public:
  ButtonAck();
  virtual ~ButtonAck();

  ButtonAck(const ButtonAck& from);

  inline ButtonAck& operator=(const ButtonAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonAck& default_instance();

  static inline const ButtonAck* internal_default_instance() {
    return reinterpret_cast<const ButtonAck*>(
               &_ButtonAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ButtonAck* other);

  // implements Message ----------------------------------------------

  inline ButtonAck* New() const PROTOBUF_FINAL { return New(NULL); }

  ButtonAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ButtonAck& from);
  void MergeFrom(const ButtonAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ButtonAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.ButtonAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PinMatrixRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.PinMatrixRequest) */ {
 public:
  PinMatrixRequest();
  virtual ~PinMatrixRequest();

  PinMatrixRequest(const PinMatrixRequest& from);

  inline PinMatrixRequest& operator=(const PinMatrixRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinMatrixRequest& default_instance();

  static inline const PinMatrixRequest* internal_default_instance() {
    return reinterpret_cast<const PinMatrixRequest*>(
               &_PinMatrixRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(PinMatrixRequest* other);

  // implements Message ----------------------------------------------

  inline PinMatrixRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PinMatrixRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PinMatrixRequest& from);
  void MergeFrom(const PinMatrixRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PinMatrixRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TrezorProtobuf.PinMatrixRequestType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::TrezorProtobuf::PinMatrixRequestType type() const;
  void set_type(::TrezorProtobuf::PinMatrixRequestType value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.PinMatrixRequest)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PinMatrixAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.PinMatrixAck) */ {
 public:
  PinMatrixAck();
  virtual ~PinMatrixAck();

  PinMatrixAck(const PinMatrixAck& from);

  inline PinMatrixAck& operator=(const PinMatrixAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinMatrixAck& default_instance();

  static inline const PinMatrixAck* internal_default_instance() {
    return reinterpret_cast<const PinMatrixAck*>(
               &_PinMatrixAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(PinMatrixAck* other);

  // implements Message ----------------------------------------------

  inline PinMatrixAck* New() const PROTOBUF_FINAL { return New(NULL); }

  PinMatrixAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PinMatrixAck& from);
  void MergeFrom(const PinMatrixAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PinMatrixAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pin = 1;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 1;
  const ::std::string& pin() const;
  void set_pin(const ::std::string& value);
  #if LANG_CXX11
  void set_pin(::std::string&& value);
  #endif
  void set_pin(const char* value);
  void set_pin(const char* value, size_t size);
  ::std::string* mutable_pin();
  ::std::string* release_pin();
  void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.PinMatrixAck)
 private:
  void set_has_pin();
  void clear_has_pin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pin_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cancel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Cancel) */ {
 public:
  Cancel();
  virtual ~Cancel();

  Cancel(const Cancel& from);

  inline Cancel& operator=(const Cancel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cancel& default_instance();

  static inline const Cancel* internal_default_instance() {
    return reinterpret_cast<const Cancel*>(
               &_Cancel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Cancel* other);

  // implements Message ----------------------------------------------

  inline Cancel* New() const PROTOBUF_FINAL { return New(NULL); }

  Cancel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Cancel& from);
  void MergeFrom(const Cancel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Cancel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Cancel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PassphraseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.PassphraseRequest) */ {
 public:
  PassphraseRequest();
  virtual ~PassphraseRequest();

  PassphraseRequest(const PassphraseRequest& from);

  inline PassphraseRequest& operator=(const PassphraseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassphraseRequest& default_instance();

  static inline const PassphraseRequest* internal_default_instance() {
    return reinterpret_cast<const PassphraseRequest*>(
               &_PassphraseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(PassphraseRequest* other);

  // implements Message ----------------------------------------------

  inline PassphraseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PassphraseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PassphraseRequest& from);
  void MergeFrom(const PassphraseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PassphraseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.PassphraseRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PassphraseAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.PassphraseAck) */ {
 public:
  PassphraseAck();
  virtual ~PassphraseAck();

  PassphraseAck(const PassphraseAck& from);

  inline PassphraseAck& operator=(const PassphraseAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassphraseAck& default_instance();

  static inline const PassphraseAck* internal_default_instance() {
    return reinterpret_cast<const PassphraseAck*>(
               &_PassphraseAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(PassphraseAck* other);

  // implements Message ----------------------------------------------

  inline PassphraseAck* New() const PROTOBUF_FINAL { return New(NULL); }

  PassphraseAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PassphraseAck& from);
  void MergeFrom(const PassphraseAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PassphraseAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string passphrase = 1;
  bool has_passphrase() const;
  void clear_passphrase();
  static const int kPassphraseFieldNumber = 1;
  const ::std::string& passphrase() const;
  void set_passphrase(const ::std::string& value);
  #if LANG_CXX11
  void set_passphrase(::std::string&& value);
  #endif
  void set_passphrase(const char* value);
  void set_passphrase(const char* value, size_t size);
  ::std::string* mutable_passphrase();
  ::std::string* release_passphrase();
  void set_allocated_passphrase(::std::string* passphrase);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.PassphraseAck)
 private:
  void set_has_passphrase();
  void clear_has_passphrase();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr passphrase_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEntropy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.GetEntropy) */ {
 public:
  GetEntropy();
  virtual ~GetEntropy();

  GetEntropy(const GetEntropy& from);

  inline GetEntropy& operator=(const GetEntropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEntropy& default_instance();

  static inline const GetEntropy* internal_default_instance() {
    return reinterpret_cast<const GetEntropy*>(
               &_GetEntropy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(GetEntropy* other);

  // implements Message ----------------------------------------------

  inline GetEntropy* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEntropy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEntropy& from);
  void MergeFrom(const GetEntropy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEntropy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 size = 1;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::uint32 size() const;
  void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.GetEntropy)
 private:
  void set_has_size();
  void clear_has_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Entropy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Entropy) */ {
 public:
  Entropy();
  virtual ~Entropy();

  Entropy(const Entropy& from);

  inline Entropy& operator=(const Entropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entropy& default_instance();

  static inline const Entropy* internal_default_instance() {
    return reinterpret_cast<const Entropy*>(
               &_Entropy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(Entropy* other);

  // implements Message ----------------------------------------------

  inline Entropy* New() const PROTOBUF_FINAL { return New(NULL); }

  Entropy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Entropy& from);
  void MergeFrom(const Entropy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Entropy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes entropy = 1;
  bool has_entropy() const;
  void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  const ::std::string& entropy() const;
  void set_entropy(const ::std::string& value);
  #if LANG_CXX11
  void set_entropy(::std::string&& value);
  #endif
  void set_entropy(const char* value);
  void set_entropy(const void* value, size_t size);
  ::std::string* mutable_entropy();
  ::std::string* release_entropy();
  void set_allocated_entropy(::std::string* entropy);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Entropy)
 private:
  void set_has_entropy();
  void clear_has_entropy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr entropy_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPublicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.GetPublicKey) */ {
 public:
  GetPublicKey();
  virtual ~GetPublicKey();

  GetPublicKey(const GetPublicKey& from);

  inline GetPublicKey& operator=(const GetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPublicKey& default_instance();

  static inline const GetPublicKey* internal_default_instance() {
    return reinterpret_cast<const GetPublicKey*>(
               &_GetPublicKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(GetPublicKey* other);

  // implements Message ----------------------------------------------

  inline GetPublicKey* New() const PROTOBUF_FINAL { return New(NULL); }

  GetPublicKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPublicKey& from);
  void MergeFrom(const GetPublicKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string ecdsa_curve_name = 2;
  bool has_ecdsa_curve_name() const;
  void clear_ecdsa_curve_name();
  static const int kEcdsaCurveNameFieldNumber = 2;
  const ::std::string& ecdsa_curve_name() const;
  void set_ecdsa_curve_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ecdsa_curve_name(::std::string&& value);
  #endif
  void set_ecdsa_curve_name(const char* value);
  void set_ecdsa_curve_name(const char* value, size_t size);
  ::std::string* mutable_ecdsa_curve_name();
  ::std::string* release_ecdsa_curve_name();
  void set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name);

  // optional string coin_name = 4 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional bool show_display = 3;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.GetPublicKey)
 private:
  void set_has_ecdsa_curve_name();
  void clear_has_ecdsa_curve_name();
  void set_has_show_display();
  void clear_has_show_display();
  void set_has_coin_name();
  void clear_has_coin_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr ecdsa_curve_name_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  bool show_display_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PublicKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.PublicKey) */ {
 public:
  PublicKey();
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicKey& default_instance();

  static inline const PublicKey* internal_default_instance() {
    return reinterpret_cast<const PublicKey*>(
               &_PublicKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(PublicKey* other);

  // implements Message ----------------------------------------------

  inline PublicKey* New() const PROTOBUF_FINAL { return New(NULL); }

  PublicKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string xpub = 2;
  bool has_xpub() const;
  void clear_xpub();
  static const int kXpubFieldNumber = 2;
  const ::std::string& xpub() const;
  void set_xpub(const ::std::string& value);
  #if LANG_CXX11
  void set_xpub(::std::string&& value);
  #endif
  void set_xpub(const char* value);
  void set_xpub(const char* value, size_t size);
  ::std::string* mutable_xpub();
  ::std::string* release_xpub();
  void set_allocated_xpub(::std::string* xpub);

  // required .TrezorProtobuf.HDNodeType node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::TrezorProtobuf::HDNodeType& node() const;
  ::TrezorProtobuf::HDNodeType* mutable_node();
  ::TrezorProtobuf::HDNodeType* release_node();
  void set_allocated_node(::TrezorProtobuf::HDNodeType* node);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.PublicKey)
 private:
  void set_has_node();
  void clear_has_node();
  void set_has_xpub();
  void clear_has_xpub();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr xpub_;
  ::TrezorProtobuf::HDNodeType* node_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.GetAddress) */ {
 public:
  GetAddress();
  virtual ~GetAddress();

  GetAddress(const GetAddress& from);

  inline GetAddress& operator=(const GetAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAddress& default_instance();

  static inline const GetAddress* internal_default_instance() {
    return reinterpret_cast<const GetAddress*>(
               &_GetAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(GetAddress* other);

  // implements Message ----------------------------------------------

  inline GetAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  GetAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetAddress& from);
  void MergeFrom(const GetAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string coin_name = 2 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 2;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 4;
  bool has_multisig() const;
  void clear_multisig();
  static const int kMultisigFieldNumber = 4;
  const ::TrezorProtobuf::MultisigRedeemScriptType& multisig() const;
  ::TrezorProtobuf::MultisigRedeemScriptType* mutable_multisig();
  ::TrezorProtobuf::MultisigRedeemScriptType* release_multisig();
  void set_allocated_multisig(::TrezorProtobuf::MultisigRedeemScriptType* multisig);

  // optional bool show_display = 3;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  bool show_display() const;
  void set_show_display(bool value);

  // optional .TrezorProtobuf.InputScriptType script_type = 5 [default = SPENDADDRESS];
  bool has_script_type() const;
  void clear_script_type();
  static const int kScriptTypeFieldNumber = 5;
  ::TrezorProtobuf::InputScriptType script_type() const;
  void set_script_type(::TrezorProtobuf::InputScriptType value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.GetAddress)
 private:
  void set_has_coin_name();
  void clear_has_coin_name();
  void set_has_show_display();
  void clear_has_show_display();
  void set_has_multisig();
  void clear_has_multisig();
  void set_has_script_type();
  void clear_has_script_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  ::TrezorProtobuf::MultisigRedeemScriptType* multisig_;
  bool show_display_;
  int script_type_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EthereumGetAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EthereumGetAddress) */ {
 public:
  EthereumGetAddress();
  virtual ~EthereumGetAddress();

  EthereumGetAddress(const EthereumGetAddress& from);

  inline EthereumGetAddress& operator=(const EthereumGetAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EthereumGetAddress& default_instance();

  static inline const EthereumGetAddress* internal_default_instance() {
    return reinterpret_cast<const EthereumGetAddress*>(
               &_EthereumGetAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(EthereumGetAddress* other);

  // implements Message ----------------------------------------------

  inline EthereumGetAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  EthereumGetAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EthereumGetAddress& from);
  void MergeFrom(const EthereumGetAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EthereumGetAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bool show_display = 2;
  bool has_show_display() const;
  void clear_show_display();
  static const int kShowDisplayFieldNumber = 2;
  bool show_display() const;
  void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EthereumGetAddress)
 private:
  void set_has_show_display();
  void clear_has_show_display();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool show_display_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.Address) */ {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  static inline const Address* internal_default_instance() {
    return reinterpret_cast<const Address*>(
               &_Address_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  inline Address* New() const PROTOBUF_FINAL { return New(NULL); }

  Address* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.Address)
 private:
  void set_has_address();
  void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EthereumAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EthereumAddress) */ {
 public:
  EthereumAddress();
  virtual ~EthereumAddress();

  EthereumAddress(const EthereumAddress& from);

  inline EthereumAddress& operator=(const EthereumAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EthereumAddress& default_instance();

  static inline const EthereumAddress* internal_default_instance() {
    return reinterpret_cast<const EthereumAddress*>(
               &_EthereumAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(EthereumAddress* other);

  // implements Message ----------------------------------------------

  inline EthereumAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  EthereumAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EthereumAddress& from);
  void MergeFrom(const EthereumAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EthereumAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EthereumAddress)
 private:
  void set_has_address();
  void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WipeDevice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.WipeDevice) */ {
 public:
  WipeDevice();
  virtual ~WipeDevice();

  WipeDevice(const WipeDevice& from);

  inline WipeDevice& operator=(const WipeDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WipeDevice& default_instance();

  static inline const WipeDevice* internal_default_instance() {
    return reinterpret_cast<const WipeDevice*>(
               &_WipeDevice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(WipeDevice* other);

  // implements Message ----------------------------------------------

  inline WipeDevice* New() const PROTOBUF_FINAL { return New(NULL); }

  WipeDevice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WipeDevice& from);
  void MergeFrom(const WipeDevice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WipeDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.WipeDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoadDevice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.LoadDevice) */ {
 public:
  LoadDevice();
  virtual ~LoadDevice();

  LoadDevice(const LoadDevice& from);

  inline LoadDevice& operator=(const LoadDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDevice& default_instance();

  static inline const LoadDevice* internal_default_instance() {
    return reinterpret_cast<const LoadDevice*>(
               &_LoadDevice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(LoadDevice* other);

  // implements Message ----------------------------------------------

  inline LoadDevice* New() const PROTOBUF_FINAL { return New(NULL); }

  LoadDevice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoadDevice& from);
  void MergeFrom(const LoadDevice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoadDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mnemonic = 1;
  bool has_mnemonic() const;
  void clear_mnemonic();
  static const int kMnemonicFieldNumber = 1;
  const ::std::string& mnemonic() const;
  void set_mnemonic(const ::std::string& value);
  #if LANG_CXX11
  void set_mnemonic(::std::string&& value);
  #endif
  void set_mnemonic(const char* value);
  void set_mnemonic(const char* value, size_t size);
  ::std::string* mutable_mnemonic();
  ::std::string* release_mnemonic();
  void set_allocated_mnemonic(::std::string* mnemonic);

  // optional string pin = 3;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 3;
  const ::std::string& pin() const;
  void set_pin(const ::std::string& value);
  #if LANG_CXX11
  void set_pin(::std::string&& value);
  #endif
  void set_pin(const char* value);
  void set_pin(const char* value, size_t size);
  ::std::string* mutable_pin();
  ::std::string* release_pin();
  void set_allocated_pin(::std::string* pin);

  // optional string language = 5 [default = "english"];
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 5;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string label = 6;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 6;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional .TrezorProtobuf.HDNodeType node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::TrezorProtobuf::HDNodeType& node() const;
  ::TrezorProtobuf::HDNodeType* mutable_node();
  ::TrezorProtobuf::HDNodeType* release_node();
  void set_allocated_node(::TrezorProtobuf::HDNodeType* node);

  // optional bool passphrase_protection = 4;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 4;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // optional bool skip_checksum = 7;
  bool has_skip_checksum() const;
  void clear_skip_checksum();
  static const int kSkipChecksumFieldNumber = 7;
  bool skip_checksum() const;
  void set_skip_checksum(bool value);

  // optional uint32 u2f_counter = 8;
  bool has_u2f_counter() const;
  void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 8;
  ::google::protobuf::uint32 u2f_counter() const;
  void set_u2f_counter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.LoadDevice)
 private:
  void set_has_mnemonic();
  void clear_has_mnemonic();
  void set_has_node();
  void clear_has_node();
  void set_has_pin();
  void clear_has_pin();
  void set_has_passphrase_protection();
  void clear_has_passphrase_protection();
  void set_has_language();
  void clear_has_language();
  void set_has_label();
  void clear_has_label();
  void set_has_skip_checksum();
  void clear_has_skip_checksum();
  void set_has_u2f_counter();
  void clear_has_u2f_counter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mnemonic_;
  ::google::protobuf::internal::ArenaStringPtr pin_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_language_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::TrezorProtobuf::HDNodeType* node_;
  bool passphrase_protection_;
  bool skip_checksum_;
  ::google::protobuf::uint32 u2f_counter_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetDevice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.ResetDevice) */ {
 public:
  ResetDevice();
  virtual ~ResetDevice();

  ResetDevice(const ResetDevice& from);

  inline ResetDevice& operator=(const ResetDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetDevice& default_instance();

  static inline const ResetDevice* internal_default_instance() {
    return reinterpret_cast<const ResetDevice*>(
               &_ResetDevice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ResetDevice* other);

  // implements Message ----------------------------------------------

  inline ResetDevice* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetDevice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetDevice& from);
  void MergeFrom(const ResetDevice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string language = 5 [default = "english"];
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 5;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string label = 6;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 6;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional bool display_random = 1;
  bool has_display_random() const;
  void clear_display_random();
  static const int kDisplayRandomFieldNumber = 1;
  bool display_random() const;
  void set_display_random(bool value);

  // optional bool passphrase_protection = 3;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 3;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // optional bool pin_protection = 4;
  bool has_pin_protection() const;
  void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 4;
  bool pin_protection() const;
  void set_pin_protection(bool value);

  // optional uint32 u2f_counter = 7;
  bool has_u2f_counter() const;
  void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 7;
  ::google::protobuf::uint32 u2f_counter() const;
  void set_u2f_counter(::google::protobuf::uint32 value);

  // optional uint32 strength = 2 [default = 256];
  bool has_strength() const;
  void clear_strength();
  static const int kStrengthFieldNumber = 2;
  ::google::protobuf::uint32 strength() const;
  void set_strength(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.ResetDevice)
 private:
  void set_has_display_random();
  void clear_has_display_random();
  void set_has_strength();
  void clear_has_strength();
  void set_has_passphrase_protection();
  void clear_has_passphrase_protection();
  void set_has_pin_protection();
  void clear_has_pin_protection();
  void set_has_language();
  void clear_has_language();
  void set_has_label();
  void clear_has_label();
  void set_has_u2f_counter();
  void clear_has_u2f_counter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_language_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  bool display_random_;
  bool passphrase_protection_;
  bool pin_protection_;
  ::google::protobuf::uint32 u2f_counter_;
  ::google::protobuf::uint32 strength_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntropyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EntropyRequest) */ {
 public:
  EntropyRequest();
  virtual ~EntropyRequest();

  EntropyRequest(const EntropyRequest& from);

  inline EntropyRequest& operator=(const EntropyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntropyRequest& default_instance();

  static inline const EntropyRequest* internal_default_instance() {
    return reinterpret_cast<const EntropyRequest*>(
               &_EntropyRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(EntropyRequest* other);

  // implements Message ----------------------------------------------

  inline EntropyRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EntropyRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntropyRequest& from);
  void MergeFrom(const EntropyRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntropyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EntropyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntropyAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EntropyAck) */ {
 public:
  EntropyAck();
  virtual ~EntropyAck();

  EntropyAck(const EntropyAck& from);

  inline EntropyAck& operator=(const EntropyAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntropyAck& default_instance();

  static inline const EntropyAck* internal_default_instance() {
    return reinterpret_cast<const EntropyAck*>(
               &_EntropyAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(EntropyAck* other);

  // implements Message ----------------------------------------------

  inline EntropyAck* New() const PROTOBUF_FINAL { return New(NULL); }

  EntropyAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntropyAck& from);
  void MergeFrom(const EntropyAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntropyAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes entropy = 1;
  bool has_entropy() const;
  void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  const ::std::string& entropy() const;
  void set_entropy(const ::std::string& value);
  #if LANG_CXX11
  void set_entropy(::std::string&& value);
  #endif
  void set_entropy(const char* value);
  void set_entropy(const void* value, size_t size);
  ::std::string* mutable_entropy();
  ::std::string* release_entropy();
  void set_allocated_entropy(::std::string* entropy);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EntropyAck)
 private:
  void set_has_entropy();
  void clear_has_entropy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr entropy_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RecoveryDevice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.RecoveryDevice) */ {
 public:
  RecoveryDevice();
  virtual ~RecoveryDevice();

  RecoveryDevice(const RecoveryDevice& from);

  inline RecoveryDevice& operator=(const RecoveryDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecoveryDevice& default_instance();

  static inline const RecoveryDevice* internal_default_instance() {
    return reinterpret_cast<const RecoveryDevice*>(
               &_RecoveryDevice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(RecoveryDevice* other);

  // implements Message ----------------------------------------------

  inline RecoveryDevice* New() const PROTOBUF_FINAL { return New(NULL); }

  RecoveryDevice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RecoveryDevice& from);
  void MergeFrom(const RecoveryDevice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RecoveryDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string language = 4 [default = "english"];
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 4;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string label = 5;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 5;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional uint32 word_count = 1;
  bool has_word_count() const;
  void clear_word_count();
  static const int kWordCountFieldNumber = 1;
  ::google::protobuf::uint32 word_count() const;
  void set_word_count(::google::protobuf::uint32 value);

  // optional bool passphrase_protection = 2;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 2;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // optional bool pin_protection = 3;
  bool has_pin_protection() const;
  void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 3;
  bool pin_protection() const;
  void set_pin_protection(bool value);

  // optional bool enforce_wordlist = 6;
  bool has_enforce_wordlist() const;
  void clear_enforce_wordlist();
  static const int kEnforceWordlistFieldNumber = 6;
  bool enforce_wordlist() const;
  void set_enforce_wordlist(bool value);

  // optional uint32 type = 8;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 u2f_counter = 9;
  bool has_u2f_counter() const;
  void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 9;
  ::google::protobuf::uint32 u2f_counter() const;
  void set_u2f_counter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.RecoveryDevice)
 private:
  void set_has_word_count();
  void clear_has_word_count();
  void set_has_passphrase_protection();
  void clear_has_passphrase_protection();
  void set_has_pin_protection();
  void clear_has_pin_protection();
  void set_has_language();
  void clear_has_language();
  void set_has_label();
  void clear_has_label();
  void set_has_enforce_wordlist();
  void clear_has_enforce_wordlist();
  void set_has_type();
  void clear_has_type();
  void set_has_u2f_counter();
  void clear_has_u2f_counter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_language_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::uint32 word_count_;
  bool passphrase_protection_;
  bool pin_protection_;
  bool enforce_wordlist_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 u2f_counter_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WordRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.WordRequest) */ {
 public:
  WordRequest();
  virtual ~WordRequest();

  WordRequest(const WordRequest& from);

  inline WordRequest& operator=(const WordRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordRequest& default_instance();

  static inline const WordRequest* internal_default_instance() {
    return reinterpret_cast<const WordRequest*>(
               &_WordRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(WordRequest* other);

  // implements Message ----------------------------------------------

  inline WordRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  WordRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WordRequest& from);
  void MergeFrom(const WordRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WordRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TrezorProtobuf.WordRequestType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::TrezorProtobuf::WordRequestType type() const;
  void set_type(::TrezorProtobuf::WordRequestType value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.WordRequest)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WordAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.WordAck) */ {
 public:
  WordAck();
  virtual ~WordAck();

  WordAck(const WordAck& from);

  inline WordAck& operator=(const WordAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordAck& default_instance();

  static inline const WordAck* internal_default_instance() {
    return reinterpret_cast<const WordAck*>(
               &_WordAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(WordAck* other);

  // implements Message ----------------------------------------------

  inline WordAck* New() const PROTOBUF_FINAL { return New(NULL); }

  WordAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WordAck& from);
  void MergeFrom(const WordAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WordAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string word = 1;
  bool has_word() const;
  void clear_word();
  static const int kWordFieldNumber = 1;
  const ::std::string& word() const;
  void set_word(const ::std::string& value);
  #if LANG_CXX11
  void set_word(::std::string&& value);
  #endif
  void set_word(const char* value);
  void set_word(const char* value, size_t size);
  ::std::string* mutable_word();
  ::std::string* release_word();
  void set_allocated_word(::std::string* word);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.WordAck)
 private:
  void set_has_word();
  void clear_has_word();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr word_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.SignMessage) */ {
 public:
  SignMessage();
  virtual ~SignMessage();

  SignMessage(const SignMessage& from);

  inline SignMessage& operator=(const SignMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignMessage& default_instance();

  static inline const SignMessage* internal_default_instance() {
    return reinterpret_cast<const SignMessage*>(
               &_SignMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(SignMessage* other);

  // implements Message ----------------------------------------------

  inline SignMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  SignMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignMessage& from);
  void MergeFrom(const SignMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string coin_name = 3 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.SignMessage)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_coin_name();
  void clear_has_coin_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.VerifyMessage) */ {
 public:
  VerifyMessage();
  virtual ~VerifyMessage();

  VerifyMessage(const VerifyMessage& from);

  inline VerifyMessage& operator=(const VerifyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyMessage& default_instance();

  static inline const VerifyMessage* internal_default_instance() {
    return reinterpret_cast<const VerifyMessage*>(
               &_VerifyMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(VerifyMessage* other);

  // implements Message ----------------------------------------------

  inline VerifyMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyMessage& from);
  void MergeFrom(const VerifyMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional bytes message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string coin_name = 4 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.VerifyMessage)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_signature();
  void clear_has_signature();
  void set_has_message();
  void clear_has_message();
  void set_has_coin_name();
  void clear_has_coin_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageSignature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.MessageSignature) */ {
 public:
  MessageSignature();
  virtual ~MessageSignature();

  MessageSignature(const MessageSignature& from);

  inline MessageSignature& operator=(const MessageSignature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageSignature& default_instance();

  static inline const MessageSignature* internal_default_instance() {
    return reinterpret_cast<const MessageSignature*>(
               &_MessageSignature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(MessageSignature* other);

  // implements Message ----------------------------------------------

  inline MessageSignature* New() const PROTOBUF_FINAL { return New(NULL); }

  MessageSignature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MessageSignature& from);
  void MergeFrom(const MessageSignature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MessageSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.MessageSignature)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_signature();
  void clear_has_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EncryptMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EncryptMessage) */ {
 public:
  EncryptMessage();
  virtual ~EncryptMessage();

  EncryptMessage(const EncryptMessage& from);

  inline EncryptMessage& operator=(const EncryptMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptMessage& default_instance();

  static inline const EncryptMessage* internal_default_instance() {
    return reinterpret_cast<const EncryptMessage*>(
               &_EncryptMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(EncryptMessage* other);

  // implements Message ----------------------------------------------

  inline EncryptMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  EncryptMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EncryptMessage& from);
  void MergeFrom(const EncryptMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EncryptMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 4;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 4;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes pubkey = 1;
  bool has_pubkey() const;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 1;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const void* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // optional bytes message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string coin_name = 5 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 5;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional bool display_only = 3;
  bool has_display_only() const;
  void clear_display_only();
  static const int kDisplayOnlyFieldNumber = 3;
  bool display_only() const;
  void set_display_only(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EncryptMessage)
 private:
  void set_has_pubkey();
  void clear_has_pubkey();
  void set_has_message();
  void clear_has_message();
  void set_has_display_only();
  void clear_has_display_only();
  void set_has_coin_name();
  void clear_has_coin_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  bool display_only_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EncryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EncryptedMessage) */ {
 public:
  EncryptedMessage();
  virtual ~EncryptedMessage();

  EncryptedMessage(const EncryptedMessage& from);

  inline EncryptedMessage& operator=(const EncryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptedMessage& default_instance();

  static inline const EncryptedMessage* internal_default_instance() {
    return reinterpret_cast<const EncryptedMessage*>(
               &_EncryptedMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(EncryptedMessage* other);

  // implements Message ----------------------------------------------

  inline EncryptedMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  EncryptedMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EncryptedMessage& from);
  void MergeFrom(const EncryptedMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EncryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes nonce = 1;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 1;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // optional bytes message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional bytes hmac = 3;
  bool has_hmac() const;
  void clear_hmac();
  static const int kHmacFieldNumber = 3;
  const ::std::string& hmac() const;
  void set_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_hmac(::std::string&& value);
  #endif
  void set_hmac(const char* value);
  void set_hmac(const void* value, size_t size);
  ::std::string* mutable_hmac();
  ::std::string* release_hmac();
  void set_allocated_hmac(::std::string* hmac);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EncryptedMessage)
 private:
  void set_has_nonce();
  void clear_has_nonce();
  void set_has_message();
  void clear_has_message();
  void set_has_hmac();
  void clear_has_hmac();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr hmac_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecryptMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DecryptMessage) */ {
 public:
  DecryptMessage();
  virtual ~DecryptMessage();

  DecryptMessage(const DecryptMessage& from);

  inline DecryptMessage& operator=(const DecryptMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecryptMessage& default_instance();

  static inline const DecryptMessage* internal_default_instance() {
    return reinterpret_cast<const DecryptMessage*>(
               &_DecryptMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(DecryptMessage* other);

  // implements Message ----------------------------------------------

  inline DecryptMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  DecryptMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DecryptMessage& from);
  void MergeFrom(const DecryptMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DecryptMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes nonce = 2;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // optional bytes message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional bytes hmac = 4;
  bool has_hmac() const;
  void clear_hmac();
  static const int kHmacFieldNumber = 4;
  const ::std::string& hmac() const;
  void set_hmac(const ::std::string& value);
  #if LANG_CXX11
  void set_hmac(::std::string&& value);
  #endif
  void set_hmac(const char* value);
  void set_hmac(const void* value, size_t size);
  ::std::string* mutable_hmac();
  ::std::string* release_hmac();
  void set_allocated_hmac(::std::string* hmac);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DecryptMessage)
 private:
  void set_has_nonce();
  void clear_has_nonce();
  void set_has_message();
  void clear_has_message();
  void set_has_hmac();
  void clear_has_hmac();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr hmac_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecryptedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DecryptedMessage) */ {
 public:
  DecryptedMessage();
  virtual ~DecryptedMessage();

  DecryptedMessage(const DecryptedMessage& from);

  inline DecryptedMessage& operator=(const DecryptedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecryptedMessage& default_instance();

  static inline const DecryptedMessage* internal_default_instance() {
    return reinterpret_cast<const DecryptedMessage*>(
               &_DecryptedMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(DecryptedMessage* other);

  // implements Message ----------------------------------------------

  inline DecryptedMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  DecryptedMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DecryptedMessage& from);
  void MergeFrom(const DecryptedMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DecryptedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string address = 2;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DecryptedMessage)
 private:
  void set_has_message();
  void clear_has_message();
  void set_has_address();
  void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CipherKeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.CipherKeyValue) */ {
 public:
  CipherKeyValue();
  virtual ~CipherKeyValue();

  CipherKeyValue(const CipherKeyValue& from);

  inline CipherKeyValue& operator=(const CipherKeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CipherKeyValue& default_instance();

  static inline const CipherKeyValue* internal_default_instance() {
    return reinterpret_cast<const CipherKeyValue*>(
               &_CipherKeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(CipherKeyValue* other);

  // implements Message ----------------------------------------------

  inline CipherKeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  CipherKeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CipherKeyValue& from);
  void MergeFrom(const CipherKeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CipherKeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes iv = 7;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 7;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional bool encrypt = 4;
  bool has_encrypt() const;
  void clear_encrypt();
  static const int kEncryptFieldNumber = 4;
  bool encrypt() const;
  void set_encrypt(bool value);

  // optional bool ask_on_encrypt = 5;
  bool has_ask_on_encrypt() const;
  void clear_ask_on_encrypt();
  static const int kAskOnEncryptFieldNumber = 5;
  bool ask_on_encrypt() const;
  void set_ask_on_encrypt(bool value);

  // optional bool ask_on_decrypt = 6;
  bool has_ask_on_decrypt() const;
  void clear_ask_on_decrypt();
  static const int kAskOnDecryptFieldNumber = 6;
  bool ask_on_decrypt() const;
  void set_ask_on_decrypt(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.CipherKeyValue)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();
  void set_has_encrypt();
  void clear_has_encrypt();
  void set_has_ask_on_encrypt();
  void clear_has_ask_on_encrypt();
  void set_has_ask_on_decrypt();
  void clear_has_ask_on_decrypt();
  void set_has_iv();
  void clear_has_iv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  bool encrypt_;
  bool ask_on_encrypt_;
  bool ask_on_decrypt_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CipheredKeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.CipheredKeyValue) */ {
 public:
  CipheredKeyValue();
  virtual ~CipheredKeyValue();

  CipheredKeyValue(const CipheredKeyValue& from);

  inline CipheredKeyValue& operator=(const CipheredKeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CipheredKeyValue& default_instance();

  static inline const CipheredKeyValue* internal_default_instance() {
    return reinterpret_cast<const CipheredKeyValue*>(
               &_CipheredKeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(CipheredKeyValue* other);

  // implements Message ----------------------------------------------

  inline CipheredKeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  CipheredKeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CipheredKeyValue& from);
  void MergeFrom(const CipheredKeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CipheredKeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.CipheredKeyValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EstimateTxSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EstimateTxSize) */ {
 public:
  EstimateTxSize();
  virtual ~EstimateTxSize();

  EstimateTxSize(const EstimateTxSize& from);

  inline EstimateTxSize& operator=(const EstimateTxSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EstimateTxSize& default_instance();

  static inline const EstimateTxSize* internal_default_instance() {
    return reinterpret_cast<const EstimateTxSize*>(
               &_EstimateTxSize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(EstimateTxSize* other);

  // implements Message ----------------------------------------------

  inline EstimateTxSize* New() const PROTOBUF_FINAL { return New(NULL); }

  EstimateTxSize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EstimateTxSize& from);
  void MergeFrom(const EstimateTxSize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EstimateTxSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string coin_name = 3 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // required uint32 outputs_count = 1;
  bool has_outputs_count() const;
  void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 1;
  ::google::protobuf::uint32 outputs_count() const;
  void set_outputs_count(::google::protobuf::uint32 value);

  // required uint32 inputs_count = 2;
  bool has_inputs_count() const;
  void clear_inputs_count();
  static const int kInputsCountFieldNumber = 2;
  ::google::protobuf::uint32 inputs_count() const;
  void set_inputs_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EstimateTxSize)
 private:
  void set_has_outputs_count();
  void clear_has_outputs_count();
  void set_has_inputs_count();
  void clear_has_inputs_count();
  void set_has_coin_name();
  void clear_has_coin_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxSize) */ {
 public:
  TxSize();
  virtual ~TxSize();

  TxSize(const TxSize& from);

  inline TxSize& operator=(const TxSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSize& default_instance();

  static inline const TxSize* internal_default_instance() {
    return reinterpret_cast<const TxSize*>(
               &_TxSize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(TxSize* other);

  // implements Message ----------------------------------------------

  inline TxSize* New() const PROTOBUF_FINAL { return New(NULL); }

  TxSize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxSize& from);
  void MergeFrom(const TxSize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tx_size = 1;
  bool has_tx_size() const;
  void clear_tx_size();
  static const int kTxSizeFieldNumber = 1;
  ::google::protobuf::uint32 tx_size() const;
  void set_tx_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxSize)
 private:
  void set_has_tx_size();
  void clear_has_tx_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 tx_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.SignTx) */ {
 public:
  SignTx();
  virtual ~SignTx();

  SignTx(const SignTx& from);

  inline SignTx& operator=(const SignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTx& default_instance();

  static inline const SignTx* internal_default_instance() {
    return reinterpret_cast<const SignTx*>(
               &_SignTx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(SignTx* other);

  // implements Message ----------------------------------------------

  inline SignTx* New() const PROTOBUF_FINAL { return New(NULL); }

  SignTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignTx& from);
  void MergeFrom(const SignTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string coin_name = 3 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // required uint32 outputs_count = 1;
  bool has_outputs_count() const;
  void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 1;
  ::google::protobuf::uint32 outputs_count() const;
  void set_outputs_count(::google::protobuf::uint32 value);

  // required uint32 inputs_count = 2;
  bool has_inputs_count() const;
  void clear_inputs_count();
  static const int kInputsCountFieldNumber = 2;
  ::google::protobuf::uint32 inputs_count() const;
  void set_inputs_count(::google::protobuf::uint32 value);

  // optional uint32 lock_time = 5 [default = 0];
  bool has_lock_time() const;
  void clear_lock_time();
  static const int kLockTimeFieldNumber = 5;
  ::google::protobuf::uint32 lock_time() const;
  void set_lock_time(::google::protobuf::uint32 value);

  // optional uint32 version = 4 [default = 1];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.SignTx)
 private:
  void set_has_outputs_count();
  void clear_has_outputs_count();
  void set_has_inputs_count();
  void clear_has_inputs_count();
  void set_has_coin_name();
  void clear_has_coin_name();
  void set_has_version();
  void clear_has_version();
  void set_has_lock_time();
  void clear_has_lock_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SimpleSignTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.SimpleSignTx) */ {
 public:
  SimpleSignTx();
  virtual ~SimpleSignTx();

  SimpleSignTx(const SimpleSignTx& from);

  inline SimpleSignTx& operator=(const SimpleSignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleSignTx& default_instance();

  static inline const SimpleSignTx* internal_default_instance() {
    return reinterpret_cast<const SimpleSignTx*>(
               &_SimpleSignTx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(SimpleSignTx* other);

  // implements Message ----------------------------------------------

  inline SimpleSignTx* New() const PROTOBUF_FINAL { return New(NULL); }

  SimpleSignTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SimpleSignTx& from);
  void MergeFrom(const SimpleSignTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SimpleSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TrezorProtobuf.TxInputType inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::TrezorProtobuf::TxInputType& inputs(int index) const;
  ::TrezorProtobuf::TxInputType* mutable_inputs(int index);
  ::TrezorProtobuf::TxInputType* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >&
      inputs() const;

  // repeated .TrezorProtobuf.TxOutputType outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::TrezorProtobuf::TxOutputType& outputs(int index) const;
  ::TrezorProtobuf::TxOutputType* mutable_outputs(int index);
  ::TrezorProtobuf::TxOutputType* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >&
      outputs() const;

  // repeated .TrezorProtobuf.TransactionType transactions = 3;
  int transactions_size() const;
  void clear_transactions();
  static const int kTransactionsFieldNumber = 3;
  const ::TrezorProtobuf::TransactionType& transactions(int index) const;
  ::TrezorProtobuf::TransactionType* mutable_transactions(int index);
  ::TrezorProtobuf::TransactionType* add_transactions();
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TransactionType >*
      mutable_transactions();
  const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TransactionType >&
      transactions() const;

  // optional string coin_name = 4 [default = "Bitcoin"];
  bool has_coin_name() const;
  void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  const ::std::string& coin_name() const;
  void set_coin_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coin_name(::std::string&& value);
  #endif
  void set_coin_name(const char* value);
  void set_coin_name(const char* value, size_t size);
  ::std::string* mutable_coin_name();
  ::std::string* release_coin_name();
  void set_allocated_coin_name(::std::string* coin_name);

  // optional uint32 lock_time = 6 [default = 0];
  bool has_lock_time() const;
  void clear_lock_time();
  static const int kLockTimeFieldNumber = 6;
  ::google::protobuf::uint32 lock_time() const;
  void set_lock_time(::google::protobuf::uint32 value);

  // optional uint32 version = 5 [default = 1];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.SimpleSignTx)
 private:
  void set_has_coin_name();
  void clear_has_coin_name();
  void set_has_version();
  void clear_has_version();
  void set_has_lock_time();
  void clear_has_lock_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType > inputs_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType > outputs_;
  ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TransactionType > transactions_;
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _default_coin_name_;
  ::google::protobuf::internal::ArenaStringPtr coin_name_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxRequest) */ {
 public:
  TxRequest();
  virtual ~TxRequest();

  TxRequest(const TxRequest& from);

  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequest& default_instance();

  static inline const TxRequest* internal_default_instance() {
    return reinterpret_cast<const TxRequest*>(
               &_TxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(TxRequest* other);

  // implements Message ----------------------------------------------

  inline TxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  TxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxRequest& from);
  void MergeFrom(const TxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TrezorProtobuf.TxRequestDetailsType details = 2;
  bool has_details() const;
  void clear_details();
  static const int kDetailsFieldNumber = 2;
  const ::TrezorProtobuf::TxRequestDetailsType& details() const;
  ::TrezorProtobuf::TxRequestDetailsType* mutable_details();
  ::TrezorProtobuf::TxRequestDetailsType* release_details();
  void set_allocated_details(::TrezorProtobuf::TxRequestDetailsType* details);

  // optional .TrezorProtobuf.TxRequestSerializedType serialized = 3;
  bool has_serialized() const;
  void clear_serialized();
  static const int kSerializedFieldNumber = 3;
  const ::TrezorProtobuf::TxRequestSerializedType& serialized() const;
  ::TrezorProtobuf::TxRequestSerializedType* mutable_serialized();
  ::TrezorProtobuf::TxRequestSerializedType* release_serialized();
  void set_allocated_serialized(::TrezorProtobuf::TxRequestSerializedType* serialized);

  // optional .TrezorProtobuf.RequestType request_type = 1;
  bool has_request_type() const;
  void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  ::TrezorProtobuf::RequestType request_type() const;
  void set_request_type(::TrezorProtobuf::RequestType value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxRequest)
 private:
  void set_has_request_type();
  void clear_has_request_type();
  void set_has_details();
  void clear_has_details();
  void set_has_serialized();
  void clear_has_serialized();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::TrezorProtobuf::TxRequestDetailsType* details_;
  ::TrezorProtobuf::TxRequestSerializedType* serialized_;
  int request_type_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.TxAck) */ {
 public:
  TxAck();
  virtual ~TxAck();

  TxAck(const TxAck& from);

  inline TxAck& operator=(const TxAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAck& default_instance();

  static inline const TxAck* internal_default_instance() {
    return reinterpret_cast<const TxAck*>(
               &_TxAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(TxAck* other);

  // implements Message ----------------------------------------------

  inline TxAck* New() const PROTOBUF_FINAL { return New(NULL); }

  TxAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxAck& from);
  void MergeFrom(const TxAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TrezorProtobuf.TransactionType tx = 1;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::TrezorProtobuf::TransactionType& tx() const;
  ::TrezorProtobuf::TransactionType* mutable_tx();
  ::TrezorProtobuf::TransactionType* release_tx();
  void set_allocated_tx(::TrezorProtobuf::TransactionType* tx);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.TxAck)
 private:
  void set_has_tx();
  void clear_has_tx();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::TrezorProtobuf::TransactionType* tx_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EthereumSignTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EthereumSignTx) */ {
 public:
  EthereumSignTx();
  virtual ~EthereumSignTx();

  EthereumSignTx(const EthereumSignTx& from);

  inline EthereumSignTx& operator=(const EthereumSignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EthereumSignTx& default_instance();

  static inline const EthereumSignTx* internal_default_instance() {
    return reinterpret_cast<const EthereumSignTx*>(
               &_EthereumSignTx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(EthereumSignTx* other);

  // implements Message ----------------------------------------------

  inline EthereumSignTx* New() const PROTOBUF_FINAL { return New(NULL); }

  EthereumSignTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EthereumSignTx& from);
  void MergeFrom(const EthereumSignTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EthereumSignTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  int address_n_size() const;
  void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  ::google::protobuf::uint32 address_n(int index) const;
  void set_address_n(int index, ::google::protobuf::uint32 value);
  void add_address_n(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes nonce = 2;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 2;
  const ::std::string& nonce() const;
  void set_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_nonce(::std::string&& value);
  #endif
  void set_nonce(const char* value);
  void set_nonce(const void* value, size_t size);
  ::std::string* mutable_nonce();
  ::std::string* release_nonce();
  void set_allocated_nonce(::std::string* nonce);

  // optional bytes gas_price = 3;
  bool has_gas_price() const;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 3;
  const ::std::string& gas_price() const;
  void set_gas_price(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_price(::std::string&& value);
  #endif
  void set_gas_price(const char* value);
  void set_gas_price(const void* value, size_t size);
  ::std::string* mutable_gas_price();
  ::std::string* release_gas_price();
  void set_allocated_gas_price(::std::string* gas_price);

  // optional bytes gas_limit = 4;
  bool has_gas_limit() const;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 4;
  const ::std::string& gas_limit() const;
  void set_gas_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_limit(::std::string&& value);
  #endif
  void set_gas_limit(const char* value);
  void set_gas_limit(const void* value, size_t size);
  ::std::string* mutable_gas_limit();
  ::std::string* release_gas_limit();
  void set_allocated_gas_limit(::std::string* gas_limit);

  // optional bytes to = 5;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 5;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const void* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional bytes value = 6;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 6;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional bytes data_initial_chunk = 7;
  bool has_data_initial_chunk() const;
  void clear_data_initial_chunk();
  static const int kDataInitialChunkFieldNumber = 7;
  const ::std::string& data_initial_chunk() const;
  void set_data_initial_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_data_initial_chunk(::std::string&& value);
  #endif
  void set_data_initial_chunk(const char* value);
  void set_data_initial_chunk(const void* value, size_t size);
  ::std::string* mutable_data_initial_chunk();
  ::std::string* release_data_initial_chunk();
  void set_allocated_data_initial_chunk(::std::string* data_initial_chunk);

  // optional uint32 data_length = 8;
  bool has_data_length() const;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 8;
  ::google::protobuf::uint32 data_length() const;
  void set_data_length(::google::protobuf::uint32 value);

  // optional uint32 chain_id = 9;
  bool has_chain_id() const;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 9;
  ::google::protobuf::uint32 chain_id() const;
  void set_chain_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EthereumSignTx)
 private:
  void set_has_nonce();
  void clear_has_nonce();
  void set_has_gas_price();
  void clear_has_gas_price();
  void set_has_gas_limit();
  void clear_has_gas_limit();
  void set_has_to();
  void clear_has_to();
  void set_has_value();
  void clear_has_value();
  void set_has_data_initial_chunk();
  void clear_has_data_initial_chunk();
  void set_has_data_length();
  void clear_has_data_length();
  void set_has_chain_id();
  void clear_has_chain_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::internal::ArenaStringPtr nonce_;
  ::google::protobuf::internal::ArenaStringPtr gas_price_;
  ::google::protobuf::internal::ArenaStringPtr gas_limit_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr data_initial_chunk_;
  ::google::protobuf::uint32 data_length_;
  ::google::protobuf::uint32 chain_id_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EthereumTxRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EthereumTxRequest) */ {
 public:
  EthereumTxRequest();
  virtual ~EthereumTxRequest();

  EthereumTxRequest(const EthereumTxRequest& from);

  inline EthereumTxRequest& operator=(const EthereumTxRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EthereumTxRequest& default_instance();

  static inline const EthereumTxRequest* internal_default_instance() {
    return reinterpret_cast<const EthereumTxRequest*>(
               &_EthereumTxRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(EthereumTxRequest* other);

  // implements Message ----------------------------------------------

  inline EthereumTxRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EthereumTxRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EthereumTxRequest& from);
  void MergeFrom(const EthereumTxRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EthereumTxRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes signature_r = 3;
  bool has_signature_r() const;
  void clear_signature_r();
  static const int kSignatureRFieldNumber = 3;
  const ::std::string& signature_r() const;
  void set_signature_r(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_r(::std::string&& value);
  #endif
  void set_signature_r(const char* value);
  void set_signature_r(const void* value, size_t size);
  ::std::string* mutable_signature_r();
  ::std::string* release_signature_r();
  void set_allocated_signature_r(::std::string* signature_r);

  // optional bytes signature_s = 4;
  bool has_signature_s() const;
  void clear_signature_s();
  static const int kSignatureSFieldNumber = 4;
  const ::std::string& signature_s() const;
  void set_signature_s(const ::std::string& value);
  #if LANG_CXX11
  void set_signature_s(::std::string&& value);
  #endif
  void set_signature_s(const char* value);
  void set_signature_s(const void* value, size_t size);
  ::std::string* mutable_signature_s();
  ::std::string* release_signature_s();
  void set_allocated_signature_s(::std::string* signature_s);

  // optional uint32 data_length = 1;
  bool has_data_length() const;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 1;
  ::google::protobuf::uint32 data_length() const;
  void set_data_length(::google::protobuf::uint32 value);

  // optional uint32 signature_v = 2;
  bool has_signature_v() const;
  void clear_signature_v();
  static const int kSignatureVFieldNumber = 2;
  ::google::protobuf::uint32 signature_v() const;
  void set_signature_v(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EthereumTxRequest)
 private:
  void set_has_data_length();
  void clear_has_data_length();
  void set_has_signature_v();
  void clear_has_signature_v();
  void set_has_signature_r();
  void clear_has_signature_r();
  void set_has_signature_s();
  void clear_has_signature_s();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr signature_r_;
  ::google::protobuf::internal::ArenaStringPtr signature_s_;
  ::google::protobuf::uint32 data_length_;
  ::google::protobuf::uint32 signature_v_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EthereumTxAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.EthereumTxAck) */ {
 public:
  EthereumTxAck();
  virtual ~EthereumTxAck();

  EthereumTxAck(const EthereumTxAck& from);

  inline EthereumTxAck& operator=(const EthereumTxAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EthereumTxAck& default_instance();

  static inline const EthereumTxAck* internal_default_instance() {
    return reinterpret_cast<const EthereumTxAck*>(
               &_EthereumTxAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(EthereumTxAck* other);

  // implements Message ----------------------------------------------

  inline EthereumTxAck* New() const PROTOBUF_FINAL { return New(NULL); }

  EthereumTxAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EthereumTxAck& from);
  void MergeFrom(const EthereumTxAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EthereumTxAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data_chunk = 1;
  bool has_data_chunk() const;
  void clear_data_chunk();
  static const int kDataChunkFieldNumber = 1;
  const ::std::string& data_chunk() const;
  void set_data_chunk(const ::std::string& value);
  #if LANG_CXX11
  void set_data_chunk(::std::string&& value);
  #endif
  void set_data_chunk(const char* value);
  void set_data_chunk(const void* value, size_t size);
  ::std::string* mutable_data_chunk();
  ::std::string* release_data_chunk();
  void set_allocated_data_chunk(::std::string* data_chunk);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.EthereumTxAck)
 private:
  void set_has_data_chunk();
  void clear_has_data_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_chunk_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignIdentity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.SignIdentity) */ {
 public:
  SignIdentity();
  virtual ~SignIdentity();

  SignIdentity(const SignIdentity& from);

  inline SignIdentity& operator=(const SignIdentity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignIdentity& default_instance();

  static inline const SignIdentity* internal_default_instance() {
    return reinterpret_cast<const SignIdentity*>(
               &_SignIdentity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(SignIdentity* other);

  // implements Message ----------------------------------------------

  inline SignIdentity* New() const PROTOBUF_FINAL { return New(NULL); }

  SignIdentity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignIdentity& from);
  void MergeFrom(const SignIdentity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignIdentity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes challenge_hidden = 2;
  bool has_challenge_hidden() const;
  void clear_challenge_hidden();
  static const int kChallengeHiddenFieldNumber = 2;
  const ::std::string& challenge_hidden() const;
  void set_challenge_hidden(const ::std::string& value);
  #if LANG_CXX11
  void set_challenge_hidden(::std::string&& value);
  #endif
  void set_challenge_hidden(const char* value);
  void set_challenge_hidden(const void* value, size_t size);
  ::std::string* mutable_challenge_hidden();
  ::std::string* release_challenge_hidden();
  void set_allocated_challenge_hidden(::std::string* challenge_hidden);

  // optional string challenge_visual = 3;
  bool has_challenge_visual() const;
  void clear_challenge_visual();
  static const int kChallengeVisualFieldNumber = 3;
  const ::std::string& challenge_visual() const;
  void set_challenge_visual(const ::std::string& value);
  #if LANG_CXX11
  void set_challenge_visual(::std::string&& value);
  #endif
  void set_challenge_visual(const char* value);
  void set_challenge_visual(const char* value, size_t size);
  ::std::string* mutable_challenge_visual();
  ::std::string* release_challenge_visual();
  void set_allocated_challenge_visual(::std::string* challenge_visual);

  // optional string ecdsa_curve_name = 4;
  bool has_ecdsa_curve_name() const;
  void clear_ecdsa_curve_name();
  static const int kEcdsaCurveNameFieldNumber = 4;
  const ::std::string& ecdsa_curve_name() const;
  void set_ecdsa_curve_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ecdsa_curve_name(::std::string&& value);
  #endif
  void set_ecdsa_curve_name(const char* value);
  void set_ecdsa_curve_name(const char* value, size_t size);
  ::std::string* mutable_ecdsa_curve_name();
  ::std::string* release_ecdsa_curve_name();
  void set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name);

  // optional .TrezorProtobuf.IdentityType identity = 1;
  bool has_identity() const;
  void clear_identity();
  static const int kIdentityFieldNumber = 1;
  const ::TrezorProtobuf::IdentityType& identity() const;
  ::TrezorProtobuf::IdentityType* mutable_identity();
  ::TrezorProtobuf::IdentityType* release_identity();
  void set_allocated_identity(::TrezorProtobuf::IdentityType* identity);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.SignIdentity)
 private:
  void set_has_identity();
  void clear_has_identity();
  void set_has_challenge_hidden();
  void clear_has_challenge_hidden();
  void set_has_challenge_visual();
  void clear_has_challenge_visual();
  void set_has_ecdsa_curve_name();
  void clear_has_ecdsa_curve_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr challenge_hidden_;
  ::google::protobuf::internal::ArenaStringPtr challenge_visual_;
  ::google::protobuf::internal::ArenaStringPtr ecdsa_curve_name_;
  ::TrezorProtobuf::IdentityType* identity_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignedIdentity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.SignedIdentity) */ {
 public:
  SignedIdentity();
  virtual ~SignedIdentity();

  SignedIdentity(const SignedIdentity& from);

  inline SignedIdentity& operator=(const SignedIdentity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedIdentity& default_instance();

  static inline const SignedIdentity* internal_default_instance() {
    return reinterpret_cast<const SignedIdentity*>(
               &_SignedIdentity_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(SignedIdentity* other);

  // implements Message ----------------------------------------------

  inline SignedIdentity* New() const PROTOBUF_FINAL { return New(NULL); }

  SignedIdentity* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SignedIdentity& from);
  void MergeFrom(const SignedIdentity& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SignedIdentity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes public_key = 2;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bytes signature = 3;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 3;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.SignedIdentity)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_public_key();
  void clear_has_public_key();
  void set_has_signature();
  void clear_has_signature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetECDHSessionKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.GetECDHSessionKey) */ {
 public:
  GetECDHSessionKey();
  virtual ~GetECDHSessionKey();

  GetECDHSessionKey(const GetECDHSessionKey& from);

  inline GetECDHSessionKey& operator=(const GetECDHSessionKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetECDHSessionKey& default_instance();

  static inline const GetECDHSessionKey* internal_default_instance() {
    return reinterpret_cast<const GetECDHSessionKey*>(
               &_GetECDHSessionKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(GetECDHSessionKey* other);

  // implements Message ----------------------------------------------

  inline GetECDHSessionKey* New() const PROTOBUF_FINAL { return New(NULL); }

  GetECDHSessionKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetECDHSessionKey& from);
  void MergeFrom(const GetECDHSessionKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetECDHSessionKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes peer_public_key = 2;
  bool has_peer_public_key() const;
  void clear_peer_public_key();
  static const int kPeerPublicKeyFieldNumber = 2;
  const ::std::string& peer_public_key() const;
  void set_peer_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_public_key(::std::string&& value);
  #endif
  void set_peer_public_key(const char* value);
  void set_peer_public_key(const void* value, size_t size);
  ::std::string* mutable_peer_public_key();
  ::std::string* release_peer_public_key();
  void set_allocated_peer_public_key(::std::string* peer_public_key);

  // optional string ecdsa_curve_name = 3;
  bool has_ecdsa_curve_name() const;
  void clear_ecdsa_curve_name();
  static const int kEcdsaCurveNameFieldNumber = 3;
  const ::std::string& ecdsa_curve_name() const;
  void set_ecdsa_curve_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ecdsa_curve_name(::std::string&& value);
  #endif
  void set_ecdsa_curve_name(const char* value);
  void set_ecdsa_curve_name(const char* value, size_t size);
  ::std::string* mutable_ecdsa_curve_name();
  ::std::string* release_ecdsa_curve_name();
  void set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name);

  // optional .TrezorProtobuf.IdentityType identity = 1;
  bool has_identity() const;
  void clear_identity();
  static const int kIdentityFieldNumber = 1;
  const ::TrezorProtobuf::IdentityType& identity() const;
  ::TrezorProtobuf::IdentityType* mutable_identity();
  ::TrezorProtobuf::IdentityType* release_identity();
  void set_allocated_identity(::TrezorProtobuf::IdentityType* identity);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.GetECDHSessionKey)
 private:
  void set_has_identity();
  void clear_has_identity();
  void set_has_peer_public_key();
  void clear_has_peer_public_key();
  void set_has_ecdsa_curve_name();
  void clear_has_ecdsa_curve_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr peer_public_key_;
  ::google::protobuf::internal::ArenaStringPtr ecdsa_curve_name_;
  ::TrezorProtobuf::IdentityType* identity_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ECDHSessionKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.ECDHSessionKey) */ {
 public:
  ECDHSessionKey();
  virtual ~ECDHSessionKey();

  ECDHSessionKey(const ECDHSessionKey& from);

  inline ECDHSessionKey& operator=(const ECDHSessionKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECDHSessionKey& default_instance();

  static inline const ECDHSessionKey* internal_default_instance() {
    return reinterpret_cast<const ECDHSessionKey*>(
               &_ECDHSessionKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(ECDHSessionKey* other);

  // implements Message ----------------------------------------------

  inline ECDHSessionKey* New() const PROTOBUF_FINAL { return New(NULL); }

  ECDHSessionKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ECDHSessionKey& from);
  void MergeFrom(const ECDHSessionKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ECDHSessionKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes session_key = 1;
  bool has_session_key() const;
  void clear_session_key();
  static const int kSessionKeyFieldNumber = 1;
  const ::std::string& session_key() const;
  void set_session_key(const ::std::string& value);
  #if LANG_CXX11
  void set_session_key(::std::string&& value);
  #endif
  void set_session_key(const char* value);
  void set_session_key(const void* value, size_t size);
  ::std::string* mutable_session_key();
  ::std::string* release_session_key();
  void set_allocated_session_key(::std::string* session_key);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.ECDHSessionKey)
 private:
  void set_has_session_key();
  void clear_has_session_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_key_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetU2FCounter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.SetU2FCounter) */ {
 public:
  SetU2FCounter();
  virtual ~SetU2FCounter();

  SetU2FCounter(const SetU2FCounter& from);

  inline SetU2FCounter& operator=(const SetU2FCounter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetU2FCounter& default_instance();

  static inline const SetU2FCounter* internal_default_instance() {
    return reinterpret_cast<const SetU2FCounter*>(
               &_SetU2FCounter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(SetU2FCounter* other);

  // implements Message ----------------------------------------------

  inline SetU2FCounter* New() const PROTOBUF_FINAL { return New(NULL); }

  SetU2FCounter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetU2FCounter& from);
  void MergeFrom(const SetU2FCounter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetU2FCounter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 u2f_counter = 1;
  bool has_u2f_counter() const;
  void clear_u2f_counter();
  static const int kU2FCounterFieldNumber = 1;
  ::google::protobuf::uint32 u2f_counter() const;
  void set_u2f_counter(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.SetU2FCounter)
 private:
  void set_has_u2f_counter();
  void clear_has_u2f_counter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 u2f_counter_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FirmwareErase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.FirmwareErase) */ {
 public:
  FirmwareErase();
  virtual ~FirmwareErase();

  FirmwareErase(const FirmwareErase& from);

  inline FirmwareErase& operator=(const FirmwareErase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareErase& default_instance();

  static inline const FirmwareErase* internal_default_instance() {
    return reinterpret_cast<const FirmwareErase*>(
               &_FirmwareErase_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(FirmwareErase* other);

  // implements Message ----------------------------------------------

  inline FirmwareErase* New() const PROTOBUF_FINAL { return New(NULL); }

  FirmwareErase* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FirmwareErase& from);
  void MergeFrom(const FirmwareErase& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FirmwareErase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.FirmwareErase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FirmwareRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.FirmwareRequest) */ {
 public:
  FirmwareRequest();
  virtual ~FirmwareRequest();

  FirmwareRequest(const FirmwareRequest& from);

  inline FirmwareRequest& operator=(const FirmwareRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareRequest& default_instance();

  static inline const FirmwareRequest* internal_default_instance() {
    return reinterpret_cast<const FirmwareRequest*>(
               &_FirmwareRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(FirmwareRequest* other);

  // implements Message ----------------------------------------------

  inline FirmwareRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  FirmwareRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FirmwareRequest& from);
  void MergeFrom(const FirmwareRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FirmwareRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // optional uint32 length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.FirmwareRequest)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_length();
  void clear_has_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 length_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FirmwareUpload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.FirmwareUpload) */ {
 public:
  FirmwareUpload();
  virtual ~FirmwareUpload();

  FirmwareUpload(const FirmwareUpload& from);

  inline FirmwareUpload& operator=(const FirmwareUpload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareUpload& default_instance();

  static inline const FirmwareUpload* internal_default_instance() {
    return reinterpret_cast<const FirmwareUpload*>(
               &_FirmwareUpload_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(FirmwareUpload* other);

  // implements Message ----------------------------------------------

  inline FirmwareUpload* New() const PROTOBUF_FINAL { return New(NULL); }

  FirmwareUpload* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FirmwareUpload& from);
  void MergeFrom(const FirmwareUpload& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FirmwareUpload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes payload = 1;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // optional bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.FirmwareUpload)
 private:
  void set_has_payload();
  void clear_has_payload();
  void set_has_hash();
  void clear_has_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkDecision : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkDecision) */ {
 public:
  DebugLinkDecision();
  virtual ~DebugLinkDecision();

  DebugLinkDecision(const DebugLinkDecision& from);

  inline DebugLinkDecision& operator=(const DebugLinkDecision& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkDecision& default_instance();

  static inline const DebugLinkDecision* internal_default_instance() {
    return reinterpret_cast<const DebugLinkDecision*>(
               &_DebugLinkDecision_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(DebugLinkDecision* other);

  // implements Message ----------------------------------------------

  inline DebugLinkDecision* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkDecision* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkDecision& from);
  void MergeFrom(const DebugLinkDecision& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkDecision* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool yes_no = 1;
  bool has_yes_no() const;
  void clear_yes_no();
  static const int kYesNoFieldNumber = 1;
  bool yes_no() const;
  void set_yes_no(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkDecision)
 private:
  void set_has_yes_no();
  void clear_has_yes_no();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool yes_no_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkGetState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkGetState) */ {
 public:
  DebugLinkGetState();
  virtual ~DebugLinkGetState();

  DebugLinkGetState(const DebugLinkGetState& from);

  inline DebugLinkGetState& operator=(const DebugLinkGetState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkGetState& default_instance();

  static inline const DebugLinkGetState* internal_default_instance() {
    return reinterpret_cast<const DebugLinkGetState*>(
               &_DebugLinkGetState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(DebugLinkGetState* other);

  // implements Message ----------------------------------------------

  inline DebugLinkGetState* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkGetState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkGetState& from);
  void MergeFrom(const DebugLinkGetState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkGetState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkGetState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkState) */ {
 public:
  DebugLinkState();
  virtual ~DebugLinkState();

  DebugLinkState(const DebugLinkState& from);

  inline DebugLinkState& operator=(const DebugLinkState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkState& default_instance();

  static inline const DebugLinkState* internal_default_instance() {
    return reinterpret_cast<const DebugLinkState*>(
               &_DebugLinkState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(DebugLinkState* other);

  // implements Message ----------------------------------------------

  inline DebugLinkState* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkState& from);
  void MergeFrom(const DebugLinkState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes layout = 1;
  bool has_layout() const;
  void clear_layout();
  static const int kLayoutFieldNumber = 1;
  const ::std::string& layout() const;
  void set_layout(const ::std::string& value);
  #if LANG_CXX11
  void set_layout(::std::string&& value);
  #endif
  void set_layout(const char* value);
  void set_layout(const void* value, size_t size);
  ::std::string* mutable_layout();
  ::std::string* release_layout();
  void set_allocated_layout(::std::string* layout);

  // optional string pin = 2;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 2;
  const ::std::string& pin() const;
  void set_pin(const ::std::string& value);
  #if LANG_CXX11
  void set_pin(::std::string&& value);
  #endif
  void set_pin(const char* value);
  void set_pin(const char* value, size_t size);
  ::std::string* mutable_pin();
  ::std::string* release_pin();
  void set_allocated_pin(::std::string* pin);

  // optional string matrix = 3;
  bool has_matrix() const;
  void clear_matrix();
  static const int kMatrixFieldNumber = 3;
  const ::std::string& matrix() const;
  void set_matrix(const ::std::string& value);
  #if LANG_CXX11
  void set_matrix(::std::string&& value);
  #endif
  void set_matrix(const char* value);
  void set_matrix(const char* value, size_t size);
  ::std::string* mutable_matrix();
  ::std::string* release_matrix();
  void set_allocated_matrix(::std::string* matrix);

  // optional string mnemonic = 4;
  bool has_mnemonic() const;
  void clear_mnemonic();
  static const int kMnemonicFieldNumber = 4;
  const ::std::string& mnemonic() const;
  void set_mnemonic(const ::std::string& value);
  #if LANG_CXX11
  void set_mnemonic(::std::string&& value);
  #endif
  void set_mnemonic(const char* value);
  void set_mnemonic(const char* value, size_t size);
  ::std::string* mutable_mnemonic();
  ::std::string* release_mnemonic();
  void set_allocated_mnemonic(::std::string* mnemonic);

  // optional string reset_word = 7;
  bool has_reset_word() const;
  void clear_reset_word();
  static const int kResetWordFieldNumber = 7;
  const ::std::string& reset_word() const;
  void set_reset_word(const ::std::string& value);
  #if LANG_CXX11
  void set_reset_word(::std::string&& value);
  #endif
  void set_reset_word(const char* value);
  void set_reset_word(const char* value, size_t size);
  ::std::string* mutable_reset_word();
  ::std::string* release_reset_word();
  void set_allocated_reset_word(::std::string* reset_word);

  // optional bytes reset_entropy = 8;
  bool has_reset_entropy() const;
  void clear_reset_entropy();
  static const int kResetEntropyFieldNumber = 8;
  const ::std::string& reset_entropy() const;
  void set_reset_entropy(const ::std::string& value);
  #if LANG_CXX11
  void set_reset_entropy(::std::string&& value);
  #endif
  void set_reset_entropy(const char* value);
  void set_reset_entropy(const void* value, size_t size);
  ::std::string* mutable_reset_entropy();
  ::std::string* release_reset_entropy();
  void set_allocated_reset_entropy(::std::string* reset_entropy);

  // optional string recovery_fake_word = 9;
  bool has_recovery_fake_word() const;
  void clear_recovery_fake_word();
  static const int kRecoveryFakeWordFieldNumber = 9;
  const ::std::string& recovery_fake_word() const;
  void set_recovery_fake_word(const ::std::string& value);
  #if LANG_CXX11
  void set_recovery_fake_word(::std::string&& value);
  #endif
  void set_recovery_fake_word(const char* value);
  void set_recovery_fake_word(const char* value, size_t size);
  ::std::string* mutable_recovery_fake_word();
  ::std::string* release_recovery_fake_word();
  void set_allocated_recovery_fake_word(::std::string* recovery_fake_word);

  // optional .TrezorProtobuf.HDNodeType node = 5;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 5;
  const ::TrezorProtobuf::HDNodeType& node() const;
  ::TrezorProtobuf::HDNodeType* mutable_node();
  ::TrezorProtobuf::HDNodeType* release_node();
  void set_allocated_node(::TrezorProtobuf::HDNodeType* node);

  // optional bool passphrase_protection = 6;
  bool has_passphrase_protection() const;
  void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 6;
  bool passphrase_protection() const;
  void set_passphrase_protection(bool value);

  // optional uint32 recovery_word_pos = 10;
  bool has_recovery_word_pos() const;
  void clear_recovery_word_pos();
  static const int kRecoveryWordPosFieldNumber = 10;
  ::google::protobuf::uint32 recovery_word_pos() const;
  void set_recovery_word_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkState)
 private:
  void set_has_layout();
  void clear_has_layout();
  void set_has_pin();
  void clear_has_pin();
  void set_has_matrix();
  void clear_has_matrix();
  void set_has_mnemonic();
  void clear_has_mnemonic();
  void set_has_node();
  void clear_has_node();
  void set_has_passphrase_protection();
  void clear_has_passphrase_protection();
  void set_has_reset_word();
  void clear_has_reset_word();
  void set_has_reset_entropy();
  void clear_has_reset_entropy();
  void set_has_recovery_fake_word();
  void clear_has_recovery_fake_word();
  void set_has_recovery_word_pos();
  void clear_has_recovery_word_pos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr layout_;
  ::google::protobuf::internal::ArenaStringPtr pin_;
  ::google::protobuf::internal::ArenaStringPtr matrix_;
  ::google::protobuf::internal::ArenaStringPtr mnemonic_;
  ::google::protobuf::internal::ArenaStringPtr reset_word_;
  ::google::protobuf::internal::ArenaStringPtr reset_entropy_;
  ::google::protobuf::internal::ArenaStringPtr recovery_fake_word_;
  ::TrezorProtobuf::HDNodeType* node_;
  bool passphrase_protection_;
  ::google::protobuf::uint32 recovery_word_pos_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkStop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkStop) */ {
 public:
  DebugLinkStop();
  virtual ~DebugLinkStop();

  DebugLinkStop(const DebugLinkStop& from);

  inline DebugLinkStop& operator=(const DebugLinkStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkStop& default_instance();

  static inline const DebugLinkStop* internal_default_instance() {
    return reinterpret_cast<const DebugLinkStop*>(
               &_DebugLinkStop_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(DebugLinkStop* other);

  // implements Message ----------------------------------------------

  inline DebugLinkStop* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkStop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkStop& from);
  void MergeFrom(const DebugLinkStop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkStop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkStop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkLog) */ {
 public:
  DebugLinkLog();
  virtual ~DebugLinkLog();

  DebugLinkLog(const DebugLinkLog& from);

  inline DebugLinkLog& operator=(const DebugLinkLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkLog& default_instance();

  static inline const DebugLinkLog* internal_default_instance() {
    return reinterpret_cast<const DebugLinkLog*>(
               &_DebugLinkLog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(DebugLinkLog* other);

  // implements Message ----------------------------------------------

  inline DebugLinkLog* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkLog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkLog& from);
  void MergeFrom(const DebugLinkLog& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bucket = 2;
  bool has_bucket() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 2;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  #if LANG_CXX11
  void set_bucket(::std::string&& value);
  #endif
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // optional string text = 3;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 3;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::uint32 level() const;
  void set_level(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkLog)
 private:
  void set_has_level();
  void clear_has_level();
  void set_has_bucket();
  void clear_has_bucket();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 level_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkMemoryRead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkMemoryRead) */ {
 public:
  DebugLinkMemoryRead();
  virtual ~DebugLinkMemoryRead();

  DebugLinkMemoryRead(const DebugLinkMemoryRead& from);

  inline DebugLinkMemoryRead& operator=(const DebugLinkMemoryRead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkMemoryRead& default_instance();

  static inline const DebugLinkMemoryRead* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemoryRead*>(
               &_DebugLinkMemoryRead_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(DebugLinkMemoryRead* other);

  // implements Message ----------------------------------------------

  inline DebugLinkMemoryRead* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkMemoryRead* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkMemoryRead& from);
  void MergeFrom(const DebugLinkMemoryRead& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkMemoryRead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // optional uint32 length = 2;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkMemoryRead)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_length();
  void clear_has_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 address_;
  ::google::protobuf::uint32 length_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkMemory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkMemory) */ {
 public:
  DebugLinkMemory();
  virtual ~DebugLinkMemory();

  DebugLinkMemory(const DebugLinkMemory& from);

  inline DebugLinkMemory& operator=(const DebugLinkMemory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkMemory& default_instance();

  static inline const DebugLinkMemory* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemory*>(
               &_DebugLinkMemory_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(DebugLinkMemory* other);

  // implements Message ----------------------------------------------

  inline DebugLinkMemory* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkMemory* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkMemory& from);
  void MergeFrom(const DebugLinkMemory& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkMemory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes memory = 1;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 1;
  const ::std::string& memory() const;
  void set_memory(const ::std::string& value);
  #if LANG_CXX11
  void set_memory(::std::string&& value);
  #endif
  void set_memory(const char* value);
  void set_memory(const void* value, size_t size);
  ::std::string* mutable_memory();
  ::std::string* release_memory();
  void set_allocated_memory(::std::string* memory);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkMemory)
 private:
  void set_has_memory();
  void clear_has_memory();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memory_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkMemoryWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkMemoryWrite) */ {
 public:
  DebugLinkMemoryWrite();
  virtual ~DebugLinkMemoryWrite();

  DebugLinkMemoryWrite(const DebugLinkMemoryWrite& from);

  inline DebugLinkMemoryWrite& operator=(const DebugLinkMemoryWrite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkMemoryWrite& default_instance();

  static inline const DebugLinkMemoryWrite* internal_default_instance() {
    return reinterpret_cast<const DebugLinkMemoryWrite*>(
               &_DebugLinkMemoryWrite_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(DebugLinkMemoryWrite* other);

  // implements Message ----------------------------------------------

  inline DebugLinkMemoryWrite* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkMemoryWrite* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkMemoryWrite& from);
  void MergeFrom(const DebugLinkMemoryWrite& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkMemoryWrite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes memory = 2;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 2;
  const ::std::string& memory() const;
  void set_memory(const ::std::string& value);
  #if LANG_CXX11
  void set_memory(::std::string&& value);
  #endif
  void set_memory(const char* value);
  void set_memory(const void* value, size_t size);
  ::std::string* mutable_memory();
  ::std::string* release_memory();
  void set_allocated_memory(::std::string* memory);

  // optional uint32 address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  ::google::protobuf::uint32 address() const;
  void set_address(::google::protobuf::uint32 value);

  // optional bool flash = 3;
  bool has_flash() const;
  void clear_flash();
  static const int kFlashFieldNumber = 3;
  bool flash() const;
  void set_flash(bool value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkMemoryWrite)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_memory();
  void clear_has_memory();
  void set_has_flash();
  void clear_has_flash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr memory_;
  ::google::protobuf::uint32 address_;
  bool flash_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugLinkFlashErase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TrezorProtobuf.DebugLinkFlashErase) */ {
 public:
  DebugLinkFlashErase();
  virtual ~DebugLinkFlashErase();

  DebugLinkFlashErase(const DebugLinkFlashErase& from);

  inline DebugLinkFlashErase& operator=(const DebugLinkFlashErase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkFlashErase& default_instance();

  static inline const DebugLinkFlashErase* internal_default_instance() {
    return reinterpret_cast<const DebugLinkFlashErase*>(
               &_DebugLinkFlashErase_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(DebugLinkFlashErase* other);

  // implements Message ----------------------------------------------

  inline DebugLinkFlashErase* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugLinkFlashErase* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugLinkFlashErase& from);
  void MergeFrom(const DebugLinkFlashErase& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugLinkFlashErase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sector = 1;
  bool has_sector() const;
  void clear_sector();
  static const int kSectorFieldNumber = 1;
  ::google::protobuf::uint32 sector() const;
  void set_sector(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TrezorProtobuf.DebugLinkFlashErase)
 private:
  void set_has_sector();
  void clear_has_sector();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 sector_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Initialize

// -------------------------------------------------------------------

// GetFeatures

// -------------------------------------------------------------------

// Features

// optional string vendor = 1;
inline bool Features::has_vendor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Features::set_has_vendor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Features::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Features::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vendor();
}
inline const ::std::string& Features::vendor() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.vendor)
  return vendor_.GetNoArena();
}
inline void Features::set_vendor(const ::std::string& value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.vendor)
}
#if LANG_CXX11
inline void Features::set_vendor(::std::string&& value) {
  set_has_vendor();
  vendor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.vendor)
}
#endif
inline void Features::set_vendor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.vendor)
}
inline void Features::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.vendor)
}
inline ::std::string* Features::mutable_vendor() {
  set_has_vendor();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_vendor() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.vendor)
  clear_has_vendor();
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    set_has_vendor();
  } else {
    clear_has_vendor();
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.vendor)
}

// optional uint32 major_version = 2;
inline bool Features::has_major_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Features::set_has_major_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Features::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Features::clear_major_version() {
  major_version_ = 0u;
  clear_has_major_version();
}
inline ::google::protobuf::uint32 Features::major_version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.major_version)
  return major_version_;
}
inline void Features::set_major_version(::google::protobuf::uint32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.major_version)
}

// optional uint32 minor_version = 3;
inline bool Features::has_minor_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Features::set_has_minor_version() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Features::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Features::clear_minor_version() {
  minor_version_ = 0u;
  clear_has_minor_version();
}
inline ::google::protobuf::uint32 Features::minor_version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.minor_version)
  return minor_version_;
}
inline void Features::set_minor_version(::google::protobuf::uint32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.minor_version)
}

// optional uint32 patch_version = 4;
inline bool Features::has_patch_version() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Features::set_has_patch_version() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Features::clear_has_patch_version() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Features::clear_patch_version() {
  patch_version_ = 0u;
  clear_has_patch_version();
}
inline ::google::protobuf::uint32 Features::patch_version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.patch_version)
  return patch_version_;
}
inline void Features::set_patch_version(::google::protobuf::uint32 value) {
  set_has_patch_version();
  patch_version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.patch_version)
}

// optional bool bootloader_mode = 5;
inline bool Features::has_bootloader_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Features::set_has_bootloader_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Features::clear_has_bootloader_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Features::clear_bootloader_mode() {
  bootloader_mode_ = false;
  clear_has_bootloader_mode();
}
inline bool Features::bootloader_mode() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.bootloader_mode)
  return bootloader_mode_;
}
inline void Features::set_bootloader_mode(bool value) {
  set_has_bootloader_mode();
  bootloader_mode_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.bootloader_mode)
}

// optional string device_id = 6;
inline bool Features::has_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Features::set_has_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Features::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Features::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_id();
}
inline const ::std::string& Features::device_id() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.device_id)
  return device_id_.GetNoArena();
}
inline void Features::set_device_id(const ::std::string& value) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.device_id)
}
#if LANG_CXX11
inline void Features::set_device_id(::std::string&& value) {
  set_has_device_id();
  device_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.device_id)
}
#endif
inline void Features::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.device_id)
}
inline void Features::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.device_id)
}
inline ::std::string* Features::mutable_device_id() {
  set_has_device_id();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.device_id)
  return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_device_id() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.device_id)
  clear_has_device_id();
  return device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_device_id(::std::string* device_id) {
  if (device_id != NULL) {
    set_has_device_id();
  } else {
    clear_has_device_id();
  }
  device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.device_id)
}

// optional bool pin_protection = 7;
inline bool Features::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Features::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Features::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Features::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool Features::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.pin_protection)
  return pin_protection_;
}
inline void Features::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.pin_protection)
}

// optional bool passphrase_protection = 8;
inline bool Features::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Features::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Features::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Features::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool Features::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.passphrase_protection)
  return passphrase_protection_;
}
inline void Features::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.passphrase_protection)
}

// optional string language = 9;
inline bool Features::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Features::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Features::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Features::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& Features::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.language)
  return language_.GetNoArena();
}
inline void Features::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.language)
}
#if LANG_CXX11
inline void Features::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.language)
}
#endif
inline void Features::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.language)
}
inline void Features::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.language)
}
inline ::std::string* Features::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.language)
}

// optional string label = 10;
inline bool Features::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Features::set_has_label() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Features::clear_has_label() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Features::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& Features::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.label)
  return label_.GetNoArena();
}
inline void Features::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.label)
}
#if LANG_CXX11
inline void Features::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.label)
}
#endif
inline void Features::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.label)
}
inline void Features::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.label)
}
inline ::std::string* Features::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.label)
}

// repeated .TrezorProtobuf.CoinType coins = 11;
inline int Features::coins_size() const {
  return coins_.size();
}
inline void Features::clear_coins() {
  coins_.Clear();
}
inline const ::TrezorProtobuf::CoinType& Features::coins(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.coins)
  return coins_.Get(index);
}
inline ::TrezorProtobuf::CoinType* Features::mutable_coins(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.coins)
  return coins_.Mutable(index);
}
inline ::TrezorProtobuf::CoinType* Features::add_coins() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.Features.coins)
  return coins_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::CoinType >*
Features::mutable_coins() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.Features.coins)
  return &coins_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::CoinType >&
Features::coins() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.Features.coins)
  return coins_;
}

// optional bool initialized = 12;
inline bool Features::has_initialized() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Features::set_has_initialized() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Features::clear_has_initialized() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Features::clear_initialized() {
  initialized_ = false;
  clear_has_initialized();
}
inline bool Features::initialized() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.initialized)
  return initialized_;
}
inline void Features::set_initialized(bool value) {
  set_has_initialized();
  initialized_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.initialized)
}

// optional bytes revision = 13;
inline bool Features::has_revision() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Features::set_has_revision() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Features::clear_has_revision() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Features::clear_revision() {
  revision_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_revision();
}
inline const ::std::string& Features::revision() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.revision)
  return revision_.GetNoArena();
}
inline void Features::set_revision(const ::std::string& value) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.revision)
}
#if LANG_CXX11
inline void Features::set_revision(::std::string&& value) {
  set_has_revision();
  revision_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.revision)
}
#endif
inline void Features::set_revision(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.revision)
}
inline void Features::set_revision(const void* value, size_t size) {
  set_has_revision();
  revision_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.revision)
}
inline ::std::string* Features::mutable_revision() {
  set_has_revision();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.revision)
  return revision_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_revision() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.revision)
  clear_has_revision();
  return revision_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_revision(::std::string* revision) {
  if (revision != NULL) {
    set_has_revision();
  } else {
    clear_has_revision();
  }
  revision_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.revision)
}

// optional bytes bootloader_hash = 14;
inline bool Features::has_bootloader_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Features::set_has_bootloader_hash() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Features::clear_has_bootloader_hash() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Features::clear_bootloader_hash() {
  bootloader_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bootloader_hash();
}
inline const ::std::string& Features::bootloader_hash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.bootloader_hash)
  return bootloader_hash_.GetNoArena();
}
inline void Features::set_bootloader_hash(const ::std::string& value) {
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.bootloader_hash)
}
#if LANG_CXX11
inline void Features::set_bootloader_hash(::std::string&& value) {
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Features.bootloader_hash)
}
#endif
inline void Features::set_bootloader_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Features.bootloader_hash)
}
inline void Features::set_bootloader_hash(const void* value, size_t size) {
  set_has_bootloader_hash();
  bootloader_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Features.bootloader_hash)
}
inline ::std::string* Features::mutable_bootloader_hash() {
  set_has_bootloader_hash();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Features.bootloader_hash)
  return bootloader_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Features::release_bootloader_hash() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Features.bootloader_hash)
  clear_has_bootloader_hash();
  return bootloader_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Features::set_allocated_bootloader_hash(::std::string* bootloader_hash) {
  if (bootloader_hash != NULL) {
    set_has_bootloader_hash();
  } else {
    clear_has_bootloader_hash();
  }
  bootloader_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bootloader_hash);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Features.bootloader_hash)
}

// optional bool imported = 15;
inline bool Features::has_imported() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Features::set_has_imported() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Features::clear_has_imported() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Features::clear_imported() {
  imported_ = false;
  clear_has_imported();
}
inline bool Features::imported() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.imported)
  return imported_;
}
inline void Features::set_imported(bool value) {
  set_has_imported();
  imported_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.imported)
}

// optional bool pin_cached = 16;
inline bool Features::has_pin_cached() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Features::set_has_pin_cached() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Features::clear_has_pin_cached() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Features::clear_pin_cached() {
  pin_cached_ = false;
  clear_has_pin_cached();
}
inline bool Features::pin_cached() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.pin_cached)
  return pin_cached_;
}
inline void Features::set_pin_cached(bool value) {
  set_has_pin_cached();
  pin_cached_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.pin_cached)
}

// optional bool passphrase_cached = 17;
inline bool Features::has_passphrase_cached() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Features::set_has_passphrase_cached() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Features::clear_has_passphrase_cached() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Features::clear_passphrase_cached() {
  passphrase_cached_ = false;
  clear_has_passphrase_cached();
}
inline bool Features::passphrase_cached() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.passphrase_cached)
  return passphrase_cached_;
}
inline void Features::set_passphrase_cached(bool value) {
  set_has_passphrase_cached();
  passphrase_cached_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.passphrase_cached)
}

// optional bool firmware_present = 18;
inline bool Features::has_firmware_present() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Features::set_has_firmware_present() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Features::clear_has_firmware_present() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Features::clear_firmware_present() {
  firmware_present_ = false;
  clear_has_firmware_present();
}
inline bool Features::firmware_present() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Features.firmware_present)
  return firmware_present_;
}
inline void Features::set_firmware_present(bool value) {
  set_has_firmware_present();
  firmware_present_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Features.firmware_present)
}

// -------------------------------------------------------------------

// ClearSession

// -------------------------------------------------------------------

// ApplySettings

// optional string language = 1;
inline bool ApplySettings::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplySettings::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplySettings::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplySettings::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& ApplySettings::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.language)
  return language_.GetNoArena();
}
inline void ApplySettings::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.language)
}
#if LANG_CXX11
inline void ApplySettings::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ApplySettings.language)
}
#endif
inline void ApplySettings::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ApplySettings.language)
}
inline void ApplySettings::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ApplySettings.language)
}
inline ::std::string* ApplySettings::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ApplySettings.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplySettings::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ApplySettings.language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplySettings::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ApplySettings.language)
}

// optional string label = 2;
inline bool ApplySettings::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplySettings::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplySettings::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplySettings::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& ApplySettings::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.label)
  return label_.GetNoArena();
}
inline void ApplySettings::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.label)
}
#if LANG_CXX11
inline void ApplySettings::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ApplySettings.label)
}
#endif
inline void ApplySettings::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ApplySettings.label)
}
inline void ApplySettings::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ApplySettings.label)
}
inline ::std::string* ApplySettings::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ApplySettings.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplySettings::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ApplySettings.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplySettings::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ApplySettings.label)
}

// optional bool use_passphrase = 3;
inline bool ApplySettings::has_use_passphrase() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplySettings::set_has_use_passphrase() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplySettings::clear_has_use_passphrase() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplySettings::clear_use_passphrase() {
  use_passphrase_ = false;
  clear_has_use_passphrase();
}
inline bool ApplySettings::use_passphrase() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.use_passphrase)
  return use_passphrase_;
}
inline void ApplySettings::set_use_passphrase(bool value) {
  set_has_use_passphrase();
  use_passphrase_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.use_passphrase)
}

// optional bytes homescreen = 4;
inline bool ApplySettings::has_homescreen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplySettings::set_has_homescreen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplySettings::clear_has_homescreen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplySettings::clear_homescreen() {
  homescreen_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_homescreen();
}
inline const ::std::string& ApplySettings::homescreen() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ApplySettings.homescreen)
  return homescreen_.GetNoArena();
}
inline void ApplySettings::set_homescreen(const ::std::string& value) {
  set_has_homescreen();
  homescreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ApplySettings.homescreen)
}
#if LANG_CXX11
inline void ApplySettings::set_homescreen(::std::string&& value) {
  set_has_homescreen();
  homescreen_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ApplySettings.homescreen)
}
#endif
inline void ApplySettings::set_homescreen(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_homescreen();
  homescreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ApplySettings.homescreen)
}
inline void ApplySettings::set_homescreen(const void* value, size_t size) {
  set_has_homescreen();
  homescreen_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ApplySettings.homescreen)
}
inline ::std::string* ApplySettings::mutable_homescreen() {
  set_has_homescreen();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ApplySettings.homescreen)
  return homescreen_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplySettings::release_homescreen() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ApplySettings.homescreen)
  clear_has_homescreen();
  return homescreen_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplySettings::set_allocated_homescreen(::std::string* homescreen) {
  if (homescreen != NULL) {
    set_has_homescreen();
  } else {
    clear_has_homescreen();
  }
  homescreen_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), homescreen);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ApplySettings.homescreen)
}

// -------------------------------------------------------------------

// ChangePin

// optional bool remove = 1;
inline bool ChangePin::has_remove() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePin::set_has_remove() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePin::clear_has_remove() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePin::clear_remove() {
  remove_ = false;
  clear_has_remove();
}
inline bool ChangePin::remove() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ChangePin.remove)
  return remove_;
}
inline void ChangePin::set_remove(bool value) {
  set_has_remove();
  remove_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ChangePin.remove)
}

// -------------------------------------------------------------------

// Ping

// optional string message = 1;
inline bool Ping::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Ping::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.message)
  return message_.GetNoArena();
}
inline void Ping::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.message)
}
#if LANG_CXX11
inline void Ping::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Ping.message)
}
#endif
inline void Ping::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Ping.message)
}
inline void Ping::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Ping.message)
}
inline ::std::string* Ping::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Ping.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ping::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Ping.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ping::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Ping.message)
}

// optional bool button_protection = 2;
inline bool Ping::has_button_protection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::set_has_button_protection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ping::clear_has_button_protection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ping::clear_button_protection() {
  button_protection_ = false;
  clear_has_button_protection();
}
inline bool Ping::button_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.button_protection)
  return button_protection_;
}
inline void Ping::set_button_protection(bool value) {
  set_has_button_protection();
  button_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.button_protection)
}

// optional bool pin_protection = 3;
inline bool Ping::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ping::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ping::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ping::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool Ping::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.pin_protection)
  return pin_protection_;
}
inline void Ping::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.pin_protection)
}

// optional bool passphrase_protection = 4;
inline bool Ping::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ping::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ping::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ping::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool Ping::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Ping.passphrase_protection)
  return passphrase_protection_;
}
inline void Ping::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Ping.passphrase_protection)
}

// -------------------------------------------------------------------

// Success

// optional string message = 1;
inline bool Success::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Success::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Success::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Success::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Success::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Success.message)
  return message_.GetNoArena();
}
inline void Success::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Success.message)
}
#if LANG_CXX11
inline void Success::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Success.message)
}
#endif
inline void Success::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Success.message)
}
inline void Success::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Success.message)
}
inline ::std::string* Success::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Success.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Success::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Success.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Success::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Success.message)
}

// -------------------------------------------------------------------

// Failure

// optional .TrezorProtobuf.FailureType code = 1;
inline bool Failure::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Failure::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Failure::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Failure::clear_code() {
  code_ = 1;
  clear_has_code();
}
inline ::TrezorProtobuf::FailureType Failure::code() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Failure.code)
  return static_cast< ::TrezorProtobuf::FailureType >(code_);
}
inline void Failure::set_code(::TrezorProtobuf::FailureType value) {
  assert(::TrezorProtobuf::FailureType_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Failure.code)
}

// optional string message = 2;
inline bool Failure::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Failure::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Failure::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Failure::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& Failure::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Failure.message)
  return message_.GetNoArena();
}
inline void Failure::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Failure.message)
}
#if LANG_CXX11
inline void Failure::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Failure.message)
}
#endif
inline void Failure::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Failure.message)
}
inline void Failure::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Failure.message)
}
inline ::std::string* Failure::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Failure.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Failure::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Failure.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Failure::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Failure.message)
}

// -------------------------------------------------------------------

// ButtonRequest

// optional .TrezorProtobuf.ButtonRequestType code = 1;
inline bool ButtonRequest::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ButtonRequest::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ButtonRequest::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ButtonRequest::clear_code() {
  code_ = 1;
  clear_has_code();
}
inline ::TrezorProtobuf::ButtonRequestType ButtonRequest::code() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ButtonRequest.code)
  return static_cast< ::TrezorProtobuf::ButtonRequestType >(code_);
}
inline void ButtonRequest::set_code(::TrezorProtobuf::ButtonRequestType value) {
  assert(::TrezorProtobuf::ButtonRequestType_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ButtonRequest.code)
}

// optional string data = 2;
inline bool ButtonRequest::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ButtonRequest::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ButtonRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ButtonRequest::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ButtonRequest::data() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ButtonRequest.data)
  return data_.GetNoArena();
}
inline void ButtonRequest::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ButtonRequest.data)
}
#if LANG_CXX11
inline void ButtonRequest::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ButtonRequest.data)
}
#endif
inline void ButtonRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ButtonRequest.data)
}
inline void ButtonRequest::set_data(const char* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ButtonRequest.data)
}
inline ::std::string* ButtonRequest::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ButtonRequest.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ButtonRequest::release_data() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ButtonRequest.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ButtonRequest::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ButtonRequest.data)
}

// -------------------------------------------------------------------

// ButtonAck

// -------------------------------------------------------------------

// PinMatrixRequest

// optional .TrezorProtobuf.PinMatrixRequestType type = 1;
inline bool PinMatrixRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinMatrixRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinMatrixRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinMatrixRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::TrezorProtobuf::PinMatrixRequestType PinMatrixRequest::type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PinMatrixRequest.type)
  return static_cast< ::TrezorProtobuf::PinMatrixRequestType >(type_);
}
inline void PinMatrixRequest::set_type(::TrezorProtobuf::PinMatrixRequestType value) {
  assert(::TrezorProtobuf::PinMatrixRequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PinMatrixRequest.type)
}

// -------------------------------------------------------------------

// PinMatrixAck

// required string pin = 1;
inline bool PinMatrixAck::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinMatrixAck::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinMatrixAck::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinMatrixAck::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
inline const ::std::string& PinMatrixAck::pin() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PinMatrixAck.pin)
  return pin_.GetNoArena();
}
inline void PinMatrixAck::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PinMatrixAck.pin)
}
#if LANG_CXX11
inline void PinMatrixAck::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.PinMatrixAck.pin)
}
#endif
inline void PinMatrixAck::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.PinMatrixAck.pin)
}
inline void PinMatrixAck::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.PinMatrixAck.pin)
}
inline ::std::string* PinMatrixAck::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PinMatrixAck.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PinMatrixAck::release_pin() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PinMatrixAck.pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PinMatrixAck::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PinMatrixAck.pin)
}

// -------------------------------------------------------------------

// Cancel

// -------------------------------------------------------------------

// PassphraseRequest

// -------------------------------------------------------------------

// PassphraseAck

// required string passphrase = 1;
inline bool PassphraseAck::has_passphrase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassphraseAck::set_has_passphrase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassphraseAck::clear_has_passphrase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassphraseAck::clear_passphrase() {
  passphrase_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_passphrase();
}
inline const ::std::string& PassphraseAck::passphrase() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PassphraseAck.passphrase)
  return passphrase_.GetNoArena();
}
inline void PassphraseAck::set_passphrase(const ::std::string& value) {
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PassphraseAck.passphrase)
}
#if LANG_CXX11
inline void PassphraseAck::set_passphrase(::std::string&& value) {
  set_has_passphrase();
  passphrase_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.PassphraseAck.passphrase)
}
#endif
inline void PassphraseAck::set_passphrase(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.PassphraseAck.passphrase)
}
inline void PassphraseAck::set_passphrase(const char* value, size_t size) {
  set_has_passphrase();
  passphrase_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.PassphraseAck.passphrase)
}
inline ::std::string* PassphraseAck::mutable_passphrase() {
  set_has_passphrase();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PassphraseAck.passphrase)
  return passphrase_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PassphraseAck::release_passphrase() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PassphraseAck.passphrase)
  clear_has_passphrase();
  return passphrase_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PassphraseAck::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase != NULL) {
    set_has_passphrase();
  } else {
    clear_has_passphrase();
  }
  passphrase_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passphrase);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PassphraseAck.passphrase)
}

// -------------------------------------------------------------------

// GetEntropy

// required uint32 size = 1;
inline bool GetEntropy::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEntropy::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEntropy::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEntropy::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 GetEntropy::size() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetEntropy.size)
  return size_;
}
inline void GetEntropy::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetEntropy.size)
}

// -------------------------------------------------------------------

// Entropy

// required bytes entropy = 1;
inline bool Entropy::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entropy::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entropy::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entropy::clear_entropy() {
  entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entropy();
}
inline const ::std::string& Entropy::entropy() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Entropy.entropy)
  return entropy_.GetNoArena();
}
inline void Entropy::set_entropy(const ::std::string& value) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Entropy.entropy)
}
#if LANG_CXX11
inline void Entropy::set_entropy(::std::string&& value) {
  set_has_entropy();
  entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Entropy.entropy)
}
#endif
inline void Entropy::set_entropy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Entropy.entropy)
}
inline void Entropy::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Entropy.entropy)
}
inline ::std::string* Entropy::mutable_entropy() {
  set_has_entropy();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Entropy.entropy)
  return entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Entropy::release_entropy() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Entropy.entropy)
  clear_has_entropy();
  return entropy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Entropy::set_allocated_entropy(::std::string* entropy) {
  if (entropy != NULL) {
    set_has_entropy();
  } else {
    clear_has_entropy();
  }
  entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entropy);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Entropy.entropy)
}

// -------------------------------------------------------------------

// GetPublicKey

// repeated uint32 address_n = 1;
inline int GetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void GetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetPublicKey::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.address_n)
  return address_n_.Get(index);
}
inline void GetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.address_n)
}
inline void GetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.GetPublicKey.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetPublicKey::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.GetPublicKey.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetPublicKey::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.GetPublicKey.address_n)
  return &address_n_;
}

// optional string ecdsa_curve_name = 2;
inline bool GetPublicKey::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPublicKey::set_has_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPublicKey::clear_has_ecdsa_curve_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPublicKey::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecdsa_curve_name();
}
inline const ::std::string& GetPublicKey::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
inline void GetPublicKey::set_ecdsa_curve_name(const ::std::string& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
#if LANG_CXX11
inline void GetPublicKey::set_ecdsa_curve_name(::std::string&& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
#endif
inline void GetPublicKey::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
inline void GetPublicKey::set_ecdsa_curve_name(const char* value, size_t size) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}
inline ::std::string* GetPublicKey::mutable_ecdsa_curve_name() {
  set_has_ecdsa_curve_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPublicKey::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
  clear_has_ecdsa_curve_name();
  return ecdsa_curve_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPublicKey::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != NULL) {
    set_has_ecdsa_curve_name();
  } else {
    clear_has_ecdsa_curve_name();
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetPublicKey.ecdsa_curve_name)
}

// optional bool show_display = 3;
inline bool GetPublicKey::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPublicKey::set_has_show_display() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPublicKey::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPublicKey::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool GetPublicKey::show_display() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.show_display)
  return show_display_;
}
inline void GetPublicKey::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.show_display)
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool GetPublicKey::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPublicKey::set_has_coin_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPublicKey::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPublicKey::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&GetPublicKey::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& GetPublicKey::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetPublicKey.coin_name)
  return coin_name_.GetNoArena();
}
inline void GetPublicKey::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetPublicKey::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetPublicKey.coin_name)
}
#if LANG_CXX11
inline void GetPublicKey::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &GetPublicKey::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetPublicKey.coin_name)
}
#endif
inline void GetPublicKey::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&GetPublicKey::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetPublicKey.coin_name)
}
inline void GetPublicKey::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetPublicKey::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetPublicKey.coin_name)
}
inline ::std::string* GetPublicKey::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetPublicKey.coin_name)
  return coin_name_.MutableNoArena(&GetPublicKey::_default_coin_name_.get());
}
inline ::std::string* GetPublicKey::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetPublicKey.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&GetPublicKey::_default_coin_name_.get());
}
inline void GetPublicKey::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&GetPublicKey::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetPublicKey.coin_name)
}

// -------------------------------------------------------------------

// PublicKey

// required .TrezorProtobuf.HDNodeType node = 1;
inline bool PublicKey::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicKey::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicKey::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicKey::clear_node() {
  if (node_ != NULL) node_->::TrezorProtobuf::HDNodeType::Clear();
  clear_has_node();
}
inline const ::TrezorProtobuf::HDNodeType& PublicKey::node() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PublicKey.node)
  return node_ != NULL ? *node_
                         : *::TrezorProtobuf::HDNodeType::internal_default_instance();
}
inline ::TrezorProtobuf::HDNodeType* PublicKey::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    node_ = new ::TrezorProtobuf::HDNodeType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PublicKey.node)
  return node_;
}
inline ::TrezorProtobuf::HDNodeType* PublicKey::release_node() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PublicKey.node)
  clear_has_node();
  ::TrezorProtobuf::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void PublicKey::set_allocated_node(::TrezorProtobuf::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PublicKey.node)
}

// optional string xpub = 2;
inline bool PublicKey::has_xpub() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicKey::set_has_xpub() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicKey::clear_has_xpub() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicKey::clear_xpub() {
  xpub_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_xpub();
}
inline const ::std::string& PublicKey::xpub() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.PublicKey.xpub)
  return xpub_.GetNoArena();
}
inline void PublicKey::set_xpub(const ::std::string& value) {
  set_has_xpub();
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.PublicKey.xpub)
}
#if LANG_CXX11
inline void PublicKey::set_xpub(::std::string&& value) {
  set_has_xpub();
  xpub_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.PublicKey.xpub)
}
#endif
inline void PublicKey::set_xpub(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_xpub();
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.PublicKey.xpub)
}
inline void PublicKey::set_xpub(const char* value, size_t size) {
  set_has_xpub();
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.PublicKey.xpub)
}
inline ::std::string* PublicKey::mutable_xpub() {
  set_has_xpub();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.PublicKey.xpub)
  return xpub_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKey::release_xpub() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.PublicKey.xpub)
  clear_has_xpub();
  return xpub_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKey::set_allocated_xpub(::std::string* xpub) {
  if (xpub != NULL) {
    set_has_xpub();
  } else {
    clear_has_xpub();
  }
  xpub_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xpub);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.PublicKey.xpub)
}

// -------------------------------------------------------------------

// GetAddress

// repeated uint32 address_n = 1;
inline int GetAddress::address_n_size() const {
  return address_n_.size();
}
inline void GetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.address_n)
  return address_n_.Get(index);
}
inline void GetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.address_n)
}
inline void GetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.GetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.GetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.GetAddress.address_n)
  return &address_n_;
}

// optional string coin_name = 2 [default = "Bitcoin"];
inline bool GetAddress::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAddress::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAddress::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAddress::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&GetAddress::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& GetAddress::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.coin_name)
  return coin_name_.GetNoArena();
}
inline void GetAddress::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetAddress::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.coin_name)
}
#if LANG_CXX11
inline void GetAddress::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &GetAddress::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetAddress.coin_name)
}
#endif
inline void GetAddress::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&GetAddress::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetAddress.coin_name)
}
inline void GetAddress::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&GetAddress::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetAddress.coin_name)
}
inline ::std::string* GetAddress::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetAddress.coin_name)
  return coin_name_.MutableNoArena(&GetAddress::_default_coin_name_.get());
}
inline ::std::string* GetAddress::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetAddress.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&GetAddress::_default_coin_name_.get());
}
inline void GetAddress::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&GetAddress::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetAddress.coin_name)
}

// optional bool show_display = 3;
inline bool GetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool GetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.show_display)
  return show_display_;
}
inline void GetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.show_display)
}

// optional .TrezorProtobuf.MultisigRedeemScriptType multisig = 4;
inline bool GetAddress::has_multisig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAddress::set_has_multisig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAddress::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAddress::clear_multisig() {
  if (multisig_ != NULL) multisig_->::TrezorProtobuf::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::TrezorProtobuf::MultisigRedeemScriptType& GetAddress::multisig() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.multisig)
  return multisig_ != NULL ? *multisig_
                         : *::TrezorProtobuf::MultisigRedeemScriptType::internal_default_instance();
}
inline ::TrezorProtobuf::MultisigRedeemScriptType* GetAddress::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) {
    multisig_ = new ::TrezorProtobuf::MultisigRedeemScriptType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetAddress.multisig)
  return multisig_;
}
inline ::TrezorProtobuf::MultisigRedeemScriptType* GetAddress::release_multisig() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetAddress.multisig)
  clear_has_multisig();
  ::TrezorProtobuf::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void GetAddress::set_allocated_multisig(::TrezorProtobuf::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetAddress.multisig)
}

// optional .TrezorProtobuf.InputScriptType script_type = 5 [default = SPENDADDRESS];
inline bool GetAddress::has_script_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetAddress::set_has_script_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetAddress::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetAddress::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::TrezorProtobuf::InputScriptType GetAddress::script_type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetAddress.script_type)
  return static_cast< ::TrezorProtobuf::InputScriptType >(script_type_);
}
inline void GetAddress::set_script_type(::TrezorProtobuf::InputScriptType value) {
  assert(::TrezorProtobuf::InputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetAddress.script_type)
}

// -------------------------------------------------------------------

// EthereumGetAddress

// repeated uint32 address_n = 1;
inline int EthereumGetAddress::address_n_size() const {
  return address_n_.size();
}
inline void EthereumGetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EthereumGetAddress::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumGetAddress.address_n)
  return address_n_.Get(index);
}
inline void EthereumGetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumGetAddress.address_n)
}
inline void EthereumGetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.EthereumGetAddress.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumGetAddress::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.EthereumGetAddress.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumGetAddress::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.EthereumGetAddress.address_n)
  return &address_n_;
}

// optional bool show_display = 2;
inline bool EthereumGetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumGetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthereumGetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthereumGetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool EthereumGetAddress::show_display() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumGetAddress.show_display)
  return show_display_;
}
inline void EthereumGetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumGetAddress.show_display)
}

// -------------------------------------------------------------------

// Address

// required string address = 1;
inline bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& Address::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.Address.address)
  return address_.GetNoArena();
}
inline void Address::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.Address.address)
}
#if LANG_CXX11
inline void Address::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.Address.address)
}
#endif
inline void Address::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.Address.address)
}
inline void Address::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.Address.address)
}
inline ::std::string* Address::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.Address.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Address::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.Address.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Address::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.Address.address)
}

// -------------------------------------------------------------------

// EthereumAddress

// required bytes address = 1;
inline bool EthereumAddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumAddress::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthereumAddress::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthereumAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& EthereumAddress::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumAddress.address)
  return address_.GetNoArena();
}
inline void EthereumAddress::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumAddress.address)
}
#if LANG_CXX11
inline void EthereumAddress::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumAddress.address)
}
#endif
inline void EthereumAddress::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumAddress.address)
}
inline void EthereumAddress::set_address(const void* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumAddress.address)
}
inline ::std::string* EthereumAddress::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumAddress::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumAddress.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumAddress.address)
}

// -------------------------------------------------------------------

// WipeDevice

// -------------------------------------------------------------------

// LoadDevice

// optional string mnemonic = 1;
inline bool LoadDevice::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadDevice::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadDevice::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadDevice::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mnemonic();
}
inline const ::std::string& LoadDevice::mnemonic() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.mnemonic)
  return mnemonic_.GetNoArena();
}
inline void LoadDevice::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.mnemonic)
}
#if LANG_CXX11
inline void LoadDevice::set_mnemonic(::std::string&& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.mnemonic)
}
#endif
inline void LoadDevice::set_mnemonic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.mnemonic)
}
inline void LoadDevice::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.mnemonic)
}
inline ::std::string* LoadDevice::mutable_mnemonic() {
  set_has_mnemonic();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadDevice::release_mnemonic() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.mnemonic)
  clear_has_mnemonic();
  return mnemonic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadDevice::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    set_has_mnemonic();
  } else {
    clear_has_mnemonic();
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.mnemonic)
}

// optional .TrezorProtobuf.HDNodeType node = 2;
inline bool LoadDevice::has_node() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoadDevice::set_has_node() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoadDevice::clear_has_node() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoadDevice::clear_node() {
  if (node_ != NULL) node_->::TrezorProtobuf::HDNodeType::Clear();
  clear_has_node();
}
inline const ::TrezorProtobuf::HDNodeType& LoadDevice::node() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.node)
  return node_ != NULL ? *node_
                         : *::TrezorProtobuf::HDNodeType::internal_default_instance();
}
inline ::TrezorProtobuf::HDNodeType* LoadDevice::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    node_ = new ::TrezorProtobuf::HDNodeType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.node)
  return node_;
}
inline ::TrezorProtobuf::HDNodeType* LoadDevice::release_node() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.node)
  clear_has_node();
  ::TrezorProtobuf::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void LoadDevice::set_allocated_node(::TrezorProtobuf::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.node)
}

// optional string pin = 3;
inline bool LoadDevice::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadDevice::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadDevice::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadDevice::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
inline const ::std::string& LoadDevice::pin() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.pin)
  return pin_.GetNoArena();
}
inline void LoadDevice::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.pin)
}
#if LANG_CXX11
inline void LoadDevice::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.pin)
}
#endif
inline void LoadDevice::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.pin)
}
inline void LoadDevice::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.pin)
}
inline ::std::string* LoadDevice::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadDevice::release_pin() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadDevice::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.pin)
}

// optional bool passphrase_protection = 4;
inline bool LoadDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoadDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoadDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoadDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool LoadDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.passphrase_protection)
  return passphrase_protection_;
}
inline void LoadDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.passphrase_protection)
}

// optional string language = 5 [default = "english"];
inline bool LoadDevice::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadDevice::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadDevice::clear_language() {
  language_.ClearToDefaultNoArena(&LoadDevice::_default_language_.get());
  clear_has_language();
}
inline const ::std::string& LoadDevice::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.language)
  return language_.GetNoArena();
}
inline void LoadDevice::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&LoadDevice::_default_language_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.language)
}
#if LANG_CXX11
inline void LoadDevice::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &LoadDevice::_default_language_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.language)
}
#endif
inline void LoadDevice::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&LoadDevice::_default_language_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.language)
}
inline void LoadDevice::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&LoadDevice::_default_language_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.language)
}
inline ::std::string* LoadDevice::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.language)
  return language_.MutableNoArena(&LoadDevice::_default_language_.get());
}
inline ::std::string* LoadDevice::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.language)
  clear_has_language();
  return language_.ReleaseNoArena(&LoadDevice::_default_language_.get());
}
inline void LoadDevice::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&LoadDevice::_default_language_.get(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.language)
}

// optional string label = 6;
inline bool LoadDevice::has_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadDevice::set_has_label() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadDevice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& LoadDevice::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.label)
  return label_.GetNoArena();
}
inline void LoadDevice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.label)
}
#if LANG_CXX11
inline void LoadDevice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.LoadDevice.label)
}
#endif
inline void LoadDevice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.LoadDevice.label)
}
inline void LoadDevice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.LoadDevice.label)
}
inline ::std::string* LoadDevice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.LoadDevice.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoadDevice::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.LoadDevice.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoadDevice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.LoadDevice.label)
}

// optional bool skip_checksum = 7;
inline bool LoadDevice::has_skip_checksum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoadDevice::set_has_skip_checksum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoadDevice::clear_has_skip_checksum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoadDevice::clear_skip_checksum() {
  skip_checksum_ = false;
  clear_has_skip_checksum();
}
inline bool LoadDevice::skip_checksum() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.skip_checksum)
  return skip_checksum_;
}
inline void LoadDevice::set_skip_checksum(bool value) {
  set_has_skip_checksum();
  skip_checksum_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.skip_checksum)
}

// optional uint32 u2f_counter = 8;
inline bool LoadDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoadDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoadDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoadDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 LoadDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.LoadDevice.u2f_counter)
  return u2f_counter_;
}
inline void LoadDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.LoadDevice.u2f_counter)
}

// -------------------------------------------------------------------

// ResetDevice

// optional bool display_random = 1;
inline bool ResetDevice::has_display_random() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResetDevice::set_has_display_random() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResetDevice::clear_has_display_random() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResetDevice::clear_display_random() {
  display_random_ = false;
  clear_has_display_random();
}
inline bool ResetDevice::display_random() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.display_random)
  return display_random_;
}
inline void ResetDevice::set_display_random(bool value) {
  set_has_display_random();
  display_random_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.display_random)
}

// optional uint32 strength = 2 [default = 256];
inline bool ResetDevice::has_strength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResetDevice::set_has_strength() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResetDevice::clear_has_strength() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResetDevice::clear_strength() {
  strength_ = 256u;
  clear_has_strength();
}
inline ::google::protobuf::uint32 ResetDevice::strength() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.strength)
  return strength_;
}
inline void ResetDevice::set_strength(::google::protobuf::uint32 value) {
  set_has_strength();
  strength_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.strength)
}

// optional bool passphrase_protection = 3;
inline bool ResetDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResetDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResetDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResetDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool ResetDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.passphrase_protection)
  return passphrase_protection_;
}
inline void ResetDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.passphrase_protection)
}

// optional bool pin_protection = 4;
inline bool ResetDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResetDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResetDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResetDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool ResetDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.pin_protection)
  return pin_protection_;
}
inline void ResetDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.pin_protection)
}

// optional string language = 5 [default = "english"];
inline bool ResetDevice::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetDevice::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetDevice::clear_language() {
  language_.ClearToDefaultNoArena(&ResetDevice::_default_language_.get());
  clear_has_language();
}
inline const ::std::string& ResetDevice::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.language)
  return language_.GetNoArena();
}
inline void ResetDevice::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&ResetDevice::_default_language_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.language)
}
#if LANG_CXX11
inline void ResetDevice::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &ResetDevice::_default_language_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ResetDevice.language)
}
#endif
inline void ResetDevice::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&ResetDevice::_default_language_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ResetDevice.language)
}
inline void ResetDevice::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&ResetDevice::_default_language_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ResetDevice.language)
}
inline ::std::string* ResetDevice::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ResetDevice.language)
  return language_.MutableNoArena(&ResetDevice::_default_language_.get());
}
inline ::std::string* ResetDevice::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ResetDevice.language)
  clear_has_language();
  return language_.ReleaseNoArena(&ResetDevice::_default_language_.get());
}
inline void ResetDevice::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&ResetDevice::_default_language_.get(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ResetDevice.language)
}

// optional string label = 6;
inline bool ResetDevice::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetDevice::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetDevice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& ResetDevice::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.label)
  return label_.GetNoArena();
}
inline void ResetDevice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.label)
}
#if LANG_CXX11
inline void ResetDevice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ResetDevice.label)
}
#endif
inline void ResetDevice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ResetDevice.label)
}
inline void ResetDevice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ResetDevice.label)
}
inline ::std::string* ResetDevice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ResetDevice.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetDevice::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ResetDevice.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetDevice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ResetDevice.label)
}

// optional uint32 u2f_counter = 7;
inline bool ResetDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResetDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResetDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResetDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 ResetDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ResetDevice.u2f_counter)
  return u2f_counter_;
}
inline void ResetDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ResetDevice.u2f_counter)
}

// -------------------------------------------------------------------

// EntropyRequest

// -------------------------------------------------------------------

// EntropyAck

// optional bytes entropy = 1;
inline bool EntropyAck::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntropyAck::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntropyAck::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntropyAck::clear_entropy() {
  entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entropy();
}
inline const ::std::string& EntropyAck::entropy() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EntropyAck.entropy)
  return entropy_.GetNoArena();
}
inline void EntropyAck::set_entropy(const ::std::string& value) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EntropyAck.entropy)
}
#if LANG_CXX11
inline void EntropyAck::set_entropy(::std::string&& value) {
  set_has_entropy();
  entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EntropyAck.entropy)
}
#endif
inline void EntropyAck::set_entropy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EntropyAck.entropy)
}
inline void EntropyAck::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EntropyAck.entropy)
}
inline ::std::string* EntropyAck::mutable_entropy() {
  set_has_entropy();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EntropyAck.entropy)
  return entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntropyAck::release_entropy() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EntropyAck.entropy)
  clear_has_entropy();
  return entropy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntropyAck::set_allocated_entropy(::std::string* entropy) {
  if (entropy != NULL) {
    set_has_entropy();
  } else {
    clear_has_entropy();
  }
  entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entropy);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EntropyAck.entropy)
}

// -------------------------------------------------------------------

// RecoveryDevice

// optional uint32 word_count = 1;
inline bool RecoveryDevice::has_word_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecoveryDevice::set_has_word_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecoveryDevice::clear_has_word_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecoveryDevice::clear_word_count() {
  word_count_ = 0u;
  clear_has_word_count();
}
inline ::google::protobuf::uint32 RecoveryDevice::word_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.word_count)
  return word_count_;
}
inline void RecoveryDevice::set_word_count(::google::protobuf::uint32 value) {
  set_has_word_count();
  word_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.word_count)
}

// optional bool passphrase_protection = 2;
inline bool RecoveryDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecoveryDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecoveryDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecoveryDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool RecoveryDevice::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.passphrase_protection)
  return passphrase_protection_;
}
inline void RecoveryDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.passphrase_protection)
}

// optional bool pin_protection = 3;
inline bool RecoveryDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecoveryDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecoveryDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecoveryDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool RecoveryDevice::pin_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.pin_protection)
  return pin_protection_;
}
inline void RecoveryDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.pin_protection)
}

// optional string language = 4 [default = "english"];
inline bool RecoveryDevice::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecoveryDevice::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecoveryDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecoveryDevice::clear_language() {
  language_.ClearToDefaultNoArena(&RecoveryDevice::_default_language_.get());
  clear_has_language();
}
inline const ::std::string& RecoveryDevice::language() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.language)
  return language_.GetNoArena();
}
inline void RecoveryDevice::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&RecoveryDevice::_default_language_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.language)
}
#if LANG_CXX11
inline void RecoveryDevice::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &RecoveryDevice::_default_language_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.RecoveryDevice.language)
}
#endif
inline void RecoveryDevice::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&RecoveryDevice::_default_language_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.RecoveryDevice.language)
}
inline void RecoveryDevice::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&RecoveryDevice::_default_language_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.RecoveryDevice.language)
}
inline ::std::string* RecoveryDevice::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.RecoveryDevice.language)
  return language_.MutableNoArena(&RecoveryDevice::_default_language_.get());
}
inline ::std::string* RecoveryDevice::release_language() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.RecoveryDevice.language)
  clear_has_language();
  return language_.ReleaseNoArena(&RecoveryDevice::_default_language_.get());
}
inline void RecoveryDevice::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&RecoveryDevice::_default_language_.get(), language);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.RecoveryDevice.language)
}

// optional string label = 5;
inline bool RecoveryDevice::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecoveryDevice::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecoveryDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecoveryDevice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& RecoveryDevice::label() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.label)
  return label_.GetNoArena();
}
inline void RecoveryDevice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.label)
}
#if LANG_CXX11
inline void RecoveryDevice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.RecoveryDevice.label)
}
#endif
inline void RecoveryDevice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.RecoveryDevice.label)
}
inline void RecoveryDevice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.RecoveryDevice.label)
}
inline ::std::string* RecoveryDevice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.RecoveryDevice.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RecoveryDevice::release_label() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.RecoveryDevice.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RecoveryDevice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.RecoveryDevice.label)
}

// optional bool enforce_wordlist = 6;
inline bool RecoveryDevice::has_enforce_wordlist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecoveryDevice::set_has_enforce_wordlist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecoveryDevice::clear_has_enforce_wordlist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecoveryDevice::clear_enforce_wordlist() {
  enforce_wordlist_ = false;
  clear_has_enforce_wordlist();
}
inline bool RecoveryDevice::enforce_wordlist() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.enforce_wordlist)
  return enforce_wordlist_;
}
inline void RecoveryDevice::set_enforce_wordlist(bool value) {
  set_has_enforce_wordlist();
  enforce_wordlist_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.enforce_wordlist)
}

// optional uint32 type = 8;
inline bool RecoveryDevice::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RecoveryDevice::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RecoveryDevice::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RecoveryDevice::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 RecoveryDevice::type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.type)
  return type_;
}
inline void RecoveryDevice::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.type)
}

// optional uint32 u2f_counter = 9;
inline bool RecoveryDevice::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RecoveryDevice::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RecoveryDevice::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RecoveryDevice::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 RecoveryDevice::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.RecoveryDevice.u2f_counter)
  return u2f_counter_;
}
inline void RecoveryDevice::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.RecoveryDevice.u2f_counter)
}

// -------------------------------------------------------------------

// WordRequest

// optional .TrezorProtobuf.WordRequestType type = 1;
inline bool WordRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::TrezorProtobuf::WordRequestType WordRequest::type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.WordRequest.type)
  return static_cast< ::TrezorProtobuf::WordRequestType >(type_);
}
inline void WordRequest::set_type(::TrezorProtobuf::WordRequestType value) {
  assert(::TrezorProtobuf::WordRequestType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.WordRequest.type)
}

// -------------------------------------------------------------------

// WordAck

// required string word = 1;
inline bool WordAck::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordAck::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordAck::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordAck::clear_word() {
  word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_word();
}
inline const ::std::string& WordAck::word() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.WordAck.word)
  return word_.GetNoArena();
}
inline void WordAck::set_word(const ::std::string& value) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.WordAck.word)
}
#if LANG_CXX11
inline void WordAck::set_word(::std::string&& value) {
  set_has_word();
  word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.WordAck.word)
}
#endif
inline void WordAck::set_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.WordAck.word)
}
inline void WordAck::set_word(const char* value, size_t size) {
  set_has_word();
  word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.WordAck.word)
}
inline ::std::string* WordAck::mutable_word() {
  set_has_word();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.WordAck.word)
  return word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WordAck::release_word() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.WordAck.word)
  clear_has_word();
  return word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WordAck::set_allocated_word(::std::string* word) {
  if (word != NULL) {
    set_has_word();
  } else {
    clear_has_word();
  }
  word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), word);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.WordAck.word)
}

// -------------------------------------------------------------------

// SignMessage

// repeated uint32 address_n = 1;
inline int SignMessage::address_n_size() const {
  return address_n_.size();
}
inline void SignMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 SignMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignMessage.address_n)
  return address_n_.Get(index);
}
inline void SignMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignMessage.address_n)
}
inline void SignMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SignMessage.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SignMessage::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SignMessage.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SignMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SignMessage.address_n)
  return &address_n_;
}

// required bytes message = 2;
inline bool SignMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& SignMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignMessage.message)
  return message_.GetNoArena();
}
inline void SignMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignMessage.message)
}
#if LANG_CXX11
inline void SignMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignMessage.message)
}
#endif
inline void SignMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignMessage.message)
}
inline void SignMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignMessage.message)
}
inline ::std::string* SignMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignMessage.message)
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&SignMessage::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& SignMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignMessage.coin_name)
  return coin_name_.GetNoArena();
}
inline void SignMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignMessage::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignMessage.coin_name)
}
#if LANG_CXX11
inline void SignMessage::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &SignMessage::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignMessage.coin_name)
}
#endif
inline void SignMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&SignMessage::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignMessage.coin_name)
}
inline void SignMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignMessage::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignMessage.coin_name)
}
inline ::std::string* SignMessage::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignMessage.coin_name)
  return coin_name_.MutableNoArena(&SignMessage::_default_coin_name_.get());
}
inline ::std::string* SignMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignMessage.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&SignMessage::_default_coin_name_.get());
}
inline void SignMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&SignMessage::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignMessage.coin_name)
}

// -------------------------------------------------------------------

// VerifyMessage

// optional string address = 1;
inline bool VerifyMessage::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyMessage::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyMessage::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyMessage::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& VerifyMessage::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.address)
  return address_.GetNoArena();
}
inline void VerifyMessage::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.address)
}
#if LANG_CXX11
inline void VerifyMessage::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.address)
}
#endif
inline void VerifyMessage::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.address)
}
inline void VerifyMessage::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.address)
}
inline ::std::string* VerifyMessage::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyMessage::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyMessage::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.address)
}

// optional bytes signature = 2;
inline bool VerifyMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyMessage::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& VerifyMessage::signature() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.signature)
  return signature_.GetNoArena();
}
inline void VerifyMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.signature)
}
#if LANG_CXX11
inline void VerifyMessage::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.signature)
}
#endif
inline void VerifyMessage::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.signature)
}
inline void VerifyMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.signature)
}
inline ::std::string* VerifyMessage::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyMessage::release_signature() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyMessage::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.signature)
}

// optional bytes message = 3;
inline bool VerifyMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& VerifyMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.message)
  return message_.GetNoArena();
}
inline void VerifyMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.message)
}
#if LANG_CXX11
inline void VerifyMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.message)
}
#endif
inline void VerifyMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.message)
}
inline void VerifyMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.message)
}
inline ::std::string* VerifyMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.message)
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool VerifyMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&VerifyMessage::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& VerifyMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.VerifyMessage.coin_name)
  return coin_name_.GetNoArena();
}
inline void VerifyMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&VerifyMessage::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.VerifyMessage.coin_name)
}
#if LANG_CXX11
inline void VerifyMessage::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &VerifyMessage::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.VerifyMessage.coin_name)
}
#endif
inline void VerifyMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&VerifyMessage::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.VerifyMessage.coin_name)
}
inline void VerifyMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&VerifyMessage::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.VerifyMessage.coin_name)
}
inline ::std::string* VerifyMessage::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.VerifyMessage.coin_name)
  return coin_name_.MutableNoArena(&VerifyMessage::_default_coin_name_.get());
}
inline ::std::string* VerifyMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.VerifyMessage.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&VerifyMessage::_default_coin_name_.get());
}
inline void VerifyMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&VerifyMessage::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.VerifyMessage.coin_name)
}

// -------------------------------------------------------------------

// MessageSignature

// optional string address = 1;
inline bool MessageSignature::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageSignature::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageSignature::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageSignature::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& MessageSignature::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.MessageSignature.address)
  return address_.GetNoArena();
}
inline void MessageSignature::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.MessageSignature.address)
}
#if LANG_CXX11
inline void MessageSignature::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.MessageSignature.address)
}
#endif
inline void MessageSignature::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.MessageSignature.address)
}
inline void MessageSignature::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.MessageSignature.address)
}
inline ::std::string* MessageSignature::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.MessageSignature.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageSignature::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.MessageSignature.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageSignature::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.MessageSignature.address)
}

// optional bytes signature = 2;
inline bool MessageSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageSignature::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageSignature::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& MessageSignature::signature() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.MessageSignature.signature)
  return signature_.GetNoArena();
}
inline void MessageSignature::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.MessageSignature.signature)
}
#if LANG_CXX11
inline void MessageSignature::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.MessageSignature.signature)
}
#endif
inline void MessageSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.MessageSignature.signature)
}
inline void MessageSignature::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.MessageSignature.signature)
}
inline ::std::string* MessageSignature::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.MessageSignature.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageSignature::release_signature() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.MessageSignature.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageSignature::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.MessageSignature.signature)
}

// -------------------------------------------------------------------

// EncryptMessage

// optional bytes pubkey = 1;
inline bool EncryptMessage::has_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptMessage::set_has_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptMessage::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptMessage::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pubkey();
}
inline const ::std::string& EncryptMessage::pubkey() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.pubkey)
  return pubkey_.GetNoArena();
}
inline void EncryptMessage::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.pubkey)
}
#if LANG_CXX11
inline void EncryptMessage::set_pubkey(::std::string&& value) {
  set_has_pubkey();
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptMessage.pubkey)
}
#endif
inline void EncryptMessage::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptMessage.pubkey)
}
inline void EncryptMessage::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptMessage.pubkey)
}
inline ::std::string* EncryptMessage::mutable_pubkey() {
  set_has_pubkey();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptMessage.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptMessage::release_pubkey() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptMessage.pubkey)
  clear_has_pubkey();
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptMessage::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    set_has_pubkey();
  } else {
    clear_has_pubkey();
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptMessage.pubkey)
}

// optional bytes message = 2;
inline bool EncryptMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& EncryptMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.message)
  return message_.GetNoArena();
}
inline void EncryptMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.message)
}
#if LANG_CXX11
inline void EncryptMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptMessage.message)
}
#endif
inline void EncryptMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptMessage.message)
}
inline void EncryptMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptMessage.message)
}
inline ::std::string* EncryptMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptMessage.message)
}

// optional bool display_only = 3;
inline bool EncryptMessage::has_display_only() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EncryptMessage::set_has_display_only() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EncryptMessage::clear_has_display_only() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EncryptMessage::clear_display_only() {
  display_only_ = false;
  clear_has_display_only();
}
inline bool EncryptMessage::display_only() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.display_only)
  return display_only_;
}
inline void EncryptMessage::set_display_only(bool value) {
  set_has_display_only();
  display_only_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.display_only)
}

// repeated uint32 address_n = 4;
inline int EncryptMessage::address_n_size() const {
  return address_n_.size();
}
inline void EncryptMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EncryptMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.address_n)
  return address_n_.Get(index);
}
inline void EncryptMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.address_n)
}
inline void EncryptMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.EncryptMessage.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EncryptMessage::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.EncryptMessage.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EncryptMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.EncryptMessage.address_n)
  return &address_n_;
}

// optional string coin_name = 5 [default = "Bitcoin"];
inline bool EncryptMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptMessage::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&EncryptMessage::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& EncryptMessage::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptMessage.coin_name)
  return coin_name_.GetNoArena();
}
inline void EncryptMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EncryptMessage::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptMessage.coin_name)
}
#if LANG_CXX11
inline void EncryptMessage::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &EncryptMessage::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptMessage.coin_name)
}
#endif
inline void EncryptMessage::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&EncryptMessage::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptMessage.coin_name)
}
inline void EncryptMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EncryptMessage::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptMessage.coin_name)
}
inline ::std::string* EncryptMessage::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptMessage.coin_name)
  return coin_name_.MutableNoArena(&EncryptMessage::_default_coin_name_.get());
}
inline ::std::string* EncryptMessage::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptMessage.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&EncryptMessage::_default_coin_name_.get());
}
inline void EncryptMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&EncryptMessage::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptMessage.coin_name)
}

// -------------------------------------------------------------------

// EncryptedMessage

// optional bytes nonce = 1;
inline bool EncryptedMessage::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptedMessage::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptedMessage::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptedMessage::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
inline const ::std::string& EncryptedMessage::nonce() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptedMessage.nonce)
  return nonce_.GetNoArena();
}
inline void EncryptedMessage::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptedMessage.nonce)
}
#if LANG_CXX11
inline void EncryptedMessage::set_nonce(::std::string&& value) {
  set_has_nonce();
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptedMessage.nonce)
}
#endif
inline void EncryptedMessage::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptedMessage.nonce)
}
inline void EncryptedMessage::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptedMessage.nonce)
}
inline ::std::string* EncryptedMessage::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptedMessage.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptedMessage::release_nonce() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptedMessage.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptedMessage::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptedMessage.nonce)
}

// optional bytes message = 2;
inline bool EncryptedMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptedMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptedMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptedMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& EncryptedMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptedMessage.message)
  return message_.GetNoArena();
}
inline void EncryptedMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptedMessage.message)
}
#if LANG_CXX11
inline void EncryptedMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptedMessage.message)
}
#endif
inline void EncryptedMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptedMessage.message)
}
inline void EncryptedMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptedMessage.message)
}
inline ::std::string* EncryptedMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptedMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptedMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptedMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptedMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptedMessage.message)
}

// optional bytes hmac = 3;
inline bool EncryptedMessage::has_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptedMessage::set_has_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptedMessage::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptedMessage::clear_hmac() {
  hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hmac();
}
inline const ::std::string& EncryptedMessage::hmac() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EncryptedMessage.hmac)
  return hmac_.GetNoArena();
}
inline void EncryptedMessage::set_hmac(const ::std::string& value) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EncryptedMessage.hmac)
}
#if LANG_CXX11
inline void EncryptedMessage::set_hmac(::std::string&& value) {
  set_has_hmac();
  hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EncryptedMessage.hmac)
}
#endif
inline void EncryptedMessage::set_hmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EncryptedMessage.hmac)
}
inline void EncryptedMessage::set_hmac(const void* value, size_t size) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EncryptedMessage.hmac)
}
inline ::std::string* EncryptedMessage::mutable_hmac() {
  set_has_hmac();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EncryptedMessage.hmac)
  return hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EncryptedMessage::release_hmac() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EncryptedMessage.hmac)
  clear_has_hmac();
  return hmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EncryptedMessage::set_allocated_hmac(::std::string* hmac) {
  if (hmac != NULL) {
    set_has_hmac();
  } else {
    clear_has_hmac();
  }
  hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmac);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EncryptedMessage.hmac)
}

// -------------------------------------------------------------------

// DecryptMessage

// repeated uint32 address_n = 1;
inline int DecryptMessage::address_n_size() const {
  return address_n_.size();
}
inline void DecryptMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 DecryptMessage::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.address_n)
  return address_n_.Get(index);
}
inline void DecryptMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.address_n)
}
inline void DecryptMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.DecryptMessage.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DecryptMessage::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.DecryptMessage.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DecryptMessage::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.DecryptMessage.address_n)
  return &address_n_;
}

// optional bytes nonce = 2;
inline bool DecryptMessage::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecryptMessage::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecryptMessage::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecryptMessage::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
inline const ::std::string& DecryptMessage::nonce() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.nonce)
  return nonce_.GetNoArena();
}
inline void DecryptMessage::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.nonce)
}
#if LANG_CXX11
inline void DecryptMessage::set_nonce(::std::string&& value) {
  set_has_nonce();
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptMessage.nonce)
}
#endif
inline void DecryptMessage::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptMessage.nonce)
}
inline void DecryptMessage::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptMessage.nonce)
}
inline ::std::string* DecryptMessage::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptMessage.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecryptMessage::release_nonce() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptMessage.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptMessage::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptMessage.nonce)
}

// optional bytes message = 3;
inline bool DecryptMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecryptMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecryptMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecryptMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& DecryptMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.message)
  return message_.GetNoArena();
}
inline void DecryptMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.message)
}
#if LANG_CXX11
inline void DecryptMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptMessage.message)
}
#endif
inline void DecryptMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptMessage.message)
}
inline void DecryptMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptMessage.message)
}
inline ::std::string* DecryptMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecryptMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptMessage.message)
}

// optional bytes hmac = 4;
inline bool DecryptMessage::has_hmac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecryptMessage::set_has_hmac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecryptMessage::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecryptMessage::clear_hmac() {
  hmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hmac();
}
inline const ::std::string& DecryptMessage::hmac() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptMessage.hmac)
  return hmac_.GetNoArena();
}
inline void DecryptMessage::set_hmac(const ::std::string& value) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptMessage.hmac)
}
#if LANG_CXX11
inline void DecryptMessage::set_hmac(::std::string&& value) {
  set_has_hmac();
  hmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptMessage.hmac)
}
#endif
inline void DecryptMessage::set_hmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptMessage.hmac)
}
inline void DecryptMessage::set_hmac(const void* value, size_t size) {
  set_has_hmac();
  hmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptMessage.hmac)
}
inline ::std::string* DecryptMessage::mutable_hmac() {
  set_has_hmac();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptMessage.hmac)
  return hmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecryptMessage::release_hmac() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptMessage.hmac)
  clear_has_hmac();
  return hmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptMessage::set_allocated_hmac(::std::string* hmac) {
  if (hmac != NULL) {
    set_has_hmac();
  } else {
    clear_has_hmac();
  }
  hmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hmac);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptMessage.hmac)
}

// -------------------------------------------------------------------

// DecryptedMessage

// optional bytes message = 1;
inline bool DecryptedMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecryptedMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecryptedMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecryptedMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& DecryptedMessage::message() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptedMessage.message)
  return message_.GetNoArena();
}
inline void DecryptedMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptedMessage.message)
}
#if LANG_CXX11
inline void DecryptedMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptedMessage.message)
}
#endif
inline void DecryptedMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptedMessage.message)
}
inline void DecryptedMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptedMessage.message)
}
inline ::std::string* DecryptedMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptedMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecryptedMessage::release_message() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptedMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptedMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptedMessage.message)
}

// optional string address = 2;
inline bool DecryptedMessage::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecryptedMessage::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecryptedMessage::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecryptedMessage::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& DecryptedMessage::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DecryptedMessage.address)
  return address_.GetNoArena();
}
inline void DecryptedMessage::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DecryptedMessage.address)
}
#if LANG_CXX11
inline void DecryptedMessage::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DecryptedMessage.address)
}
#endif
inline void DecryptedMessage::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DecryptedMessage.address)
}
inline void DecryptedMessage::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DecryptedMessage.address)
}
inline ::std::string* DecryptedMessage::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DecryptedMessage.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecryptedMessage::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DecryptedMessage.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptedMessage::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DecryptedMessage.address)
}

// -------------------------------------------------------------------

// CipherKeyValue

// repeated uint32 address_n = 1;
inline int CipherKeyValue::address_n_size() const {
  return address_n_.size();
}
inline void CipherKeyValue::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CipherKeyValue::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.address_n)
  return address_n_.Get(index);
}
inline void CipherKeyValue::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.address_n)
}
inline void CipherKeyValue::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.CipherKeyValue.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CipherKeyValue::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.CipherKeyValue.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CipherKeyValue::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.CipherKeyValue.address_n)
  return &address_n_;
}

// optional string key = 2;
inline bool CipherKeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CipherKeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CipherKeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CipherKeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& CipherKeyValue::key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.key)
  return key_.GetNoArena();
}
inline void CipherKeyValue::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.key)
}
#if LANG_CXX11
inline void CipherKeyValue::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipherKeyValue.key)
}
#endif
inline void CipherKeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipherKeyValue.key)
}
inline void CipherKeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipherKeyValue.key)
}
inline ::std::string* CipherKeyValue::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipherKeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipherKeyValue::release_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipherKeyValue.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipherKeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipherKeyValue.key)
}

// optional bytes value = 3;
inline bool CipherKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CipherKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CipherKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CipherKeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& CipherKeyValue::value() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.value)
  return value_.GetNoArena();
}
inline void CipherKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.value)
}
#if LANG_CXX11
inline void CipherKeyValue::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipherKeyValue.value)
}
#endif
inline void CipherKeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipherKeyValue.value)
}
inline void CipherKeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipherKeyValue.value)
}
inline ::std::string* CipherKeyValue::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipherKeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipherKeyValue::release_value() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipherKeyValue.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipherKeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipherKeyValue.value)
}

// optional bool encrypt = 4;
inline bool CipherKeyValue::has_encrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CipherKeyValue::set_has_encrypt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CipherKeyValue::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CipherKeyValue::clear_encrypt() {
  encrypt_ = false;
  clear_has_encrypt();
}
inline bool CipherKeyValue::encrypt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.encrypt)
  return encrypt_;
}
inline void CipherKeyValue::set_encrypt(bool value) {
  set_has_encrypt();
  encrypt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.encrypt)
}

// optional bool ask_on_encrypt = 5;
inline bool CipherKeyValue::has_ask_on_encrypt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CipherKeyValue::set_has_ask_on_encrypt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CipherKeyValue::clear_has_ask_on_encrypt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CipherKeyValue::clear_ask_on_encrypt() {
  ask_on_encrypt_ = false;
  clear_has_ask_on_encrypt();
}
inline bool CipherKeyValue::ask_on_encrypt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.ask_on_encrypt)
  return ask_on_encrypt_;
}
inline void CipherKeyValue::set_ask_on_encrypt(bool value) {
  set_has_ask_on_encrypt();
  ask_on_encrypt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.ask_on_encrypt)
}

// optional bool ask_on_decrypt = 6;
inline bool CipherKeyValue::has_ask_on_decrypt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CipherKeyValue::set_has_ask_on_decrypt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CipherKeyValue::clear_has_ask_on_decrypt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CipherKeyValue::clear_ask_on_decrypt() {
  ask_on_decrypt_ = false;
  clear_has_ask_on_decrypt();
}
inline bool CipherKeyValue::ask_on_decrypt() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.ask_on_decrypt)
  return ask_on_decrypt_;
}
inline void CipherKeyValue::set_ask_on_decrypt(bool value) {
  set_has_ask_on_decrypt();
  ask_on_decrypt_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.ask_on_decrypt)
}

// optional bytes iv = 7;
inline bool CipherKeyValue::has_iv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CipherKeyValue::set_has_iv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CipherKeyValue::clear_has_iv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CipherKeyValue::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iv();
}
inline const ::std::string& CipherKeyValue::iv() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipherKeyValue.iv)
  return iv_.GetNoArena();
}
inline void CipherKeyValue::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipherKeyValue.iv)
}
#if LANG_CXX11
inline void CipherKeyValue::set_iv(::std::string&& value) {
  set_has_iv();
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipherKeyValue.iv)
}
#endif
inline void CipherKeyValue::set_iv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipherKeyValue.iv)
}
inline void CipherKeyValue::set_iv(const void* value, size_t size) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipherKeyValue.iv)
}
inline ::std::string* CipherKeyValue::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipherKeyValue.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipherKeyValue::release_iv() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipherKeyValue.iv)
  clear_has_iv();
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipherKeyValue::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipherKeyValue.iv)
}

// -------------------------------------------------------------------

// CipheredKeyValue

// optional bytes value = 1;
inline bool CipheredKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CipheredKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CipheredKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CipheredKeyValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& CipheredKeyValue::value() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.CipheredKeyValue.value)
  return value_.GetNoArena();
}
inline void CipheredKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.CipheredKeyValue.value)
}
#if LANG_CXX11
inline void CipheredKeyValue::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.CipheredKeyValue.value)
}
#endif
inline void CipheredKeyValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.CipheredKeyValue.value)
}
inline void CipheredKeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.CipheredKeyValue.value)
}
inline ::std::string* CipheredKeyValue::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.CipheredKeyValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CipheredKeyValue::release_value() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.CipheredKeyValue.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CipheredKeyValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.CipheredKeyValue.value)
}

// -------------------------------------------------------------------

// EstimateTxSize

// required uint32 outputs_count = 1;
inline bool EstimateTxSize::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EstimateTxSize::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EstimateTxSize::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EstimateTxSize::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
inline ::google::protobuf::uint32 EstimateTxSize::outputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EstimateTxSize.outputs_count)
  return outputs_count_;
}
inline void EstimateTxSize::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EstimateTxSize.outputs_count)
}

// required uint32 inputs_count = 2;
inline bool EstimateTxSize::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EstimateTxSize::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EstimateTxSize::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EstimateTxSize::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
inline ::google::protobuf::uint32 EstimateTxSize::inputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EstimateTxSize.inputs_count)
  return inputs_count_;
}
inline void EstimateTxSize::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EstimateTxSize.inputs_count)
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool EstimateTxSize::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EstimateTxSize::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EstimateTxSize::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EstimateTxSize::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&EstimateTxSize::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& EstimateTxSize::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EstimateTxSize.coin_name)
  return coin_name_.GetNoArena();
}
inline void EstimateTxSize::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EstimateTxSize::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EstimateTxSize.coin_name)
}
#if LANG_CXX11
inline void EstimateTxSize::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &EstimateTxSize::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EstimateTxSize.coin_name)
}
#endif
inline void EstimateTxSize::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&EstimateTxSize::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EstimateTxSize.coin_name)
}
inline void EstimateTxSize::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&EstimateTxSize::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EstimateTxSize.coin_name)
}
inline ::std::string* EstimateTxSize::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EstimateTxSize.coin_name)
  return coin_name_.MutableNoArena(&EstimateTxSize::_default_coin_name_.get());
}
inline ::std::string* EstimateTxSize::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EstimateTxSize.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&EstimateTxSize::_default_coin_name_.get());
}
inline void EstimateTxSize::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&EstimateTxSize::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EstimateTxSize.coin_name)
}

// -------------------------------------------------------------------

// TxSize

// optional uint32 tx_size = 1;
inline bool TxSize::has_tx_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxSize::set_has_tx_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxSize::clear_has_tx_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxSize::clear_tx_size() {
  tx_size_ = 0u;
  clear_has_tx_size();
}
inline ::google::protobuf::uint32 TxSize::tx_size() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxSize.tx_size)
  return tx_size_;
}
inline void TxSize::set_tx_size(::google::protobuf::uint32 value) {
  set_has_tx_size();
  tx_size_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxSize.tx_size)
}

// -------------------------------------------------------------------

// SignTx

// required uint32 outputs_count = 1;
inline bool SignTx::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignTx::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignTx::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignTx::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
inline ::google::protobuf::uint32 SignTx::outputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.outputs_count)
  return outputs_count_;
}
inline void SignTx::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.outputs_count)
}

// required uint32 inputs_count = 2;
inline bool SignTx::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignTx::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignTx::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignTx::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
inline ::google::protobuf::uint32 SignTx::inputs_count() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.inputs_count)
  return inputs_count_;
}
inline void SignTx::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.inputs_count)
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTx::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignTx::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignTx::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&SignTx::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& SignTx::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.coin_name)
  return coin_name_.GetNoArena();
}
inline void SignTx::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignTx::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.coin_name)
}
#if LANG_CXX11
inline void SignTx::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &SignTx::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignTx.coin_name)
}
#endif
inline void SignTx::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&SignTx::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignTx.coin_name)
}
inline void SignTx::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SignTx::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignTx.coin_name)
}
inline ::std::string* SignTx::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignTx.coin_name)
  return coin_name_.MutableNoArena(&SignTx::_default_coin_name_.get());
}
inline ::std::string* SignTx::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignTx.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&SignTx::_default_coin_name_.get());
}
inline void SignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&SignTx::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignTx.coin_name)
}

// optional uint32 version = 4 [default = 1];
inline bool SignTx::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignTx::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignTx::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignTx::clear_version() {
  version_ = 1u;
  clear_has_version();
}
inline ::google::protobuf::uint32 SignTx::version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.version)
  return version_;
}
inline void SignTx::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.version)
}

// optional uint32 lock_time = 5 [default = 0];
inline bool SignTx::has_lock_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignTx::set_has_lock_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignTx::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignTx::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
inline ::google::protobuf::uint32 SignTx::lock_time() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignTx.lock_time)
  return lock_time_;
}
inline void SignTx::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignTx.lock_time)
}

// -------------------------------------------------------------------

// SimpleSignTx

// repeated .TrezorProtobuf.TxInputType inputs = 1;
inline int SimpleSignTx::inputs_size() const {
  return inputs_.size();
}
inline void SimpleSignTx::clear_inputs() {
  inputs_.Clear();
}
inline const ::TrezorProtobuf::TxInputType& SimpleSignTx::inputs(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_.Get(index);
}
inline ::TrezorProtobuf::TxInputType* SimpleSignTx::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_.Mutable(index);
}
inline ::TrezorProtobuf::TxInputType* SimpleSignTx::add_inputs() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >*
SimpleSignTx::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SimpleSignTx.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxInputType >&
SimpleSignTx::inputs() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SimpleSignTx.inputs)
  return inputs_;
}

// repeated .TrezorProtobuf.TxOutputType outputs = 2;
inline int SimpleSignTx::outputs_size() const {
  return outputs_.size();
}
inline void SimpleSignTx::clear_outputs() {
  outputs_.Clear();
}
inline const ::TrezorProtobuf::TxOutputType& SimpleSignTx::outputs(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_.Get(index);
}
inline ::TrezorProtobuf::TxOutputType* SimpleSignTx::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_.Mutable(index);
}
inline ::TrezorProtobuf::TxOutputType* SimpleSignTx::add_outputs() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >*
SimpleSignTx::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SimpleSignTx.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TxOutputType >&
SimpleSignTx::outputs() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SimpleSignTx.outputs)
  return outputs_;
}

// repeated .TrezorProtobuf.TransactionType transactions = 3;
inline int SimpleSignTx::transactions_size() const {
  return transactions_.size();
}
inline void SimpleSignTx::clear_transactions() {
  transactions_.Clear();
}
inline const ::TrezorProtobuf::TransactionType& SimpleSignTx::transactions(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_.Get(index);
}
inline ::TrezorProtobuf::TransactionType* SimpleSignTx::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_.Mutable(index);
}
inline ::TrezorProtobuf::TransactionType* SimpleSignTx::add_transactions() {
  // @@protoc_insertion_point(field_add:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TransactionType >*
SimpleSignTx::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.SimpleSignTx.transactions)
  return &transactions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TrezorProtobuf::TransactionType >&
SimpleSignTx::transactions() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.SimpleSignTx.transactions)
  return transactions_;
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool SimpleSignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleSignTx::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleSignTx::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleSignTx::clear_coin_name() {
  coin_name_.ClearToDefaultNoArena(&SimpleSignTx::_default_coin_name_.get());
  clear_has_coin_name();
}
inline const ::std::string& SimpleSignTx::coin_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.coin_name)
  return coin_name_.GetNoArena();
}
inline void SimpleSignTx::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SimpleSignTx::_default_coin_name_.get(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SimpleSignTx.coin_name)
}
#if LANG_CXX11
inline void SimpleSignTx::set_coin_name(::std::string&& value) {
  set_has_coin_name();
  coin_name_.SetNoArena(
    &SimpleSignTx::_default_coin_name_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SimpleSignTx.coin_name)
}
#endif
inline void SimpleSignTx::set_coin_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coin_name();
  coin_name_.SetNoArena(&SimpleSignTx::_default_coin_name_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SimpleSignTx.coin_name)
}
inline void SimpleSignTx::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  coin_name_.SetNoArena(&SimpleSignTx::_default_coin_name_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SimpleSignTx.coin_name)
}
inline ::std::string* SimpleSignTx::mutable_coin_name() {
  set_has_coin_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SimpleSignTx.coin_name)
  return coin_name_.MutableNoArena(&SimpleSignTx::_default_coin_name_.get());
}
inline ::std::string* SimpleSignTx::release_coin_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SimpleSignTx.coin_name)
  clear_has_coin_name();
  return coin_name_.ReleaseNoArena(&SimpleSignTx::_default_coin_name_.get());
}
inline void SimpleSignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name != NULL) {
    set_has_coin_name();
  } else {
    clear_has_coin_name();
  }
  coin_name_.SetAllocatedNoArena(&SimpleSignTx::_default_coin_name_.get(), coin_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SimpleSignTx.coin_name)
}

// optional uint32 version = 5 [default = 1];
inline bool SimpleSignTx::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimpleSignTx::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimpleSignTx::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimpleSignTx::clear_version() {
  version_ = 1u;
  clear_has_version();
}
inline ::google::protobuf::uint32 SimpleSignTx::version() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.version)
  return version_;
}
inline void SimpleSignTx::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SimpleSignTx.version)
}

// optional uint32 lock_time = 6 [default = 0];
inline bool SimpleSignTx::has_lock_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimpleSignTx::set_has_lock_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimpleSignTx::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimpleSignTx::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
inline ::google::protobuf::uint32 SimpleSignTx::lock_time() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SimpleSignTx.lock_time)
  return lock_time_;
}
inline void SimpleSignTx::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SimpleSignTx.lock_time)
}

// -------------------------------------------------------------------

// TxRequest

// optional .TrezorProtobuf.RequestType request_type = 1;
inline bool TxRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequest::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::TrezorProtobuf::RequestType TxRequest::request_type() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequest.request_type)
  return static_cast< ::TrezorProtobuf::RequestType >(request_type_);
}
inline void TxRequest::set_request_type(::TrezorProtobuf::RequestType value) {
  assert(::TrezorProtobuf::RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.TxRequest.request_type)
}

// optional .TrezorProtobuf.TxRequestDetailsType details = 2;
inline bool TxRequest::has_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest::set_has_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequest::clear_has_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequest::clear_details() {
  if (details_ != NULL) details_->::TrezorProtobuf::TxRequestDetailsType::Clear();
  clear_has_details();
}
inline const ::TrezorProtobuf::TxRequestDetailsType& TxRequest::details() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequest.details)
  return details_ != NULL ? *details_
                         : *::TrezorProtobuf::TxRequestDetailsType::internal_default_instance();
}
inline ::TrezorProtobuf::TxRequestDetailsType* TxRequest::mutable_details() {
  set_has_details();
  if (details_ == NULL) {
    details_ = new ::TrezorProtobuf::TxRequestDetailsType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxRequest.details)
  return details_;
}
inline ::TrezorProtobuf::TxRequestDetailsType* TxRequest::release_details() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxRequest.details)
  clear_has_details();
  ::TrezorProtobuf::TxRequestDetailsType* temp = details_;
  details_ = NULL;
  return temp;
}
inline void TxRequest::set_allocated_details(::TrezorProtobuf::TxRequestDetailsType* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxRequest.details)
}

// optional .TrezorProtobuf.TxRequestSerializedType serialized = 3;
inline bool TxRequest::has_serialized() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest::set_has_serialized() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequest::clear_has_serialized() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequest::clear_serialized() {
  if (serialized_ != NULL) serialized_->::TrezorProtobuf::TxRequestSerializedType::Clear();
  clear_has_serialized();
}
inline const ::TrezorProtobuf::TxRequestSerializedType& TxRequest::serialized() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxRequest.serialized)
  return serialized_ != NULL ? *serialized_
                         : *::TrezorProtobuf::TxRequestSerializedType::internal_default_instance();
}
inline ::TrezorProtobuf::TxRequestSerializedType* TxRequest::mutable_serialized() {
  set_has_serialized();
  if (serialized_ == NULL) {
    serialized_ = new ::TrezorProtobuf::TxRequestSerializedType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxRequest.serialized)
  return serialized_;
}
inline ::TrezorProtobuf::TxRequestSerializedType* TxRequest::release_serialized() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxRequest.serialized)
  clear_has_serialized();
  ::TrezorProtobuf::TxRequestSerializedType* temp = serialized_;
  serialized_ = NULL;
  return temp;
}
inline void TxRequest::set_allocated_serialized(::TrezorProtobuf::TxRequestSerializedType* serialized) {
  delete serialized_;
  serialized_ = serialized;
  if (serialized) {
    set_has_serialized();
  } else {
    clear_has_serialized();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxRequest.serialized)
}

// -------------------------------------------------------------------

// TxAck

// optional .TrezorProtobuf.TransactionType tx = 1;
inline bool TxAck::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck::set_has_tx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAck::clear_has_tx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAck::clear_tx() {
  if (tx_ != NULL) tx_->::TrezorProtobuf::TransactionType::Clear();
  clear_has_tx();
}
inline const ::TrezorProtobuf::TransactionType& TxAck::tx() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.TxAck.tx)
  return tx_ != NULL ? *tx_
                         : *::TrezorProtobuf::TransactionType::internal_default_instance();
}
inline ::TrezorProtobuf::TransactionType* TxAck::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) {
    tx_ = new ::TrezorProtobuf::TransactionType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.TxAck.tx)
  return tx_;
}
inline ::TrezorProtobuf::TransactionType* TxAck::release_tx() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.TxAck.tx)
  clear_has_tx();
  ::TrezorProtobuf::TransactionType* temp = tx_;
  tx_ = NULL;
  return temp;
}
inline void TxAck::set_allocated_tx(::TrezorProtobuf::TransactionType* tx) {
  delete tx_;
  tx_ = tx;
  if (tx) {
    set_has_tx();
  } else {
    clear_has_tx();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.TxAck.tx)
}

// -------------------------------------------------------------------

// EthereumSignTx

// repeated uint32 address_n = 1;
inline int EthereumSignTx::address_n_size() const {
  return address_n_.size();
}
inline void EthereumSignTx::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EthereumSignTx::address_n(int index) const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.address_n)
  return address_n_.Get(index);
}
inline void EthereumSignTx::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.address_n)
}
inline void EthereumSignTx::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
  // @@protoc_insertion_point(field_add:TrezorProtobuf.EthereumSignTx.address_n)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EthereumSignTx::address_n() const {
  // @@protoc_insertion_point(field_list:TrezorProtobuf.EthereumSignTx.address_n)
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EthereumSignTx::mutable_address_n() {
  // @@protoc_insertion_point(field_mutable_list:TrezorProtobuf.EthereumSignTx.address_n)
  return &address_n_;
}

// optional bytes nonce = 2;
inline bool EthereumSignTx::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumSignTx::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthereumSignTx::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthereumSignTx::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
inline const ::std::string& EthereumSignTx::nonce() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.nonce)
  return nonce_.GetNoArena();
}
inline void EthereumSignTx::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.nonce)
}
#if LANG_CXX11
inline void EthereumSignTx::set_nonce(::std::string&& value) {
  set_has_nonce();
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.nonce)
}
#endif
inline void EthereumSignTx::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.nonce)
}
inline void EthereumSignTx::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.nonce)
}
inline ::std::string* EthereumSignTx::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_nonce() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.nonce)
}

// optional bytes gas_price = 3;
inline bool EthereumSignTx::has_gas_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthereumSignTx::set_has_gas_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EthereumSignTx::clear_has_gas_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EthereumSignTx::clear_gas_price() {
  gas_price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gas_price();
}
inline const ::std::string& EthereumSignTx::gas_price() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.gas_price)
  return gas_price_.GetNoArena();
}
inline void EthereumSignTx::set_gas_price(const ::std::string& value) {
  set_has_gas_price();
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.gas_price)
}
#if LANG_CXX11
inline void EthereumSignTx::set_gas_price(::std::string&& value) {
  set_has_gas_price();
  gas_price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.gas_price)
}
#endif
inline void EthereumSignTx::set_gas_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gas_price();
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.gas_price)
}
inline void EthereumSignTx::set_gas_price(const void* value, size_t size) {
  set_has_gas_price();
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.gas_price)
}
inline ::std::string* EthereumSignTx::mutable_gas_price() {
  set_has_gas_price();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.gas_price)
  return gas_price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_gas_price() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.gas_price)
  clear_has_gas_price();
  return gas_price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_gas_price(::std::string* gas_price) {
  if (gas_price != NULL) {
    set_has_gas_price();
  } else {
    clear_has_gas_price();
  }
  gas_price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_price);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.gas_price)
}

// optional bytes gas_limit = 4;
inline bool EthereumSignTx::has_gas_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthereumSignTx::set_has_gas_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EthereumSignTx::clear_has_gas_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EthereumSignTx::clear_gas_limit() {
  gas_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gas_limit();
}
inline const ::std::string& EthereumSignTx::gas_limit() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.gas_limit)
  return gas_limit_.GetNoArena();
}
inline void EthereumSignTx::set_gas_limit(const ::std::string& value) {
  set_has_gas_limit();
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.gas_limit)
}
#if LANG_CXX11
inline void EthereumSignTx::set_gas_limit(::std::string&& value) {
  set_has_gas_limit();
  gas_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.gas_limit)
}
#endif
inline void EthereumSignTx::set_gas_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gas_limit();
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.gas_limit)
}
inline void EthereumSignTx::set_gas_limit(const void* value, size_t size) {
  set_has_gas_limit();
  gas_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.gas_limit)
}
inline ::std::string* EthereumSignTx::mutable_gas_limit() {
  set_has_gas_limit();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.gas_limit)
  return gas_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_gas_limit() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.gas_limit)
  clear_has_gas_limit();
  return gas_limit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_gas_limit(::std::string* gas_limit) {
  if (gas_limit != NULL) {
    set_has_gas_limit();
  } else {
    clear_has_gas_limit();
  }
  gas_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_limit);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.gas_limit)
}

// optional bytes to = 5;
inline bool EthereumSignTx::has_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EthereumSignTx::set_has_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EthereumSignTx::clear_has_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EthereumSignTx::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& EthereumSignTx::to() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.to)
  return to_.GetNoArena();
}
inline void EthereumSignTx::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.to)
}
#if LANG_CXX11
inline void EthereumSignTx::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.to)
}
#endif
inline void EthereumSignTx::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.to)
}
inline void EthereumSignTx::set_to(const void* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.to)
}
inline ::std::string* EthereumSignTx::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_to() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.to)
  clear_has_to();
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.to)
}

// optional bytes value = 6;
inline bool EthereumSignTx::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EthereumSignTx::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EthereumSignTx::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EthereumSignTx::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& EthereumSignTx::value() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.value)
  return value_.GetNoArena();
}
inline void EthereumSignTx::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.value)
}
#if LANG_CXX11
inline void EthereumSignTx::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.value)
}
#endif
inline void EthereumSignTx::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.value)
}
inline void EthereumSignTx::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.value)
}
inline ::std::string* EthereumSignTx::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_value() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.value)
}

// optional bytes data_initial_chunk = 7;
inline bool EthereumSignTx::has_data_initial_chunk() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EthereumSignTx::set_has_data_initial_chunk() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EthereumSignTx::clear_has_data_initial_chunk() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EthereumSignTx::clear_data_initial_chunk() {
  data_initial_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_initial_chunk();
}
inline const ::std::string& EthereumSignTx::data_initial_chunk() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
  return data_initial_chunk_.GetNoArena();
}
inline void EthereumSignTx::set_data_initial_chunk(const ::std::string& value) {
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
#if LANG_CXX11
inline void EthereumSignTx::set_data_initial_chunk(::std::string&& value) {
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
#endif
inline void EthereumSignTx::set_data_initial_chunk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
inline void EthereumSignTx::set_data_initial_chunk(const void* value, size_t size) {
  set_has_data_initial_chunk();
  data_initial_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}
inline ::std::string* EthereumSignTx::mutable_data_initial_chunk() {
  set_has_data_initial_chunk();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
  return data_initial_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumSignTx::release_data_initial_chunk() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
  clear_has_data_initial_chunk();
  return data_initial_chunk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumSignTx::set_allocated_data_initial_chunk(::std::string* data_initial_chunk) {
  if (data_initial_chunk != NULL) {
    set_has_data_initial_chunk();
  } else {
    clear_has_data_initial_chunk();
  }
  data_initial_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_initial_chunk);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumSignTx.data_initial_chunk)
}

// optional uint32 data_length = 8;
inline bool EthereumSignTx::has_data_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EthereumSignTx::set_has_data_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EthereumSignTx::clear_has_data_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EthereumSignTx::clear_data_length() {
  data_length_ = 0u;
  clear_has_data_length();
}
inline ::google::protobuf::uint32 EthereumSignTx::data_length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.data_length)
  return data_length_;
}
inline void EthereumSignTx::set_data_length(::google::protobuf::uint32 value) {
  set_has_data_length();
  data_length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.data_length)
}

// optional uint32 chain_id = 9;
inline bool EthereumSignTx::has_chain_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EthereumSignTx::set_has_chain_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EthereumSignTx::clear_has_chain_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EthereumSignTx::clear_chain_id() {
  chain_id_ = 0u;
  clear_has_chain_id();
}
inline ::google::protobuf::uint32 EthereumSignTx::chain_id() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumSignTx.chain_id)
  return chain_id_;
}
inline void EthereumSignTx::set_chain_id(::google::protobuf::uint32 value) {
  set_has_chain_id();
  chain_id_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumSignTx.chain_id)
}

// -------------------------------------------------------------------

// EthereumTxRequest

// optional uint32 data_length = 1;
inline bool EthereumTxRequest::has_data_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EthereumTxRequest::set_has_data_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EthereumTxRequest::clear_has_data_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EthereumTxRequest::clear_data_length() {
  data_length_ = 0u;
  clear_has_data_length();
}
inline ::google::protobuf::uint32 EthereumTxRequest::data_length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.data_length)
  return data_length_;
}
inline void EthereumTxRequest::set_data_length(::google::protobuf::uint32 value) {
  set_has_data_length();
  data_length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.data_length)
}

// optional uint32 signature_v = 2;
inline bool EthereumTxRequest::has_signature_v() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EthereumTxRequest::set_has_signature_v() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EthereumTxRequest::clear_has_signature_v() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EthereumTxRequest::clear_signature_v() {
  signature_v_ = 0u;
  clear_has_signature_v();
}
inline ::google::protobuf::uint32 EthereumTxRequest::signature_v() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.signature_v)
  return signature_v_;
}
inline void EthereumTxRequest::set_signature_v(::google::protobuf::uint32 value) {
  set_has_signature_v();
  signature_v_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.signature_v)
}

// optional bytes signature_r = 3;
inline bool EthereumTxRequest::has_signature_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumTxRequest::set_has_signature_r() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthereumTxRequest::clear_has_signature_r() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthereumTxRequest::clear_signature_r() {
  signature_r_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature_r();
}
inline const ::std::string& EthereumTxRequest::signature_r() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.signature_r)
  return signature_r_.GetNoArena();
}
inline void EthereumTxRequest::set_signature_r(const ::std::string& value) {
  set_has_signature_r();
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.signature_r)
}
#if LANG_CXX11
inline void EthereumTxRequest::set_signature_r(::std::string&& value) {
  set_has_signature_r();
  signature_r_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumTxRequest.signature_r)
}
#endif
inline void EthereumTxRequest::set_signature_r(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature_r();
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumTxRequest.signature_r)
}
inline void EthereumTxRequest::set_signature_r(const void* value, size_t size) {
  set_has_signature_r();
  signature_r_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumTxRequest.signature_r)
}
inline ::std::string* EthereumTxRequest::mutable_signature_r() {
  set_has_signature_r();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumTxRequest.signature_r)
  return signature_r_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumTxRequest::release_signature_r() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumTxRequest.signature_r)
  clear_has_signature_r();
  return signature_r_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumTxRequest::set_allocated_signature_r(::std::string* signature_r) {
  if (signature_r != NULL) {
    set_has_signature_r();
  } else {
    clear_has_signature_r();
  }
  signature_r_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_r);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumTxRequest.signature_r)
}

// optional bytes signature_s = 4;
inline bool EthereumTxRequest::has_signature_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EthereumTxRequest::set_has_signature_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EthereumTxRequest::clear_has_signature_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EthereumTxRequest::clear_signature_s() {
  signature_s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature_s();
}
inline const ::std::string& EthereumTxRequest::signature_s() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxRequest.signature_s)
  return signature_s_.GetNoArena();
}
inline void EthereumTxRequest::set_signature_s(const ::std::string& value) {
  set_has_signature_s();
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxRequest.signature_s)
}
#if LANG_CXX11
inline void EthereumTxRequest::set_signature_s(::std::string&& value) {
  set_has_signature_s();
  signature_s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumTxRequest.signature_s)
}
#endif
inline void EthereumTxRequest::set_signature_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature_s();
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumTxRequest.signature_s)
}
inline void EthereumTxRequest::set_signature_s(const void* value, size_t size) {
  set_has_signature_s();
  signature_s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumTxRequest.signature_s)
}
inline ::std::string* EthereumTxRequest::mutable_signature_s() {
  set_has_signature_s();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumTxRequest.signature_s)
  return signature_s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumTxRequest::release_signature_s() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumTxRequest.signature_s)
  clear_has_signature_s();
  return signature_s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumTxRequest::set_allocated_signature_s(::std::string* signature_s) {
  if (signature_s != NULL) {
    set_has_signature_s();
  } else {
    clear_has_signature_s();
  }
  signature_s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature_s);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumTxRequest.signature_s)
}

// -------------------------------------------------------------------

// EthereumTxAck

// optional bytes data_chunk = 1;
inline bool EthereumTxAck::has_data_chunk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EthereumTxAck::set_has_data_chunk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EthereumTxAck::clear_has_data_chunk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EthereumTxAck::clear_data_chunk() {
  data_chunk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_chunk();
}
inline const ::std::string& EthereumTxAck::data_chunk() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.EthereumTxAck.data_chunk)
  return data_chunk_.GetNoArena();
}
inline void EthereumTxAck::set_data_chunk(const ::std::string& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.EthereumTxAck.data_chunk)
}
#if LANG_CXX11
inline void EthereumTxAck::set_data_chunk(::std::string&& value) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.EthereumTxAck.data_chunk)
}
#endif
inline void EthereumTxAck::set_data_chunk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.EthereumTxAck.data_chunk)
}
inline void EthereumTxAck::set_data_chunk(const void* value, size_t size) {
  set_has_data_chunk();
  data_chunk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.EthereumTxAck.data_chunk)
}
inline ::std::string* EthereumTxAck::mutable_data_chunk() {
  set_has_data_chunk();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.EthereumTxAck.data_chunk)
  return data_chunk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EthereumTxAck::release_data_chunk() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.EthereumTxAck.data_chunk)
  clear_has_data_chunk();
  return data_chunk_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EthereumTxAck::set_allocated_data_chunk(::std::string* data_chunk) {
  if (data_chunk != NULL) {
    set_has_data_chunk();
  } else {
    clear_has_data_chunk();
  }
  data_chunk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_chunk);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.EthereumTxAck.data_chunk)
}

// -------------------------------------------------------------------

// SignIdentity

// optional .TrezorProtobuf.IdentityType identity = 1;
inline bool SignIdentity::has_identity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignIdentity::set_has_identity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignIdentity::clear_has_identity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignIdentity::clear_identity() {
  if (identity_ != NULL) identity_->::TrezorProtobuf::IdentityType::Clear();
  clear_has_identity();
}
inline const ::TrezorProtobuf::IdentityType& SignIdentity::identity() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.identity)
  return identity_ != NULL ? *identity_
                         : *::TrezorProtobuf::IdentityType::internal_default_instance();
}
inline ::TrezorProtobuf::IdentityType* SignIdentity::mutable_identity() {
  set_has_identity();
  if (identity_ == NULL) {
    identity_ = new ::TrezorProtobuf::IdentityType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.identity)
  return identity_;
}
inline ::TrezorProtobuf::IdentityType* SignIdentity::release_identity() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.identity)
  clear_has_identity();
  ::TrezorProtobuf::IdentityType* temp = identity_;
  identity_ = NULL;
  return temp;
}
inline void SignIdentity::set_allocated_identity(::TrezorProtobuf::IdentityType* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.identity)
}

// optional bytes challenge_hidden = 2;
inline bool SignIdentity::has_challenge_hidden() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignIdentity::set_has_challenge_hidden() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignIdentity::clear_has_challenge_hidden() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignIdentity::clear_challenge_hidden() {
  challenge_hidden_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_challenge_hidden();
}
inline const ::std::string& SignIdentity::challenge_hidden() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.challenge_hidden)
  return challenge_hidden_.GetNoArena();
}
inline void SignIdentity::set_challenge_hidden(const ::std::string& value) {
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignIdentity.challenge_hidden)
}
#if LANG_CXX11
inline void SignIdentity::set_challenge_hidden(::std::string&& value) {
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignIdentity.challenge_hidden)
}
#endif
inline void SignIdentity::set_challenge_hidden(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignIdentity.challenge_hidden)
}
inline void SignIdentity::set_challenge_hidden(const void* value, size_t size) {
  set_has_challenge_hidden();
  challenge_hidden_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignIdentity.challenge_hidden)
}
inline ::std::string* SignIdentity::mutable_challenge_hidden() {
  set_has_challenge_hidden();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.challenge_hidden)
  return challenge_hidden_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignIdentity::release_challenge_hidden() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.challenge_hidden)
  clear_has_challenge_hidden();
  return challenge_hidden_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignIdentity::set_allocated_challenge_hidden(::std::string* challenge_hidden) {
  if (challenge_hidden != NULL) {
    set_has_challenge_hidden();
  } else {
    clear_has_challenge_hidden();
  }
  challenge_hidden_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), challenge_hidden);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.challenge_hidden)
}

// optional string challenge_visual = 3;
inline bool SignIdentity::has_challenge_visual() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignIdentity::set_has_challenge_visual() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignIdentity::clear_has_challenge_visual() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignIdentity::clear_challenge_visual() {
  challenge_visual_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_challenge_visual();
}
inline const ::std::string& SignIdentity::challenge_visual() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.challenge_visual)
  return challenge_visual_.GetNoArena();
}
inline void SignIdentity::set_challenge_visual(const ::std::string& value) {
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignIdentity.challenge_visual)
}
#if LANG_CXX11
inline void SignIdentity::set_challenge_visual(::std::string&& value) {
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignIdentity.challenge_visual)
}
#endif
inline void SignIdentity::set_challenge_visual(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignIdentity.challenge_visual)
}
inline void SignIdentity::set_challenge_visual(const char* value, size_t size) {
  set_has_challenge_visual();
  challenge_visual_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignIdentity.challenge_visual)
}
inline ::std::string* SignIdentity::mutable_challenge_visual() {
  set_has_challenge_visual();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.challenge_visual)
  return challenge_visual_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignIdentity::release_challenge_visual() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.challenge_visual)
  clear_has_challenge_visual();
  return challenge_visual_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignIdentity::set_allocated_challenge_visual(::std::string* challenge_visual) {
  if (challenge_visual != NULL) {
    set_has_challenge_visual();
  } else {
    clear_has_challenge_visual();
  }
  challenge_visual_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), challenge_visual);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.challenge_visual)
}

// optional string ecdsa_curve_name = 4;
inline bool SignIdentity::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignIdentity::set_has_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignIdentity::clear_has_ecdsa_curve_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignIdentity::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecdsa_curve_name();
}
inline const ::std::string& SignIdentity::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
inline void SignIdentity::set_ecdsa_curve_name(const ::std::string& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
#if LANG_CXX11
inline void SignIdentity::set_ecdsa_curve_name(::std::string&& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
#endif
inline void SignIdentity::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
inline void SignIdentity::set_ecdsa_curve_name(const char* value, size_t size) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}
inline ::std::string* SignIdentity::mutable_ecdsa_curve_name() {
  set_has_ecdsa_curve_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignIdentity::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
  clear_has_ecdsa_curve_name();
  return ecdsa_curve_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignIdentity::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != NULL) {
    set_has_ecdsa_curve_name();
  } else {
    clear_has_ecdsa_curve_name();
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignIdentity.ecdsa_curve_name)
}

// -------------------------------------------------------------------

// SignedIdentity

// optional string address = 1;
inline bool SignedIdentity::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedIdentity::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedIdentity::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedIdentity::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& SignedIdentity::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignedIdentity.address)
  return address_.GetNoArena();
}
inline void SignedIdentity::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignedIdentity.address)
}
#if LANG_CXX11
inline void SignedIdentity::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignedIdentity.address)
}
#endif
inline void SignedIdentity::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignedIdentity.address)
}
inline void SignedIdentity::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignedIdentity.address)
}
inline ::std::string* SignedIdentity::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignedIdentity.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedIdentity::release_address() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignedIdentity.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedIdentity::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignedIdentity.address)
}

// optional bytes public_key = 2;
inline bool SignedIdentity::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedIdentity::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedIdentity::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedIdentity::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& SignedIdentity::public_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignedIdentity.public_key)
  return public_key_.GetNoArena();
}
inline void SignedIdentity::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignedIdentity.public_key)
}
#if LANG_CXX11
inline void SignedIdentity::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignedIdentity.public_key)
}
#endif
inline void SignedIdentity::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignedIdentity.public_key)
}
inline void SignedIdentity::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignedIdentity.public_key)
}
inline ::std::string* SignedIdentity::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignedIdentity.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedIdentity::release_public_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignedIdentity.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedIdentity::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignedIdentity.public_key)
}

// optional bytes signature = 3;
inline bool SignedIdentity::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedIdentity::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedIdentity::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedIdentity::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& SignedIdentity::signature() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SignedIdentity.signature)
  return signature_.GetNoArena();
}
inline void SignedIdentity::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SignedIdentity.signature)
}
#if LANG_CXX11
inline void SignedIdentity::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.SignedIdentity.signature)
}
#endif
inline void SignedIdentity::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.SignedIdentity.signature)
}
inline void SignedIdentity::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.SignedIdentity.signature)
}
inline ::std::string* SignedIdentity::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.SignedIdentity.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedIdentity::release_signature() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.SignedIdentity.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedIdentity::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.SignedIdentity.signature)
}

// -------------------------------------------------------------------

// GetECDHSessionKey

// optional .TrezorProtobuf.IdentityType identity = 1;
inline bool GetECDHSessionKey::has_identity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetECDHSessionKey::set_has_identity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetECDHSessionKey::clear_has_identity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetECDHSessionKey::clear_identity() {
  if (identity_ != NULL) identity_->::TrezorProtobuf::IdentityType::Clear();
  clear_has_identity();
}
inline const ::TrezorProtobuf::IdentityType& GetECDHSessionKey::identity() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetECDHSessionKey.identity)
  return identity_ != NULL ? *identity_
                         : *::TrezorProtobuf::IdentityType::internal_default_instance();
}
inline ::TrezorProtobuf::IdentityType* GetECDHSessionKey::mutable_identity() {
  set_has_identity();
  if (identity_ == NULL) {
    identity_ = new ::TrezorProtobuf::IdentityType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetECDHSessionKey.identity)
  return identity_;
}
inline ::TrezorProtobuf::IdentityType* GetECDHSessionKey::release_identity() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetECDHSessionKey.identity)
  clear_has_identity();
  ::TrezorProtobuf::IdentityType* temp = identity_;
  identity_ = NULL;
  return temp;
}
inline void GetECDHSessionKey::set_allocated_identity(::TrezorProtobuf::IdentityType* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetECDHSessionKey.identity)
}

// optional bytes peer_public_key = 2;
inline bool GetECDHSessionKey::has_peer_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetECDHSessionKey::set_has_peer_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetECDHSessionKey::clear_has_peer_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetECDHSessionKey::clear_peer_public_key() {
  peer_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_public_key();
}
inline const ::std::string& GetECDHSessionKey::peer_public_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
  return peer_public_key_.GetNoArena();
}
inline void GetECDHSessionKey::set_peer_public_key(const ::std::string& value) {
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
#if LANG_CXX11
inline void GetECDHSessionKey::set_peer_public_key(::std::string&& value) {
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
#endif
inline void GetECDHSessionKey::set_peer_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
inline void GetECDHSessionKey::set_peer_public_key(const void* value, size_t size) {
  set_has_peer_public_key();
  peer_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}
inline ::std::string* GetECDHSessionKey::mutable_peer_public_key() {
  set_has_peer_public_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
  return peer_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetECDHSessionKey::release_peer_public_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
  clear_has_peer_public_key();
  return peer_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetECDHSessionKey::set_allocated_peer_public_key(::std::string* peer_public_key) {
  if (peer_public_key != NULL) {
    set_has_peer_public_key();
  } else {
    clear_has_peer_public_key();
  }
  peer_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_public_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetECDHSessionKey.peer_public_key)
}

// optional string ecdsa_curve_name = 3;
inline bool GetECDHSessionKey::has_ecdsa_curve_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetECDHSessionKey::set_has_ecdsa_curve_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetECDHSessionKey::clear_has_ecdsa_curve_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetECDHSessionKey::clear_ecdsa_curve_name() {
  ecdsa_curve_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ecdsa_curve_name();
}
inline const ::std::string& GetECDHSessionKey::ecdsa_curve_name() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
  return ecdsa_curve_name_.GetNoArena();
}
inline void GetECDHSessionKey::set_ecdsa_curve_name(const ::std::string& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
#if LANG_CXX11
inline void GetECDHSessionKey::set_ecdsa_curve_name(::std::string&& value) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
#endif
inline void GetECDHSessionKey::set_ecdsa_curve_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
inline void GetECDHSessionKey::set_ecdsa_curve_name(const char* value, size_t size) {
  set_has_ecdsa_curve_name();
  ecdsa_curve_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}
inline ::std::string* GetECDHSessionKey::mutable_ecdsa_curve_name() {
  set_has_ecdsa_curve_name();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
  return ecdsa_curve_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetECDHSessionKey::release_ecdsa_curve_name() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
  clear_has_ecdsa_curve_name();
  return ecdsa_curve_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetECDHSessionKey::set_allocated_ecdsa_curve_name(::std::string* ecdsa_curve_name) {
  if (ecdsa_curve_name != NULL) {
    set_has_ecdsa_curve_name();
  } else {
    clear_has_ecdsa_curve_name();
  }
  ecdsa_curve_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ecdsa_curve_name);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.GetECDHSessionKey.ecdsa_curve_name)
}

// -------------------------------------------------------------------

// ECDHSessionKey

// optional bytes session_key = 1;
inline bool ECDHSessionKey::has_session_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECDHSessionKey::set_has_session_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ECDHSessionKey::clear_has_session_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ECDHSessionKey::clear_session_key() {
  session_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_key();
}
inline const ::std::string& ECDHSessionKey::session_key() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.ECDHSessionKey.session_key)
  return session_key_.GetNoArena();
}
inline void ECDHSessionKey::set_session_key(const ::std::string& value) {
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.ECDHSessionKey.session_key)
}
#if LANG_CXX11
inline void ECDHSessionKey::set_session_key(::std::string&& value) {
  set_has_session_key();
  session_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.ECDHSessionKey.session_key)
}
#endif
inline void ECDHSessionKey::set_session_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.ECDHSessionKey.session_key)
}
inline void ECDHSessionKey::set_session_key(const void* value, size_t size) {
  set_has_session_key();
  session_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.ECDHSessionKey.session_key)
}
inline ::std::string* ECDHSessionKey::mutable_session_key() {
  set_has_session_key();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.ECDHSessionKey.session_key)
  return session_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ECDHSessionKey::release_session_key() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.ECDHSessionKey.session_key)
  clear_has_session_key();
  return session_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ECDHSessionKey::set_allocated_session_key(::std::string* session_key) {
  if (session_key != NULL) {
    set_has_session_key();
  } else {
    clear_has_session_key();
  }
  session_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_key);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.ECDHSessionKey.session_key)
}

// -------------------------------------------------------------------

// SetU2FCounter

// optional uint32 u2f_counter = 1;
inline bool SetU2FCounter::has_u2f_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetU2FCounter::set_has_u2f_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetU2FCounter::clear_has_u2f_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetU2FCounter::clear_u2f_counter() {
  u2f_counter_ = 0u;
  clear_has_u2f_counter();
}
inline ::google::protobuf::uint32 SetU2FCounter::u2f_counter() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.SetU2FCounter.u2f_counter)
  return u2f_counter_;
}
inline void SetU2FCounter::set_u2f_counter(::google::protobuf::uint32 value) {
  set_has_u2f_counter();
  u2f_counter_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.SetU2FCounter.u2f_counter)
}

// -------------------------------------------------------------------

// FirmwareErase

// -------------------------------------------------------------------

// FirmwareRequest

// optional uint32 offset = 1;
inline bool FirmwareRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FirmwareRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FirmwareRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FirmwareRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 FirmwareRequest::offset() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareRequest.offset)
  return offset_;
}
inline void FirmwareRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareRequest.offset)
}

// optional uint32 length = 2;
inline bool FirmwareRequest::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FirmwareRequest::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FirmwareRequest::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FirmwareRequest::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 FirmwareRequest::length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareRequest.length)
  return length_;
}
inline void FirmwareRequest::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareRequest.length)
}

// -------------------------------------------------------------------

// FirmwareUpload

// required bytes payload = 1;
inline bool FirmwareUpload::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FirmwareUpload::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FirmwareUpload::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FirmwareUpload::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& FirmwareUpload::payload() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareUpload.payload)
  return payload_.GetNoArena();
}
inline void FirmwareUpload::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareUpload.payload)
}
#if LANG_CXX11
inline void FirmwareUpload::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.FirmwareUpload.payload)
}
#endif
inline void FirmwareUpload::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.FirmwareUpload.payload)
}
inline void FirmwareUpload::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.FirmwareUpload.payload)
}
inline ::std::string* FirmwareUpload::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.FirmwareUpload.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FirmwareUpload::release_payload() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.FirmwareUpload.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FirmwareUpload::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.FirmwareUpload.payload)
}

// optional bytes hash = 2;
inline bool FirmwareUpload::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FirmwareUpload::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FirmwareUpload::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FirmwareUpload::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& FirmwareUpload::hash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.FirmwareUpload.hash)
  return hash_.GetNoArena();
}
inline void FirmwareUpload::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.FirmwareUpload.hash)
}
#if LANG_CXX11
inline void FirmwareUpload::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.FirmwareUpload.hash)
}
#endif
inline void FirmwareUpload::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.FirmwareUpload.hash)
}
inline void FirmwareUpload::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.FirmwareUpload.hash)
}
inline ::std::string* FirmwareUpload::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.FirmwareUpload.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FirmwareUpload::release_hash() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.FirmwareUpload.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FirmwareUpload::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.FirmwareUpload.hash)
}

// -------------------------------------------------------------------

// DebugLinkDecision

// required bool yes_no = 1;
inline bool DebugLinkDecision::has_yes_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkDecision::set_has_yes_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkDecision::clear_has_yes_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkDecision::clear_yes_no() {
  yes_no_ = false;
  clear_has_yes_no();
}
inline bool DebugLinkDecision::yes_no() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkDecision.yes_no)
  return yes_no_;
}
inline void DebugLinkDecision::set_yes_no(bool value) {
  set_has_yes_no();
  yes_no_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkDecision.yes_no)
}

// -------------------------------------------------------------------

// DebugLinkGetState

// -------------------------------------------------------------------

// DebugLinkState

// optional bytes layout = 1;
inline bool DebugLinkState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkState::clear_layout() {
  layout_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_layout();
}
inline const ::std::string& DebugLinkState::layout() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.layout)
  return layout_.GetNoArena();
}
inline void DebugLinkState::set_layout(const ::std::string& value) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.layout)
}
#if LANG_CXX11
inline void DebugLinkState::set_layout(::std::string&& value) {
  set_has_layout();
  layout_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.layout)
}
#endif
inline void DebugLinkState::set_layout(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.layout)
}
inline void DebugLinkState::set_layout(const void* value, size_t size) {
  set_has_layout();
  layout_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.layout)
}
inline ::std::string* DebugLinkState::mutable_layout() {
  set_has_layout();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.layout)
  return layout_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_layout() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.layout)
  clear_has_layout();
  return layout_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_layout(::std::string* layout) {
  if (layout != NULL) {
    set_has_layout();
  } else {
    clear_has_layout();
  }
  layout_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), layout);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.layout)
}

// optional string pin = 2;
inline bool DebugLinkState::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkState::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkState::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
inline const ::std::string& DebugLinkState::pin() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.pin)
  return pin_.GetNoArena();
}
inline void DebugLinkState::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.pin)
}
#if LANG_CXX11
inline void DebugLinkState::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.pin)
}
#endif
inline void DebugLinkState::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.pin)
}
inline void DebugLinkState::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.pin)
}
inline ::std::string* DebugLinkState::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_pin() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.pin)
}

// optional string matrix = 3;
inline bool DebugLinkState::has_matrix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkState::set_has_matrix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkState::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkState::clear_matrix() {
  matrix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_matrix();
}
inline const ::std::string& DebugLinkState::matrix() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.matrix)
  return matrix_.GetNoArena();
}
inline void DebugLinkState::set_matrix(const ::std::string& value) {
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.matrix)
}
#if LANG_CXX11
inline void DebugLinkState::set_matrix(::std::string&& value) {
  set_has_matrix();
  matrix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.matrix)
}
#endif
inline void DebugLinkState::set_matrix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.matrix)
}
inline void DebugLinkState::set_matrix(const char* value, size_t size) {
  set_has_matrix();
  matrix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.matrix)
}
inline ::std::string* DebugLinkState::mutable_matrix() {
  set_has_matrix();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.matrix)
  return matrix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_matrix() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.matrix)
  clear_has_matrix();
  return matrix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_matrix(::std::string* matrix) {
  if (matrix != NULL) {
    set_has_matrix();
  } else {
    clear_has_matrix();
  }
  matrix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), matrix);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.matrix)
}

// optional string mnemonic = 4;
inline bool DebugLinkState::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkState::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugLinkState::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugLinkState::clear_mnemonic() {
  mnemonic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mnemonic();
}
inline const ::std::string& DebugLinkState::mnemonic() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.mnemonic)
  return mnemonic_.GetNoArena();
}
inline void DebugLinkState::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.mnemonic)
}
#if LANG_CXX11
inline void DebugLinkState::set_mnemonic(::std::string&& value) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.mnemonic)
}
#endif
inline void DebugLinkState::set_mnemonic(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.mnemonic)
}
inline void DebugLinkState::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  mnemonic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.mnemonic)
}
inline ::std::string* DebugLinkState::mutable_mnemonic() {
  set_has_mnemonic();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.mnemonic)
  return mnemonic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_mnemonic() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.mnemonic)
  clear_has_mnemonic();
  return mnemonic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic != NULL) {
    set_has_mnemonic();
  } else {
    clear_has_mnemonic();
  }
  mnemonic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mnemonic);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.mnemonic)
}

// optional .TrezorProtobuf.HDNodeType node = 5;
inline bool DebugLinkState::has_node() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DebugLinkState::set_has_node() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DebugLinkState::clear_has_node() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DebugLinkState::clear_node() {
  if (node_ != NULL) node_->::TrezorProtobuf::HDNodeType::Clear();
  clear_has_node();
}
inline const ::TrezorProtobuf::HDNodeType& DebugLinkState::node() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.node)
  return node_ != NULL ? *node_
                         : *::TrezorProtobuf::HDNodeType::internal_default_instance();
}
inline ::TrezorProtobuf::HDNodeType* DebugLinkState::mutable_node() {
  set_has_node();
  if (node_ == NULL) {
    node_ = new ::TrezorProtobuf::HDNodeType;
  }
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.node)
  return node_;
}
inline ::TrezorProtobuf::HDNodeType* DebugLinkState::release_node() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.node)
  clear_has_node();
  ::TrezorProtobuf::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void DebugLinkState::set_allocated_node(::TrezorProtobuf::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.node)
}

// optional bool passphrase_protection = 6;
inline bool DebugLinkState::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DebugLinkState::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DebugLinkState::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DebugLinkState::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool DebugLinkState::passphrase_protection() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.passphrase_protection)
  return passphrase_protection_;
}
inline void DebugLinkState::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.passphrase_protection)
}

// optional string reset_word = 7;
inline bool DebugLinkState::has_reset_word() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugLinkState::set_has_reset_word() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DebugLinkState::clear_has_reset_word() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DebugLinkState::clear_reset_word() {
  reset_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reset_word();
}
inline const ::std::string& DebugLinkState::reset_word() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.reset_word)
  return reset_word_.GetNoArena();
}
inline void DebugLinkState::set_reset_word(const ::std::string& value) {
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.reset_word)
}
#if LANG_CXX11
inline void DebugLinkState::set_reset_word(::std::string&& value) {
  set_has_reset_word();
  reset_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.reset_word)
}
#endif
inline void DebugLinkState::set_reset_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.reset_word)
}
inline void DebugLinkState::set_reset_word(const char* value, size_t size) {
  set_has_reset_word();
  reset_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.reset_word)
}
inline ::std::string* DebugLinkState::mutable_reset_word() {
  set_has_reset_word();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.reset_word)
  return reset_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_reset_word() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.reset_word)
  clear_has_reset_word();
  return reset_word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_reset_word(::std::string* reset_word) {
  if (reset_word != NULL) {
    set_has_reset_word();
  } else {
    clear_has_reset_word();
  }
  reset_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_word);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.reset_word)
}

// optional bytes reset_entropy = 8;
inline bool DebugLinkState::has_reset_entropy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DebugLinkState::set_has_reset_entropy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DebugLinkState::clear_has_reset_entropy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DebugLinkState::clear_reset_entropy() {
  reset_entropy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reset_entropy();
}
inline const ::std::string& DebugLinkState::reset_entropy() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.reset_entropy)
  return reset_entropy_.GetNoArena();
}
inline void DebugLinkState::set_reset_entropy(const ::std::string& value) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.reset_entropy)
}
#if LANG_CXX11
inline void DebugLinkState::set_reset_entropy(::std::string&& value) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.reset_entropy)
}
#endif
inline void DebugLinkState::set_reset_entropy(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.reset_entropy)
}
inline void DebugLinkState::set_reset_entropy(const void* value, size_t size) {
  set_has_reset_entropy();
  reset_entropy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.reset_entropy)
}
inline ::std::string* DebugLinkState::mutable_reset_entropy() {
  set_has_reset_entropy();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.reset_entropy)
  return reset_entropy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_reset_entropy() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.reset_entropy)
  clear_has_reset_entropy();
  return reset_entropy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_reset_entropy(::std::string* reset_entropy) {
  if (reset_entropy != NULL) {
    set_has_reset_entropy();
  } else {
    clear_has_reset_entropy();
  }
  reset_entropy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reset_entropy);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.reset_entropy)
}

// optional string recovery_fake_word = 9;
inline bool DebugLinkState::has_recovery_fake_word() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DebugLinkState::set_has_recovery_fake_word() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DebugLinkState::clear_has_recovery_fake_word() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DebugLinkState::clear_recovery_fake_word() {
  recovery_fake_word_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_recovery_fake_word();
}
inline const ::std::string& DebugLinkState::recovery_fake_word() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.GetNoArena();
}
inline void DebugLinkState::set_recovery_fake_word(const ::std::string& value) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
#if LANG_CXX11
inline void DebugLinkState::set_recovery_fake_word(::std::string&& value) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
#endif
inline void DebugLinkState::set_recovery_fake_word(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
inline void DebugLinkState::set_recovery_fake_word(const char* value, size_t size) {
  set_has_recovery_fake_word();
  recovery_fake_word_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}
inline ::std::string* DebugLinkState::mutable_recovery_fake_word() {
  set_has_recovery_fake_word();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkState.recovery_fake_word)
  return recovery_fake_word_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkState::release_recovery_fake_word() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkState.recovery_fake_word)
  clear_has_recovery_fake_word();
  return recovery_fake_word_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkState::set_allocated_recovery_fake_word(::std::string* recovery_fake_word) {
  if (recovery_fake_word != NULL) {
    set_has_recovery_fake_word();
  } else {
    clear_has_recovery_fake_word();
  }
  recovery_fake_word_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recovery_fake_word);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkState.recovery_fake_word)
}

// optional uint32 recovery_word_pos = 10;
inline bool DebugLinkState::has_recovery_word_pos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DebugLinkState::set_has_recovery_word_pos() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DebugLinkState::clear_has_recovery_word_pos() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DebugLinkState::clear_recovery_word_pos() {
  recovery_word_pos_ = 0u;
  clear_has_recovery_word_pos();
}
inline ::google::protobuf::uint32 DebugLinkState::recovery_word_pos() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkState.recovery_word_pos)
  return recovery_word_pos_;
}
inline void DebugLinkState::set_recovery_word_pos(::google::protobuf::uint32 value) {
  set_has_recovery_word_pos();
  recovery_word_pos_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkState.recovery_word_pos)
}

// -------------------------------------------------------------------

// DebugLinkStop

// -------------------------------------------------------------------

// DebugLinkLog

// optional uint32 level = 1;
inline bool DebugLinkLog::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkLog::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkLog::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkLog::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 DebugLinkLog::level() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkLog.level)
  return level_;
}
inline void DebugLinkLog::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkLog.level)
}

// optional string bucket = 2;
inline bool DebugLinkLog::has_bucket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkLog::set_has_bucket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkLog::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkLog::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bucket();
}
inline const ::std::string& DebugLinkLog::bucket() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkLog.bucket)
  return bucket_.GetNoArena();
}
inline void DebugLinkLog::set_bucket(const ::std::string& value) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkLog.bucket)
}
#if LANG_CXX11
inline void DebugLinkLog::set_bucket(::std::string&& value) {
  set_has_bucket();
  bucket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkLog.bucket)
}
#endif
inline void DebugLinkLog::set_bucket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkLog.bucket)
}
inline void DebugLinkLog::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkLog.bucket)
}
inline ::std::string* DebugLinkLog::mutable_bucket() {
  set_has_bucket();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkLog.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkLog::release_bucket() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkLog.bucket)
  clear_has_bucket();
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkLog::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    set_has_bucket();
  } else {
    clear_has_bucket();
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkLog.bucket)
}

// optional string text = 3;
inline bool DebugLinkLog::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkLog::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkLog::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkLog::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& DebugLinkLog::text() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkLog.text)
  return text_.GetNoArena();
}
inline void DebugLinkLog::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkLog.text)
}
#if LANG_CXX11
inline void DebugLinkLog::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkLog.text)
}
#endif
inline void DebugLinkLog::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkLog.text)
}
inline void DebugLinkLog::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkLog.text)
}
inline ::std::string* DebugLinkLog::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkLog.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkLog::release_text() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkLog.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkLog::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkLog.text)
}

// -------------------------------------------------------------------

// DebugLinkMemoryRead

// optional uint32 address = 1;
inline bool DebugLinkMemoryRead::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemoryRead::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkMemoryRead::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkMemoryRead::clear_address() {
  address_ = 0u;
  clear_has_address();
}
inline ::google::protobuf::uint32 DebugLinkMemoryRead::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryRead.address)
  return address_;
}
inline void DebugLinkMemoryRead::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryRead.address)
}

// optional uint32 length = 2;
inline bool DebugLinkMemoryRead::has_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkMemoryRead::set_has_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkMemoryRead::clear_has_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkMemoryRead::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 DebugLinkMemoryRead::length() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryRead.length)
  return length_;
}
inline void DebugLinkMemoryRead::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryRead.length)
}

// -------------------------------------------------------------------

// DebugLinkMemory

// optional bytes memory = 1;
inline bool DebugLinkMemory::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemory::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkMemory::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkMemory::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory();
}
inline const ::std::string& DebugLinkMemory::memory() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemory.memory)
  return memory_.GetNoArena();
}
inline void DebugLinkMemory::set_memory(const ::std::string& value) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemory.memory)
}
#if LANG_CXX11
inline void DebugLinkMemory::set_memory(::std::string&& value) {
  set_has_memory();
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkMemory.memory)
}
#endif
inline void DebugLinkMemory::set_memory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkMemory.memory)
}
inline void DebugLinkMemory::set_memory(const void* value, size_t size) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkMemory.memory)
}
inline ::std::string* DebugLinkMemory::mutable_memory() {
  set_has_memory();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkMemory.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkMemory::release_memory() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkMemory.memory)
  clear_has_memory();
  return memory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkMemory::set_allocated_memory(::std::string* memory) {
  if (memory != NULL) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkMemory.memory)
}

// -------------------------------------------------------------------

// DebugLinkMemoryWrite

// optional uint32 address = 1;
inline bool DebugLinkMemoryWrite::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkMemoryWrite::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkMemoryWrite::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkMemoryWrite::clear_address() {
  address_ = 0u;
  clear_has_address();
}
inline ::google::protobuf::uint32 DebugLinkMemoryWrite::address() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryWrite.address)
  return address_;
}
inline void DebugLinkMemoryWrite::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryWrite.address)
}

// optional bytes memory = 2;
inline bool DebugLinkMemoryWrite::has_memory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkMemoryWrite::set_has_memory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkMemoryWrite::clear_has_memory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkMemoryWrite::clear_memory() {
  memory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_memory();
}
inline const ::std::string& DebugLinkMemoryWrite::memory() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryWrite.memory)
  return memory_.GetNoArena();
}
inline void DebugLinkMemoryWrite::set_memory(const ::std::string& value) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
#if LANG_CXX11
inline void DebugLinkMemoryWrite::set_memory(::std::string&& value) {
  set_has_memory();
  memory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
#endif
inline void DebugLinkMemoryWrite::set_memory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
inline void DebugLinkMemoryWrite::set_memory(const void* value, size_t size) {
  set_has_memory();
  memory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}
inline ::std::string* DebugLinkMemoryWrite::mutable_memory() {
  set_has_memory();
  // @@protoc_insertion_point(field_mutable:TrezorProtobuf.DebugLinkMemoryWrite.memory)
  return memory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugLinkMemoryWrite::release_memory() {
  // @@protoc_insertion_point(field_release:TrezorProtobuf.DebugLinkMemoryWrite.memory)
  clear_has_memory();
  return memory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugLinkMemoryWrite::set_allocated_memory(::std::string* memory) {
  if (memory != NULL) {
    set_has_memory();
  } else {
    clear_has_memory();
  }
  memory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), memory);
  // @@protoc_insertion_point(field_set_allocated:TrezorProtobuf.DebugLinkMemoryWrite.memory)
}

// optional bool flash = 3;
inline bool DebugLinkMemoryWrite::has_flash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkMemoryWrite::set_has_flash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkMemoryWrite::clear_has_flash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkMemoryWrite::clear_flash() {
  flash_ = false;
  clear_has_flash();
}
inline bool DebugLinkMemoryWrite::flash() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkMemoryWrite.flash)
  return flash_;
}
inline void DebugLinkMemoryWrite::set_flash(bool value) {
  set_has_flash();
  flash_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkMemoryWrite.flash)
}

// -------------------------------------------------------------------

// DebugLinkFlashErase

// optional uint32 sector = 1;
inline bool DebugLinkFlashErase::has_sector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkFlashErase::set_has_sector() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkFlashErase::clear_has_sector() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkFlashErase::clear_sector() {
  sector_ = 0u;
  clear_has_sector();
}
inline ::google::protobuf::uint32 DebugLinkFlashErase::sector() const {
  // @@protoc_insertion_point(field_get:TrezorProtobuf.DebugLinkFlashErase.sector)
  return sector_;
}
inline void DebugLinkFlashErase::set_sector(::google::protobuf::uint32 value) {
  set_has_sector();
  sector_ = value;
  // @@protoc_insertion_point(field_set:TrezorProtobuf.DebugLinkFlashErase.sector)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace TrezorProtobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TrezorProtobuf::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TrezorProtobuf::MessageType>() {
  return ::TrezorProtobuf::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
